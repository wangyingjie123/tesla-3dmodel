import{l as ox,L as ax,s as Pa,a as ix}from"./vendor-5fa84e51.js";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ux=1e-7,cx=1e-4;class Tp{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Fa{refCount(e){return Le("refCount")}incRef(e){return Le("incRef")}timerAvailable(){return!0}time(e){return Le("time")}read(e){return Le("read")}readSync(e){return Le("readSync")}readToGPU(e,t){return Le("readToGPU")}numDataIds(){return Le("numDataIds")}disposeData(e,t){return Le("disposeData")}write(e,t,s){return Le("write")}move(e,t,s,r,o){return Le("move")}createTensorFromGPUData(e,t,s){return Le("createTensorFromGPUData")}memory(){return Le("memory")}floatPrecision(){return Le("floatPrecision")}epsilon(){return this.floatPrecision()===32?ux:cx}dispose(){return Le("dispose")}}function Le(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Dt(n,e,t)}function lx(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Dt(n,t,s),Dt(e,t,s)}function Is(n,e,t){return Math.max(n,Math.min(e,t))}function so(n){return n%2===0?n:n+1}function Dt(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function Ep(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function dx(n,e){const t=Math.random();return e*t+(1-t)*n}function px(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function v(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Ce(n,e,t=""){v(ce(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function On(n){v(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function P(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function hx(n){return n.length===0}function Ip(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function ce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function vn(n){return n%1===0}function fx(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function Pr(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function mx(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return Np(e),e}function xn(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Zo(n,e=r=>0,t,s){return new Promise((r,o)=>{let a=0;const i=()=>{if(n()){r();return}a++;const u=e(a);if(t!=null&&a>=t){o();return}s!=null?s(i,u):setTimeout(i,u)};i()})}function kp(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function me(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),v(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),v(n.every(s=>vn(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function zt(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:me(e,n).sort();let a=0;for(let i=0;i<n.length;++i){if(o!=null){if(o[a]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(o[a]==null||o[a]>i)&&n[i]===1&&(t.push(n[i]),s.push(i)),o[a]<=i&&a++}n[i]!==1&&(t.push(n[i]),s.push(i))}return{newShape:t,keptDims:s}}function Mt(n,e){return fe(n,e)}function fe(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Rp(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function _p(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Ap(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function ks(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Op(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ft(n){return typeof n=="string"||n instanceof String}function Dp(n){return typeof n=="boolean"}function Pp(n){return typeof n=="number"}function rs(n){return Array.isArray(n)?rs(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Pp(n)?"float32":Ft(n)?"string":Dp(n)?"bool":"float32"}function Jt(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Fr(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function xe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function Fp(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=t[n+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((u,c)=>u*c)*(s?2:1);for(let u=0;u<o;u++)r[u]=Fp(n+u*i,a,t,s)}return r}function bn(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Fp(0,n,e,t)}function gx(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function La(n,e){const t=Wt(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Wt(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function yx(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return bn(n,new Float32Array(t));if(e==="int32")return bn(n,new Int32Array(t));if(e==="bool")return bn(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function ze(n){n.forEach(e=>{v(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Lr(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function ro(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function en(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ad="tfjsflags";class Lp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=xx,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(en(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);ad in e&&e[ad].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=wx(r,o)})}}function xx(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(bx(e,s[0],s[1]),s.join("="))),e}function bx(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function wx(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function I(){return Ba}let Ba=null;function $x(n){Ba=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Po;function Bp(){if(Po==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Po=n}return Po}function vx(){const n=Bp();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Va(n,e){const t=vx();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Ma="Abs",Wa="Acos",Ua="Acosh",oo="Add",za="AddN",Ga="All",Ha="Any",ja="ArgMax",Ka="ArgMin",qa="Asin",Xa="Asinh",Ya="Atan",Qa="Atanh",Za="Atan2",Ja="AvgPool",Vp="AvgPoolGrad",ei="AvgPool3D",Mp="AvgPool3DGrad",ti="BatchMatMul",ni="BatchToSpaceND",si="Bincount",ri="BitwiseAnd",Sx="BroadcastTo",oi="BroadcastArgs",ao="Cast",ai="Ceil",ii="ClipByValue",ui="Complex",ci="ComplexAbs",li="Concat",di="Conv2D",pi="Conv2DBackpropFilter",hi="Conv2DBackpropInput",fi="Conv3D",Wp="Conv3DBackpropFilterV2",mi="Conv3DBackpropInputV2",gi="Cos",yi="Cosh",xi="Cumprod",bi="Cumsum",wi="CropAndResize",$i="DenseBincount",vi="DepthToSpace",Si="DepthwiseConv2dNative",Ci="DepthwiseConv2dNativeBackpropFilter",Ti="DepthwiseConv2dNativeBackpropInput",Ni="Diag",Ei="Dilation2D",Cx="Dilation2DBackpropInput",Tx="Dilation2DBackpropFilter",Ii="Draw",ki="RealDiv",Ri="Einsum",_i="Elu",Up="EluGrad",Ai="Erf",Oi="Equal",Di="Exp",Pi="ExpandDims",Fi="Expm1",Li="FFT",Bi="Fill",Vi="FlipLeftRight",Mi="Floor",Wi="FloorDiv",Ui="FusedBatchNorm",zi="GatherV2",Gi="GatherNd",Hi="Greater",ji="GreaterEqual",io="Identity",Ki="IFFT",qi="Imag",Xi="IsFinite",Yi="IsInf",Qi="IsNan",Zi="LeakyRelu",Ji="Less",eu="LessEqual",tu="LinSpace",nu="Log",su="Log1p",ru="LogicalAnd",ou="LogicalNot",au="LogicalOr",Nx="LogicalXor",Ex="LogSoftmax",Ix="LowerBound",iu="LRN",zp="LRNGrad",kx="MatrixBandPart",uu="Max",cu="Maximum",lu="MaxPool",Gp="MaxPoolGrad",du="MaxPool3D",Hp="MaxPool3DGrad",pu="MaxPoolWithArgmax",hu="Mean",fu="Min",mu="Minimum",gu="MirrorPad",yu="Mod",xu="Multinomial",bu="Multiply",wu="Neg",$u="NotEqual",vu="NonMaxSuppressionV3",Su="NonMaxSuppressionV4",Cu="NonMaxSuppressionV5",Tu="OnesLike",Nu="OneHot",Eu="Pack",Iu="PadV2",Rx="Pool",ku="Pow",Ru="Prelu",_u="Prod",Au="RaggedGather",Ou="RaggedRange",Du="RaggedTensorToTensor",Pu="Range",Fu="Real",Lu="Reciprocal",Bu="Relu",Vu="Reshape",Mu="ResizeNearestNeighbor",jp="ResizeNearestNeighborGrad",Wu="ResizeBilinear",Kp="ResizeBilinearGrad",Uu="Relu6",zu="Reverse",Gu="Round",Hu="Rsqrt",ju="ScatterNd",Ku="TensorScatterUpdate",qu="SearchSorted",Xu="Select",Yu="Selu",Qu="Slice",Zu="Sin",Ju="Sinh",ec="Sign",tc="Sigmoid",nc="Softplus",sc="Sqrt",rc="Sum",oc="SpaceToBatchND",ac="SplitV",ic="Softmax",uc="SparseFillEmptyRows",cc="SparseReshape",lc="SparseSegmentMean",dc="SparseSegmentSum",pc="SparseToDense",hc="SquaredDifference",qp="Square",fc="StaticRegexReplace",mc="StridedSlice",gc="StringNGrams",yc="StringSplit",xc="StringToHashBucketFast",bc="Sub",wc="Tan",$c="Tanh",uo="Tile",vc="TopK",Sc="Transform",Es="Transpose",Cc="Unique",Tc="Unpack",Nc="UnsortedSegmentSum",_x="UpperBound",Ec="ZerosLike",Ic="Step",Br="FromPixels",kc="RotateWithOffset",Vr="_FusedMatMul",Mr="FusedConv2D",Wr="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nt(...n){I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(...n)}function Ax(...n){I().getBool("IS_TEST")||I().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xn=Va("kernelRegistry",()=>new Map),Rs=Va("gradRegistry",()=>new Map);function _s(n,e){const t=_c(n,e);return Xn.get(t)}function Jo(n){return Rs.get(n)}function Ur(n){const e=Xn.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,a]=r,[i]=o.split("_");i===n&&t.push(a)}return t}function Rc(n){const{kernelName:e,backendName:t}=n,s=_c(e,t);Xn.has(s)&&nt(`The kernel '${e}' for backend '${t}' is already registered`),Xn.set(s,n)}function Ox(n){const{kernelName:e}=n;Rs.has(e)&&I().getBool("DEBUG")&&nt(`Overriding the gradient for '${e}'`),Rs.set(e,n)}function Dx(n,e){const t=_c(n,e);if(!Xn.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Xn.delete(t)}function Px(n){if(!Rs.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Rs.delete(n)}function Fx(n,e){Ur(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});Rc(r)})}function _c(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xp(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fn=ox||ax;function qs(n){return fn.fromString(n,!0,16)}const Yp=qs("c3a5c85c97cb3127"),hn=qs("b492b66fbe98f273"),Ie=qs("9ae16a3b2f90404f");function ea(n){return n.xor(n.shru(47))}function Qp(n,e,t){const s=n.slice(e,e+t);return fn.fromBytes(Array.from(s),!0,!0)}function ie(n,e){return Qp(n,e,8)}function id(n,e){return Qp(n,e,4)}function ge(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Zt(n,e,t=qs("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function Lx(n,e,t,s,r,o){r=r.add(n),o=ge(o.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),o=o.add(ge(r,44)),[r.add(s),o.add(a)]}function pr(n,e,t,s){return Lx(ie(n,e),ie(n,e+8),ie(n,e+16),ie(n,e+24),t,s)}function Bx(n,e=n.length){if(e>=8){const t=Ie.add(e*2),s=ie(n,0).add(Ie),r=ie(n,e-8),o=ge(r,37).mul(t).add(s),a=ge(s,25).add(r).mul(t);return Zt(o,a,t)}if(e>=4){const t=Ie.add(e*2),s=id(n,0);return Zt(s.shl(3).add(e),id(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),a=e+(r<<2);return ea(Ie.mul(o).xor(Yp.mul(a))).mul(Ie)}return Ie}function Vx(n,e=n.length){const t=Ie.add(e*2),s=ie(n,0).mul(hn),r=ie(n,8),o=ie(n,e-8).mul(t),a=ie(n,e-16).mul(Ie);return Zt(ge(s.add(r),43).add(ge(o,30)).add(a),s.add(ge(r.add(Ie),18)).add(o),t)}function Mx(n,e=n.length){const t=Ie.add(e*2),s=ie(n,0).mul(Ie),r=ie(n,8),o=ie(n,e-8).mul(t),a=ie(n,e-16).mul(Ie),i=ge(s.add(r),43).add(ge(o,30)).add(a),u=Zt(i,s.add(ge(r.add(Ie),18)).add(o),t),c=ie(n,16).mul(t),l=ie(n,24),d=i.add(ie(n,e-32)).mul(t),p=u.add(ie(n,e-24)).mul(t);return Zt(ge(c.add(l),43).add(ge(d,30)).add(p),c.add(ge(l.add(s),18)).add(d),t)}function Zp(n,e=n.length){const t=fn.fromNumber(81,!0);if(e<=32)return e<=16?Bx(n,e):Vx(n,e);if(e<=64)return Mx(n,e);let s=t,r=t.mul(hn).add(113),o=ea(r.mul(Ie).add(113)).mul(Ie),a=[fn.UZERO,fn.UZERO],i=[fn.UZERO,fn.UZERO];s=s.mul(Ie).add(ie(n,0));let u=0;const c=(e-1>>6)*64,l=c+(e-1&63)-63;do s=ge(s.add(r).add(a[0]).add(ie(n,u+8)),37).mul(hn),r=ge(r.add(a[1]).add(ie(n,u+48)),42).mul(hn),s=s.xor(i[1]),r=r.add(a[0]).add(ie(n,u+40)),o=ge(o.add(i[0]),33).mul(hn),a=pr(n,u,a[1].mul(hn),s.add(i[0])),i=pr(n,u+32,o.add(i[1]),r.add(ie(n,u+16))),[o,s]=[s,o],u+=64;while(u!==c);const d=hn.add(o.and(255).shl(1));return u=l,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),s=ge(s.add(r).add(a[0]).add(ie(n,u+8)),37).mul(d),r=ge(r.add(a[1]).add(ie(n,u+48)),42).mul(d),s=s.xor(i[1].mul(9)),r=r.add(a[0].mul(9).add(ie(n,u+40))),o=ge(o.add(i[0]),33).mul(d),a=pr(n,u,a[1].mul(d),s.add(i[0])),i=pr(n,u+32,o.add(i[1]),r.add(ie(n,u+16))),[o,s]=[s,o],Zt(Zt(a[0],i[0],d).add(ea(r).mul(Yp)).add(o),Zt(a[1],i[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(n,e){return e==="string"?Lt(n):Xs([n],e)}function Wx(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Xs(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Nt(n)),I().getBool("DEBUG")&&Rp(n,e),Wx(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function tt(){return I().platform.now()}function Ux(n,e){return I().platform.fetch(n,e)}function Lt(n,e="utf-8"){return e=e||"utf-8",I().platform.encode(n,e)}function Sn(n,e="utf-8"){return e=e||"utf-8",I().platform.decode(n,e)}function ye(n){return I().platform.isTypedArray!=null?I().platform.isTypedArray(n):Xp(n)}function Nt(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||en(n)||n==null||ye(n)&&t)e.push(n);else if(Array.isArray(n)||ye(n))for(let s=0;s<n.length;++s)Nt(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Nt(n[r],e,t)}return e}const zx=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:ce,arraysEqualWithNull:Ip,assert:v,assertNonNegativeIntegerDimensions:ze,assertNonNull:On,assertShapesMatch:Ce,bytesFromStringArray:Op,bytesPerElement:ks,checkConversionForErrors:Rp,clamp:Is,computeStrides:xe,convertBackendValuesAndArrayBuffer:gx,createScalarValue:Dn,createShuffledIndices:mx,decodeString:Sn,distSquared:px,encodeString:Lt,fetch:Ux,fingerPrint64:Zp,flatten:Nt,getArrayFromDType:fe,getTypedArrayFromDType:Mt,hasEncodingLoss:Ap,hexToLong:qs,indexToLoc:ro,inferDtype:rs,inferFromImplicitShape:kp,isBoolean:Dp,isFunction:Jt,isInt:vn,isNumber:Pp,isPromise:en,isScalarShape:hx,isString:Ft,isTypedArray:ye,isValidDtype:_p,locToIndex:Lr,makeOnesTypedArray:La,makeZerosNestedTypedArray:yx,makeZerosTypedArray:Wt,nearestDivisor:Fr,nearestLargerEven:so,now:tt,parseAxisParam:me,randUniform:dx,repeatedTry:Zo,rightPad:xn,shuffle:Np,shuffleCombo:lx,sizeFromShape:P,sizeToSquarishShape:Pr,squeezeShape:zt,sum:Ep,swap:Dt,tanh:fx,toNestedArray:bn,toTypedArray:Xs},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gx{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new jx)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let a;const i=tt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const c of r)c.dataSync();a=Promise.resolve({kernelMs:tt()-i})}if(I().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const l=r[c];l.data().then(d=>{Hx(d,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(c=>c.kernelMs),extraInfo:a.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:a}=e;s.forEach(i=>{Promise.all([i.data(),r,a]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],o,u[2])})})}}function Hx(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class jx{logKernelProfile(e,t,s,r,o,a){const i=typeof r=="number"?xn(`${r}ms`,9):r.error,u=xn(e,25),c=t.rank,l=t.size,d=xn(t.shape.toString(),14);let p="";for(const h in o){const f=o[h];if(f!=null){const g=f.shape||t.shape,m=g.length;p+=`${h}: ${m}D ${m>0?g:""} `}}console.log(`%c${u}	%c${i}	%c${c}D ${d}	%c${l}	%c${p}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const c=n[u],l=c.inputs;for(const d in l){const p=l[d];let h=!1;for(let f=0;f<e.length;f++)if(s[p.id]){c.outputs.forEach(g=>s[g.id]=!0),h=!0,r[c.id]=!0;break}if(h)break}}const o={};o[t.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const c=n[u],l=c.inputs;for(let d=0;d<c.outputs.length;d++)if(o[c.outputs[d].id]){for(const p in l)o[l[p].id]=!0,a[c.id]=!0;break}}const i=[];for(let u=0;u<n.length;u++){const c=n[u];if(r[c.id]&&a[c.id]){const l={};for(const p in c.inputs){const h=c.inputs[p];s[h.id]&&(l[p]=h)}const d=Object.assign({},c);d.inputs=l,d.outputs=c.outputs,i.push(d)}}return i}function qx(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],a=[];if(o.outputs.forEach(u=>{const c=n[u.id];c!=null?a.push(c):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const u in o.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const c=t(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const l=o.inputs[u];if(!ce(c.shape,l.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(n[l.id]==null)n[l.id]=c;else{const d=n[l.id];n[l.id]=s(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ud=20,xs=3,Fo=7;function Xx(n,e,t,s){const r=xe(e),o=Yx(n,e,t,r),a=e.length,i=_r(n,e,t,r,o),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function Yx(n,e,t,s){const r=P(e),o=s[s.length-1],a=new Array(o).fill(0),i=e.length,u=t==="complex64"?vs(n):n;if(i>1)for(let c=0;c<r/o;c++){const l=c*o;for(let d=0;d<o;d++)a[d]=Math.max(a[d],$s(u[l+d],0,t).length)}return a}function $s(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Fo))} + ${parseFloat(n[1].toFixed(Fo))}j`:Ft(n)?s=`'${n}'`:t==="bool"?s=Jp(n):s=parseFloat(n.toFixed(Fo)).toString(),xn(s,e)}function Jp(n){return n===0?"false":"true"}function _r(n,e,t,s,r,o=!0){const a=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){const g=vs(n);return[$s(g[0],0,t)]}return t==="bool"?[Jp(n[0])]:[n[0].toString()]}if(u===1){if(i>ud){const m=xs*a;let y=Array.from(n.slice(0,m)),b=Array.from(n.slice((i-xs)*a,i*a));return t==="complex64"&&(y=vs(y),b=vs(b)),["["+y.map(($,S)=>$s($,r[S],t)).join(", ")+", ..., "+b.map(($,S)=>$s($,r[i-xs+S],t)).join(", ")+"]"]}return["["+(t==="complex64"?vs(n):Array.from(n)).map((m,y)=>$s(m,r[y],t)).join(", ")+"]"]}const c=e.slice(1),l=s.slice(1),d=s[0]*a,p=[];if(i>ud){for(let g=0;g<xs;g++){const m=g*d,y=m+d;p.push(..._r(n.slice(m,y),c,t,l,r,!1))}p.push("...");for(let g=i-xs;g<i;g++){const m=g*d,y=m+d;p.push(..._r(n.slice(m,y),c,t,l,r,g===i-1))}}else for(let g=0;g<i;g++){const m=g*d,y=m+d;p.push(..._r(n.slice(m,y),c,t,l,r,g===i-1))}const h=u===2?",":"";p[0]="["+(i>0?p[0]+h:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+h;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":f),p}function vs(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=P(e),s!=null){const r=s.length;v(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||fe(t,this.size),this.strides=xe(e)}set(e,...t){t.length===0&&(t=[0]),v(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return mt().makeTensor(this.values,this.shape,this.dtype)}}let mt=null,zn=null;function Qx(n){mt=n}function Zx(n){zn=n}class te{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=P(e),this.strides=xe(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return zn.buffer(this.shape,this.dtype,e)}bufferSync(){return zn.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return bn(this.shape,e,this.dtype==="complex64")}arraySync(){return bn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=mt().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Sn(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),mt().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=mt().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Sn(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await mt().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(mt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return zn.print(this,e)}clone(){return this.throwIfDisposed(),zn.clone(this)}toString(e=!1){const t=this.dataSync();return Xx(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),zn.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),mt().makeVariable(this,e,t,s)}}Object.defineProperty(te,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Jx(){return Va("Tensor",()=>te)}Jx();class As extends te{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);mt().disposeTensor(this),this.dataId=e.dataId,mt().incRef(this,null)}dispose(){mt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(As,Symbol.hasInstance,{value:n=>n instanceof te&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ta;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(ta||(ta={}));var na;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(na||(na={}));var sa;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(sa||(sa={}));var ra;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(ra||(ra={}));var oa;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(oa||(oa={}));const eb={float32:ra,int32:na,bool:sa,complex64:oa};function wt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return eb[n][e]}function co(n){return wt(n,"int32")}function eh(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function th(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(n,e){if(n.dtype===e.dtype)return[n,e];const t=wt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function nh(n,e){v(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function tb(n,e){return e.some(t=>t.id===n.id)}function Ac(n){const e=[];return sh(n,e,new Set),e}function sh(n,e,t){if(n==null)return;if(n instanceof te){e.push(n);return}if(!nb(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),sh(o,e,t))}}function nb(n){return Array.isArray(n)||typeof n=="object"}const sb=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:nh,getTensorsInContainer:Ac,isTensorInList:tb,makeTypesMatch:pe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(n){return n.kernelName!=null}class cd{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Yn{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new cd}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(nt(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Gx(this.backendInstance),!0}setupRegisteredKernels(){Ur(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ur(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Fa)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,nt(`Initialization of backend ${e} failed`),nt(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return nt(`Initialization of backend ${e} failed`),nt(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Yn.nextTensorId++}nextVariableId(){return Yn.nextVariableId++}clone(e){const t=T.runKernel(io,{x:e}),s={x:e},r=a=>({x:()=>{const i="float32",u={x:a},c={dtype:i};return T.runKernel(ao,u,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(_s(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(u=>{o+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const c=Lo(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Lo(e)){const{kernelName:f,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const y=_s(f,this.backendName);v(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const b=this.backend.numDataIds();u=y.kernelFunc({inputs:g,attrs:m,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,$);const S=$.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(r){const N=this.getTensorsForGradient(f,g,S);s=this.saveTensorsForBackwardMode(N)}return S}}else{const{forwardFunc:f}=e,g=m=>{r&&(s=m.map(y=>this.keep(this.clone(y))))};i=()=>{const m=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,g));const y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,y),y}}const{inputs:l,attrs:d}=e,p=Lo(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(h=this.profiler.profileKernel(c,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs)}),r&&this.addTapeNode(c,l,t,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(f=>l[f]!=null?l[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Jo(e);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let i;r.saveAllInputs?(v(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(c=>t[c])):i=o.map(c=>t[c]);const u=s.filter((c,l)=>a[l]);return i.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&Ft(e[0])&&(o=e.map(u=>Lt(u)));const a=r.write(o,t,s),i=new te(t,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const u=this.state.tensorInfo.get(a),c=Op(o);this.state.numBytes+=c-u.bytes,u.bytes=c}return i}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,a=new te(r,o,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new As(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*ks(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof As||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*ks(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},u=Jo(e);u!=null&&(r=u.gradFunc),r!=null&&(i.gradient=c=>(c=c.map((l,d)=>{if(l==null){const p=s[d],h=Wt(p.size,p.dtype);return this.makeTensor(h,p.shape,p.dtype)}return l}),r(c.length>1?c:c[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ac(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(v(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));v(o instanceof te,()=>"The result y returned by f() must be a tensor.");const a=Kx(this.state.activeTape,t,o);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=s??rb(o.shape),qx(i,a,c=>this.tidy(c),ob);const u=t.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const l of c.saved)l.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return v(Jt(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{v(t.every(i=>i instanceof te),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((i,u)=>{r[u]=i});const o=(i,u)=>(s=e(...t,u),v(s.value instanceof te,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),v(Jt(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,u)=>{const c=s.gradFunc(i,u),l=Array.isArray(c)?c:[c];v(l.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),v(l.every(p=>p instanceof te),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return l.forEach((p,h)=>{d[h]=()=>p}),d};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=tt(),s=await this.backend.time(e);return s.wallMs=tt()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new cd;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Yn.nextTensorId=0;Yn.nextVariableId=0;function rb(n){const e=La(P(n),"float32");return T.makeTensor(e,n,"float32")}function rh(){const n=Bp();if(n._tfengine==null){const e=new Lp(n);n._tfengine=new Yn(e)}return $x(n._tfengine.ENV),Qx(()=>n._tfengine),n._tfengine}const T=rh();function ob(n,e){const t={a:n,b:e};return T.runKernel(oo,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(){return typeof navigator<"u"&&navigator!=null}let aa;function ib(n){aa=n}function Oc(n){if(aa!==void 0)return aa;if(n||ab()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Dc(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ub=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:Dc,isMobile:Oc,mockIsMobile:ib},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const De=I();De.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});De.registerFlag("IS_BROWSER",()=>Dc());De.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");De.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));De.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));De.registerFlag("PROD",()=>!1);De.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>De.getBool("DEBUG"));De.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);De.registerFlag("IS_TEST",()=>!1);De.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>De.getBool("DEBUG"));De.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);De.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);De.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(n,e){let t=n;if(ye(n))return e==="string"?[]:[n.length];if(eh(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(th(n))return[n.buffer.size/(e==null?4:ks(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||ye(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&I().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&oh(n,s,[]),s}function oh(n,e,t){if(t=t||[],!Array.isArray(n)&&!ye(n)){v(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}v(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),v(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)oh(n[r],s,t.concat(r))}function ld(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function w(n,e,t,s="numeric"){if(n instanceof te)return ld(s,n.dtype,e,t),n;let r=rs(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),ld(s,r,e,t),n==null||!ye(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=Et(n,r);!ye(n)&&!Array.isArray(n)&&(n=[n]);const i=r!=="string"?Xs(n,r):Nt(n,[],!0);return T.makeTensor(i,o,r)}function Os(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,a)=>w(o,`${e}[${a}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pc="__op";function C(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Pc;const r=(...o)=>{T.startScope(t);try{const a=s(...o);return en(a)&&console.error("Cannot return a Promise inside of tidy."),T.endScope(a),a}catch(a){throw T.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n,e){const t=w(n,"real","complex"),s=w(e,"imag","complex");Ce(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return T.runKernel(ui,r)}const Ut=C({complex_:cb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function on(n,e,t,s){if(s==null)s=rs(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(th(n)||eh(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return T.backend.createTensorFromGPUData(n,e||t,s)}if(!ye(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ze(e);const r=P(e),o=P(t);v(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<t.length;++a){const i=t[a],u=a===t.length-1?i!==P(e.slice(a)):!0;v(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!ye(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Xs(n,s):Nt(n,[],!0),T.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(n,e,t){const s=Et(n,t);return on(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ia={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class vt{static join(e){return new vt(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>ye(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),a=new Uint8Array(o);let i=0;for(let u=s;u<this.shards.length;u++){const c=this.shards[u],d=e+i-c.start,p=i,f=Math.min(t,c.end)-c.start,g=new Uint8Array(c.buffer,d,f-d);if(a.set(g,p),i+=g.length,t<c.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=lb(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function lb(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr=4;async function db(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const i=r[a],u=Array.isArray(n)?n[a].tensor:n[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const c={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async d=>{const p=await u.bytes(),h=p.reduce((m,y)=>m+y.length,0)+zr*p.length,f=new Uint8Array(h);let g=0;for(let m=0;m<p.length;m++){const y=p[m],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,g),g+=zr,f.set(y,g),g+=y.length}d(f)});s.push(l)}else s.push(u.data());e!=null&&(c.group=e),t.push(c)}const o=await Promise.all(s);return{data:pb(o),specs:t}}function ah(n,e){const t=new vt(n),s={};let r,o=0;for(const a of e){const i=a.name,u=a.dtype,c=a.shape,l=P(c);let d;if("quantization"in a){const p=a.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${a.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(u!=="float32")throw new Error(`Weight ${a.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${u}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=ia[p.dtype],f=t.slice(o,o+l*h),g=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(u==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){d=new Float32Array(g.length);for(let m=0;m<g.length;m++){const y=g[m];d[m]=y*p.scale+p.min}}else if(p.dtype==="float16")r===void 0&&(r=bb()),d=r(g);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(u==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);d=new Int32Array(g.length);for(let m=0;m<g.length;m++){const y=g[m];d[m]=Math.round(y*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${u}`);o+=l*h}else if(u==="string"){const p=P(a.shape);d=[];for(let h=0;h<p;h++){const f=new Uint32Array(t.slice(o,o+zr))[0];o+=zr;const g=new Uint8Array(t.slice(o,o+f));d.push(g),o+=f}}else{const p=ia[u],h=t.slice(o,o+l*p);if(u==="float32")d=new Float32Array(h);else if(u==="int32")d=new Int32Array(h);else if(u==="bool")d=new Uint8Array(h);else if(u==="complex64"){d=new Float32Array(h);const f=new Float32Array(d.length/2),g=new Float32Array(d.length/2);for(let b=0;b<f.length;b++)f[b]=d[b*2],g[b]=d[b*2+1];const m=at(f,c,"float32"),y=at(g,c,"float32");s[i]=Ut(m,y),m.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${u}`);o+=l*p}u!=="complex64"&&(s[i]=at(d,c,u))}return s}function pb(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Fc=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function dd(n){return Fc?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function hb(n){if(Fc)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function fb(n){if(Fc){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function mb(n){return vt.join(n)}function pd(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function ih(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function uh(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function Lc(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),uh(n,t,s)}function Ys(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:dd(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:dd(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new vt(n.weightData).byteLength}}function ch(n){const e=[];for(const t of n)e.push(...t.weights);return e}function gb(){const n=t=>{let s=t<<13,r=0;for(;!(s&8388608);)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function yb(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function xb(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function bb(){const n=gb(),e=yb(),t=xb();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const i=s[a],u=n[t[i>>10]+(i&1023)]+e[i>>10];o[a]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class de{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return de.instance==null&&(de.instance=new de),de.instance}static registerSaveRouter(e){de.getInstance().saveRouters.push(e)}static registerLoadRouter(e){de.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return de.getHandlers(e,"save")}static getLoadHandlers(e,t){return de.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?de.getInstance().loadRouters:de.getInstance().saveRouters).forEach(a=>{const i=a(e,s);i!==null&&r.push(i)}),r}}const wb=n=>de.registerSaveRouter(n),$b=n=>de.registerLoadRouter(n),vb=n=>de.getSaveHandlers(n),Sb=(n,e)=>de.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua="tensorflowjs",ca=1,yn="models_store",Xt="model_info_store";function lh(){if(!I().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function la(n){const e=n.result;e.createObjectStore(yn,{keyPath:"modelPath"}),e.createObjectStore(Xt,{keyPath:"modelPath"})}class Tn{constructor(e){if(this.indexedDB=lh(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(ua,ca);o.onupgradeneeded=()=>la(o),o.onsuccess=()=>{const a=o.result;if(t==null){const i=a.transaction(yn,"readonly"),c=i.objectStore(yn).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=l=>(a.close(),r(c.error)),i.oncomplete=()=>a.close()}else{t.weightData=vt.join(t.weightData);const i=Ys(t),u=a.transaction(Xt,"readwrite");let c=u.objectStore(Xt),l;try{l=c.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(p){return r(p)}let d;l.onsuccess=()=>{d=a.transaction(yn,"readwrite");const p=d.objectStore(yn);let h;try{h=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(f){return r(f)}h.onsuccess=()=>s({modelArtifactsInfo:i}),h.onerror=f=>{c=u.objectStore(Xt);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),r(h.error)),g.onerror=m=>(a.close(),r(h.error))}},l.onerror=p=>(a.close(),r(l.error)),u.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}Tn.URL_SCHEME="indexeddb://";const dh=n=>I().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Tn.URL_SCHEME)?Cb(n.slice(Tn.URL_SCHEME.length)):null;de.registerSaveRouter(dh);de.registerLoadRouter(dh);function Cb(n){return new Tn(n)}function Tb(n){return n.startsWith(Tn.URL_SCHEME)?n.slice(Tn.URL_SCHEME.length):n}class Nb{constructor(){this.indexedDB=lh()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(ua,ca);s.onupgradeneeded=()=>la(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Xt,"readonly"),i=o.objectStore(Xt).getAll();i.onsuccess=()=>{const u={};for(const c of i.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},i.onerror=u=>(r.close(),t(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=Tb(e),new Promise((t,s)=>{const r=this.indexedDB.open(ua,ca);r.onupgradeneeded=()=>la(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Xt,"readwrite"),i=a.objectStore(Xt),u=i.get(e);let c;u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const l=i.delete(e),d=()=>{c=o.transaction(yn,"readwrite");const h=c.objectStore(yn).delete(e);h.onsuccess=()=>t(u.result.modelArtifactsInfo),h.onerror=f=>s(u.error)};l.onsuccess=d,l.onerror=p=>(d(),o.close(),s(u.error))}},u.onerror=l=>(o.close(),s(u.error)),a.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pt="/",Gn="tensorflowjs_models",ph="info",Eb="model_topology",Ib="weight_specs",kb="weight_data",Rb="model_metadata";function hh(n){return{info:[Gn,n,ph].join(Pt),topology:[Gn,n,Eb].join(Pt),weightSpecs:[Gn,n,Ib].join(Pt),weightData:[Gn,n,kb].join(Pt),modelMetadata:[Gn,n,Rb].join(Pt)}}function fh(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function _b(n){const e=n.split(Pt);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Pt)}function Ab(n){return n.startsWith(Nn.URL_SCHEME)?n.slice(Nn.URL_SCHEME.length):n}class Nn{constructor(e){if(!I().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=hh(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Ys(e),o=vt.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,hb(o));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw fh(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=fb(a),t}}Nn.URL_SCHEME="localstorage://";const mh=n=>I().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Nn.URL_SCHEME)?Ob(n.slice(Nn.URL_SCHEME.length)):null;de.registerSaveRouter(mh);de.registerLoadRouter(mh);function Ob(n){return new Nn(n)}class Db{constructor(){v(I().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),v(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Gn+Pt,s=Pt+ph;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const a=_b(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=Ab(e);const t=hh(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return fh(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn="://";class Ee{constructor(){this.managers={}}static getInstance(){return Ee.instance==null&&(Ee.instance=new Ee),Ee.instance}static registerManager(e,t){v(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Hn)&&(e=e.slice(0,e.indexOf(Hn))),v(e.length>0,()=>"scheme must not be an empty string.");const s=Ee.getInstance();v(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Ee.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ee.getInstance().managers)}}function Ar(n){if(n.indexOf(Hn)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ee.getSchemes().join(",")}`);return{scheme:n.split(Hn)[0],path:n.split(Hn)[1]}}async function gh(n,e,t=!1){v(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=de.getLoadHandlers(n);v(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),v(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=de.getSaveHandlers(e);v(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),v(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=o[0],i=Ar(n).scheme,u=Ar(n).path,c=i===Ar(n).scheme,l=await r.load();t&&c&&await Ee.getManager(i).removeModel(u);const d=await a.save(l);return t&&!c&&await Ee.getManager(i).removeModel(u),d.modelArtifactsInfo}async function Pb(){const n=Ee.getSchemes(),e={};for(const t of n){const s=await Ee.getManager(t).listModels();for(const r in s){const o=t+Hn+r;e[o]=s[r]}}return e}async function Fb(n){const e=Ar(n);return Ee.getManager(e.scheme).removeModel(e.path)}async function Lb(n,e){return gh(n,e,!1)}async function Bb(n,e){return gh(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vb{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!I().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Xp(e)}}if(I().get("IS_BROWSER")){I().setPlatform("browser",new Vb);try{Ee.registerManager(Nn.URL_SCHEME,new Db)}catch{}try{Ee.registerManager(Tn.URL_SCHEME,new Nb)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mb={importFetch:()=>require("node-fetch")};let Bo;class Wb{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return I().global.fetch!=null?I().global.fetch(e,t):(Bo==null&&(Bo=Mb.importFetch()),Bo(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}I().get("IS_NODE")&&!I().get("IS_BROWSER")&&I().setPlatform("node",new Wb);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function le(n,e="float32",t){return e=e||"float32",ze(n),new Cn(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ub(n,e){const t=w(n,"x","cast");if(!_p(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return T.runKernel(ao,s,r)}const ee=C({cast_:Ub});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zb(n){const t={x:w(n,"x","clone","string_or_numeric")};return T.runKernel(io,t)}const Bt=C({clone_:zb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bc(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */rh();const Gb={buffer:le,cast:ee,clone:Bt,print:Bc};Zx(Gb);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hb(){I().set("PROD",!0)}function jb(){I().set("DEBUG",!0)}function Kb(){I().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function qb(n){I().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Xb(){T.disposeVariables()}function ft(){return T}function Yb(){return T.memory()}function Qb(n){return T.profile(n)}function U(n,e){return T.tidy(n,e)}function _e(n){Ac(n).forEach(t=>t.dispose())}function xt(n){return T.keep(n)}function Zb(n){return T.time(n)}function Jb(n){return T.setBackend(n)}function e0(){return T.ready()}function yh(){return T.backendName}function t0(n){T.removeBackend(n)}function n0(n){return T.findBackend(n)}function s0(n){return T.findBackendFactory(n)}function xh(n,e,t=1){return T.registerBackend(n,e,t)}function bh(){return T.backend}function r0(n,e){I().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0(n,e){let t=w(n,"a","add"),s=w(e,"b","add");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(oo,r)}const W=C({add_:o0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(n,e){let t=w(n,"a","floorDiv"),s=w(e,"b","floorDiv");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(Wi,r)}const Vc=C({floorDiv_:a0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0(n,e){let t=w(n,"a","div"),s=w(e,"b","div");if([t,s]=pe(t,s),t.dtype==="int32"&&s.dtype==="int32")return Vc(t,s);const r={a:t,b:s},o={};return T.runKernel(ki,r,o)}const ae=C({div_:i0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0(n,e){let t=w(n,"a","mul"),s=w(e,"b","mul");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(bu,r)}const L=C({mul_:u0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0(n){const e=w(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return T.runKernel(ci,t)}else{const t={x:e};return T.runKernel(Ma,t)}}const Ve=C({abs_:c0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0(n){const t={x:w(n,"x","acos")};return T.runKernel(Wa,t)}const wh=C({acos_:l0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0(n){const t={x:w(n,"x","acosh")};return T.runKernel(Ua,t)}const $h=C({acosh_:d0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0(n){v(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),v(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>w(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!ce(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return T.runKernel(za,s)}const vh=C({addN_:p0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0(n,e=null,t=!1){const r={x:w(n,"x","all","bool")},o={axis:e,keepDims:t};return T.runKernel(Ga,r,o)}const Sh=C({all_:h0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f0(n,e=null,t=!1){const r={x:w(n,"x","any","bool")},o={axis:e,keepDims:t};return T.runKernel(Ha,r,o)}const Ch=C({any_:f0});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0(n,e=0){const s={x:w(n,"x","argMax")},r={axis:e};return T.runKernel(ja,s,r)}const Mc=C({argMax_:m0});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0(n,e=0){const s={x:w(n,"x","argMin")},r={axis:e};return T.runKernel(Ka,s,r)}const Th=C({argMin_:g0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0(n){const t={x:w(n,"x","asin")};return T.runKernel(qa,t)}const Nh=C({asin_:y0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n){const t={x:w(n,"x","asinh")};return T.runKernel(Xa,t)}const Eh=C({asinh_:x0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0(n){const t={x:w(n,"x","atan")};return T.runKernel(Ya,t)}const Ih=C({atan_:b0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n,e){let t=w(n,"a","atan2"),s=w(e,"b","atan2");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(Za,r)}const kh=C({atan2_:w0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0(n){const t={x:w(n,"x","atanh")};return T.runKernel(Qa,t)}const Rh=C({atanh_:$0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(n,e,t,s,r="NHWC",o){const a=n[3],i=[...e,a],u=os(r);return je(n,i,t,o,s,null,null,u)}function Pn(n,e,t,s,r,o,a="channelsLast"){const[i,u]=Ds(e);let c;if(a==="channelsLast")c=[i,u,n[3],n[3]];else if(a==="channelsFirst")c=[i,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return je(n,c,t,s,r,o,!1,a)}function Qs(n,e,t,s,r,o,a="NDHWC"){const[i,u,c]=da(e);let l,d;if(a==="NDHWC")d="channelsLast",l=[i,u,c,n[4],n[4]];else if(a==="NCDHW")d="channelsFirst",l=[i,u,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Zs(n,l,t,s,r,!1,d,o)}function je(n,e,t,s,r,o,a=!1,i="channelsLast"){let[u,c,l,d]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,d]=n;else if(i==="channelsFirst")[u,d,c,l]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,h,,f]=e,[g,m]=Ds(t),[y,b]=Ds(s),$=jn(p,y),S=jn(h,b),{padInfo:N,outHeight:E,outWidth:k}=C0(r,c,l,g,m,$,S,o,i),R=a?f*d:f;let A;return i==="channelsFirst"?A=[u,R,E,k]:i==="channelsLast"&&(A=[u,E,k,R]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:l,inChannels:d,outHeight:E,outWidth:k,outChannels:R,padInfo:N,strideHeight:g,strideWidth:m,filterHeight:p,filterWidth:h,effectiveFilterHeight:$,effectiveFilterWidth:S,dilationHeight:y,dilationWidth:b,inShape:n,outShape:A,filterShape:e}}function Zs(n,e,t,s,r,o=!1,a="channelsLast",i){let[u,c,l,d,p]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,c,l,d,p]=n;else if(a==="channelsFirst")[u,p,c,l,d]=n;else throw new Error(`Unknown dataFormat ${a}`);const[h,f,g,,m]=e,[y,b,$]=da(t),[S,N,E]=da(s),k=jn(h,S),R=jn(f,N),A=jn(g,E),{padInfo:O,outDepth:D,outHeight:V,outWidth:z}=T0(r,c,l,d,y,b,$,k,R,A,i),G=o?m*p:m;let j;return a==="channelsFirst"?j=[u,G,D,V,z]:a==="channelsLast"&&(j=[u,D,V,z,G]),{batchSize:u,dataFormat:a,inDepth:c,inHeight:l,inWidth:d,inChannels:p,outDepth:D,outHeight:V,outWidth:z,outChannels:G,padInfo:O,strideDepth:y,strideHeight:b,strideWidth:$,filterDepth:h,filterHeight:f,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:R,effectiveFilterWidth:A,dilationDepth:S,dilationHeight:N,dilationWidth:E,inShape:n,outShape:j,filterShape:e}}function v0(n,e,t,s,r){s==null&&(s=Wc(n,e,t));const o=n[0],a=n[1],i=Ps((o-e+2*s)/t+1,r),u=Ps((a-e+2*s)/t+1,r);return[i,u]}function S0(n,e,t,s,r,o){r==null&&(r=Wc(n,e[0],s[0]));const a=[0,0,0,t];for(let i=0;i<3;i++)n[i]+2*r>=e[i]&&(a[i]=Ps((n[i]-e[i]+2*r)/s[i]+1,o));return a}function Wc(n,e,t,s=1){const r=jn(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Ds(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function da(n){return typeof n=="number"?[n,n,n]:n}function jn(n,e){return e<=1?n:n+(n-1)*(e-1)}function C0(n,e,t,s,r,o,a,i,u){let c,l,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const h=v0([e,t],o,s,n,i);l=h[0],d=h[1]}else if(n==="same"){l=Math.ceil(e/s),d=Math.ceil(t/r);const p=Math.max(0,(l-1)*s+o-e),h=Math.max(0,(d-1)*r+a-t),f=Math.floor(p/2),g=p-f,m=Math.floor(h/2),y=h-m;c={top:f,bottom:g,left:m,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-o+1)/s),d=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const p=u==="channelsLast"?n[1][0]:n[2][0],h=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],g=u==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:h,left:f,right:g,type:p===0&&h===0&&f===0&&g===0?"VALID":"EXPLICIT"},l=Ps((e-o+p+h)/s+1,i),d=Ps((t-a+f+g)/r+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:l,outWidth:d}}function T0(n,e,t,s,r,o,a,i,u,c,l){let d,p,h,f;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const m=S0([e,t,s,1],[i,u,c],1,[r,o,a],n,l);p=m[0],h=m[1],f=m[2]}else if(n==="same"){p=Math.ceil(e/r),h=Math.ceil(t/o),f=Math.ceil(s/a);const g=(p-1)*r+i-e,m=(h-1)*o+u-t,y=(f-1)*a+c-s,b=Math.floor(g/2),$=g-b,S=Math.floor(m/2),N=m-S,E=Math.floor(y/2),k=y-E;d={top:S,bottom:N,left:E,right:k,front:b,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}function Ps(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Fs(n){const[e,t,s]=Ds(n);return e===1&&t===1&&s===1}function Ge(n,e){return Fs(n)||Fs(e)}function En(n){return Ds(n).every(e=>e>0)}function os(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ut(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")v(vn(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{v(vn(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0(n,e){const s={x:w(n,"x","reshape","string_or_numeric")},r={shape:e};return T.runKernel(Vu,s,r)}const _=C({reshape_:N0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0(n,e,t,s,r){const o=w(n,"x","avgPool","float32"),a=1;v(Ge(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=o,u=!1;o.rank===3&&(u=!0,i=_(o,[1,o.shape[0],o.shape[1],o.shape[2]])),v(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ut("avgPool",s,r);const c={x:i},l={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let d=T.runKernel(Ja,c,l);return d=ee(d,o.dtype),u?_(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Uc=C({avgPool_:E0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0(n,e,t,s,r,o="NDHWC"){const a=w(n,"x","avgPool3d","float32");let i=a,u=!1;a.rank===4&&(u=!0,i=_(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),v(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),v(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),v(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ut("avgPool3d",s,r);const c={x:i},l={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let d=T.runKernel(ei,c,l);return d=ee(d,i.dtype),u?_(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Ah=C({avgPool3d_:I0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0(n,e=0){v(n.length>=1,()=>"Pass at least one tensor to concat");const t=Os(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Bt(t[0]);const s=t,r={axis:e};return T.runKernel(li,s,r)}const Se=C({concat_:k0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0(n,e,t=!1,s=!1){let r=w(n,"a","matMul"),o=w(e,"b","matMul");[r,o]=pe(r,o);const a={a:r,b:o},i={transposeA:t,transposeB:s};return T.runKernel(ti,a,i)}const Z=C({matMul_:R0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0(n){const t={x:w(n,"x","sigmoid","float32")};return T.runKernel(tc,t)}const Tt=C({sigmoid_:_0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(n,e,t){const s=w(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return T.runKernel(Qu,r,o)}const re=C({slice_:A0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0(n){const t={x:w(n,"x","tanh","float32")};return T.runKernel($c,t)}const Gr=C({tanh_:O0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0(n,e,t,s,r,o){const a=w(n,"forgetBias","basicLSTMCell"),i=w(e,"lstmKernel","basicLSTMCell"),u=w(t,"lstmBias","basicLSTMCell"),c=w(s,"data","basicLSTMCell"),l=w(r,"c","basicLSTMCell"),d=w(o,"h","basicLSTMCell"),p=Se([c,d],1),h=Z(p,i),f=W(h,u),g=f.shape[0],m=f.shape[1]/4,y=[g,m],b=re(f,[0,0],y),$=re(f,[0,m],y),S=re(f,[0,m*2],y),N=re(f,[0,m*3],y),E=W(L(Tt(b),Gr($)),L(l,Tt(W(a,S)))),k=L(Gr(E),Tt(N));return[E,k]}const Oh=C({basicLSTMCell_:D0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0(n,e,t){const s=w(n,"x","batchToSpaceND"),r=e.reduce((i,u)=>i*u);v(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),v(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),v(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},a={blockShape:e,crops:t};return T.runKernel(ni,o,a)}const zc=C({batchToSpaceND_:P0});function F0(n){let e;return n.rank===0||n.rank===1?e=_(n,[1,1,1,n.size]):n.rank===2?e=_(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0(n,e,t,s,r,o){o==null&&(o=.001);const a=w(n,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(t,"variance","batchNorm");let c;r!=null&&(c=w(r,"scale","batchNorm"));let l;s!=null&&(l=w(s,"offset","batchNorm")),v(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),v(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),v(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:F0(a),scale:c,offset:l,mean:i,variance:u},h={varianceEpsilon:o},f=T.runKernel(Ui,p,h);return _(f,a.shape)}const Js=C({batchNorm_:L0});function B0(n,e,t,s,r,o){const a=w(n,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(t,"variance","batchNorm");let c;r!=null&&(c=w(r,"scale","batchNorm"));let l;return s!=null&&(l=w(s,"offset","batchNorm")),v(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),v(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),v(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&v(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&v(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Js(a,i,u,l,c,o)}const Dh=C({batchNorm2d_:B0});function V0(n,e,t,s,r,o){const a=w(n,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(t,"variance","batchNorm");let c;r!=null&&(c=w(r,"scale","batchNorm"));let l;return s!=null&&(l=w(s,"offset","batchNorm")),v(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),v(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),v(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&v(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&v(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Js(a,i,u,l,c,o)}const Ph=C({batchNorm3d_:V0});function M0(n,e,t,s,r,o){const a=w(n,"x","batchNorm"),i=w(e,"mean","batchNorm"),u=w(t,"variance","batchNorm");let c;r!=null&&(c=w(r,"scale","batchNorm"));let l;return s!=null&&(l=w(s,"offset","batchNorm")),v(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),v(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),v(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&v(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&v(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Js(a,i,u,l,c,o)}const Fh=C({batchNorm4d_:M0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0(n,e,t){const s=w(n,"x","bincount"),r=w(e,"weights","bincount");v(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),v(t>=0,()=>`size must be non-negative, but got ${t}.`),v(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},a={size:t};return T.runKernel(si,o,a)}const Gc=C({bincount_:W0});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0(n,e){const t=w(n,"x","bitwiseAnd"),s=w(e,"y","bitwiseAnd");if(!ce(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return T.runKernel(ri,r)}const Lh=C({bitwiseAnd_:U0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0(n,e){const t=w(n,"s0","broadcastArgs","int32"),s=w(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return T.runKernel(oi,r)}const Bh=C({broadcastArgs_:z0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0(n,e){let t=w(n,"broadcastTo","x");const s=t.shape;if(ze(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=_(t,c)}const r=t.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])o[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return Bt(t);const i={x:t},u={reps:o};return T.runKernel(uo,i,u)}const Kn=C({broadcastTo_:G0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0(n){const t={x:w(n,"x","ceil","float32")};return T.runKernel(ai,t)}const Vh=C({ceil_:H0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function as(n,e,t){ze(n),t=t||rs(e);const s={shape:n,value:e,dtype:t};return T.runKernel(Bi,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0(n,e,t){const s=w(n,"x","clipByValue");if(v(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return as(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return T.runKernel(ii,r,o)}const Mh=C({clipByValue_:j0});function K0(n){return Se(n,0)}const Wh=C({concat1d_:K0});function q0(n,e){return Se(n,e)}const Uh=C({concat2d_:q0});function X0(n,e){return Se(n,e)}const zh=C({concat3d_:X0});function Y0(n,e){return Se(n,e)}const Gh=C({concat4d_:Y0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0(n,e,t,s,r="NHWC",o=[1,1],a){const i=w(n,"x","conv2d","float32"),u=w(e,"filter","conv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),v(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),v(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ut("conv2d",s,a);const d=r==="NHWC"?c.shape[3]:c.shape[1];v(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),v(Ge(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),v(En(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),v(En(t),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:u},h={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},f=T.runKernel(di,p,h);return l?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const er=C({conv2d_:Q0});function Z0(n,e,t,s,r="NWC",o=1,a){const i=w(n,"x","conv1d"),u=w(e,"filter","conv1d");let c=i,l=!1;i.rank===2&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1]])),v(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),v(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ut("conv1d",s,a),v(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),v(Ge(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),v(En(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),v(En(t),()=>"Error in conv1D: Stride should be larger than 0."),v(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=_(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=_(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=er(p,d,[1,t],s,"NHWC",[1,o],a);return l?_(m,[m.shape[2],m.shape[3]]):_(m,[m.shape[0],m.shape[2],m.shape[3]])}const Hh=C({conv1d_:Z0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0(n,e,t,s,r,o="NHWC",a){v(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,u=e,c=!1;e.rank===3&&(c=!0,u=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),v(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),v(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),v(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const l=o==="NHWC"?i[3]:i[1],d=o==="NHWC"?u.shape[3]:u.shape[1];v(l===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[2]}.`),v(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),ut("conv2dDerInput",r,a);const p={dy:u,filter:t},h={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:i},f=T.runKernel(hi,p,h);return c?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const jh=C({conv2DBackpropInput_:J0});function ew(n,e,t,s,r,o){const a=w(n,"x","conv2dTranspose"),i=w(e,"filter","conv2dTranspose");return jh(t,a,i,s,r,"NHWC",o)}const Kh=C({conv2dTranspose_:ew});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(n,e,t,s,r="NDHWC",o=[1,1,1]){const a=w(n,"x","conv3d"),i=w(e,"filter","conv3d");let u=a,c=!1;a.rank===4&&(c=!0,u=_(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),v(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),v(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),v(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),v(Ge(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),v(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),v(En(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),v(En(t),()=>"Error in conv3D: Strides should be larger than 0.");const l={x:u,filter:i},d={strides:t,pad:s,dataFormat:r,dilations:o},p=T.runKernel(fi,l,d);return c?_(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const qh=C({conv3d_:tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n,e,t,s,r){v(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,a=e,i=!1;e.rank===4&&(i=!0,a=_(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const u=o[4],c=a.shape[4];v(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),v(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),v(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),v(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),v(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const l={dy:a,filter:t},d={pad:r,strides:s,inputShape:o},p=T.runKernel(mi,l,d);return i?_(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const sw=C({conv3DBackpropInput_:nw});function rw(n,e,t,s,r){const o=w(n,"x","conv3dTranspose"),a=w(e,"filter","conv3dTranspose");return sw(t,o,a,s,r)}const Xh=C({conv3dTranspose_:rw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ow(n){const t={x:w(n,"x","cos","float32")};return T.runKernel(gi,t)}const Yh=C({cos_:ow});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n){const t={x:w(n,"x","cosh","float32")};return T.runKernel(yi,t)}const Qh=C({cosh_:aw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(n,e=0,t=!1,s=!1){const o={x:w(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return T.runKernel(xi,o,a)}const Zh=C({cumprod_:iw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n,e=0,t=!1,s=!1){const o={x:w(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return T.runKernel(bi,o,a)}const Jh=C({cumsum_:uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n,e,t,s=!1){const r=w(n,"x","denseBincount"),o=w(e,"weights","denseBincount");v(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),v(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),v(t>=0,()=>`size must be non-negative, but got ${t}.`),v(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},i={size:t,binaryOutput:s};return T.runKernel($i,a,i)}const ef=C({denseBincount_:cw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lw(n,e,t="NHWC"){const s=w(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];v(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),v(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),v(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),v(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const i={x:s},u={blockSize:e,dataFormat:t};return T.runKernel(vi,i,u)}const tf=C({depthToSpace_:lw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(n,e,t,s,r="NHWC",o=[1,1],a){const i=w(n,"x","depthwiseConv2d","float32"),u=w(e,"filter","depthwiseConv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),v(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),v(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const d=r==="NHWC"?c.shape[3]:c.shape[1];v(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),ut("depthwiseConv2d",s,a);const p={x:c,filter:u},h={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},f=T.runKernel(Si,p,h);return l?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const lo=C({depthwiseConv2d_:dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pw(n){const t={x:w(n,"x","diag")};return T.runKernel(Ni,t)}const nf=C({diag_:pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hw(n,e,t,s,r=[1,1],o="NHWC"){const a=w(n,"x","dilation2d"),i=w(e,"filter","dilation2d");v(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),v(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),v(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=a,c=!1;a.rank===3&&(u=_(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),v(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const l={x:u,filter:i},d={strides:t,pad:s,dilations:r},p=T.runKernel(Ei,l,d);return c?_(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const sf=C({dilation2d_:hw});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ls(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,a=n[o]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function Hc(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,a=e[o];(r==null||r===1&&a>1)&&t.unshift(o)}return t}function X(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let a=e[e.length-r-1];if(a==null&&(a=1),o===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=o;else if(o!==a){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else s[t-r-1]=o}return s}const fw=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:X,getBroadcastDims:Ls,getReductionAxes:Hc},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e){let t=w(n,"a","equal","string_or_numeric"),s=w(e,"b","equal","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(Oi,r)}const tr=C({equal_:mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n,e,t){const s=w(e,"a","where"),r=w(t,"b","where"),o=w(n,"condition","where","bool"),a=X(X(o.shape,s.shape),r.shape),i=Kn(o,a),u=Kn(s,a),c=Kn(r,a),l={condition:i,t:u,e:c};return T.runKernel(Xu,l)}const Vt=C({where_:gw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n){const t={x:w(n,"x","zerosLike")};return T.runKernel(Ec,t)}const We=C({zerosLike_:yw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n,e){let t=w(n,"a","div"),s=w(e,"b","div");[t,s]=pe(t,s);const r=ae(t,s),o=We(r),a=tr(s,o);return Vt(a,o,r)}const rf=C({divNoNan_:xw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw(n,e){const t=w(n,"t1","dot"),s=w(e,"t2","dot");v((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(v(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const a=_(t,[1,-1]),i=_(s,[-1,1]),u=Z(a,i);return _(u,[])}else if(t.rank===1&&s.rank===2){const a=_(t,[1,-1]),i=_(s,[s.shape[0],s.shape[1]]),u=Z(a,i);return _(u,[u.size])}else if(t.rank===2&&s.rank===1){const a=_(s,[-1,1]),i=Z(t,a);return _(i,[i.size])}else{const a=_(s,[s.shape[0],s.shape[1]]);return Z(t,a)}}const of=C({dot_:bw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ww(n,...e){const t=e.map((r,o)=>w(r,`tensors${o}`,"einsum")),s={equation:n};return T.runKernel(Ri,t,s)}const af=C({einsum_:ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n){const t={x:w(n,"x","elu","float32")};return T.runKernel(_i,t)}const jc=C({elu_:$w});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vw(n,e){const t=w(n,"x","ensureShape","string_or_numeric");if(!Ip(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const uf=C({ensureShape_:vw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(n){let e=w(n,"x","erf");v(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ee(e,"float32"));const t={x:e};return T.runKernel(Ai,t)}const cf=C({erf_:Sw});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kc(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function lf(n,e,t){const s=n.length+e.length,r=[];let o=0,a=0;for(let i=0;i<s;i++)t.indexOf(i)===-1?r.push(n[o++]):r.push(e[a++]);return r}function _t(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function Ke(n,e){const t=e.map(s=>1);return lf(n,t,e)}function St(n,e,t){v(Kc(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ct(n,e){if(Kc(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function qc(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function lt(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(n,e=null,t=!1){const r={x:w(n,"x","max")},o={reductionIndices:e,keepDims:t};return T.runKernel(uu,r,o)}const wn=C({max_:Cw});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tw(n,e=null,t=!1){const r={x:w(n,"x","min")},o={axis:e,keepDims:t};return T.runKernel(fu,r,o)}const Hr=C({min_:Tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e){let t=w(n,"base","pow"),s=w(e,"exp","pow");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(ku,r)}const Qn=C({pow_:Nw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K(n,e){if((ye(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&ye(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return on(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(n){const t={x:w(n,"x","sqrt","float32")};return T.runKernel(sc,t)}const It=C({sqrt_:Ew});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n){const e=w(n,"x","square"),t={};return T.runKernel("Square",{x:e},t)}const it=C({square_:Iw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(n,e=null,t=!1){let s=w(n,"x","sum");s.dtype==="bool"&&(s=ee(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return T.runKernel(rc,r,o)}const ue=C({sum_:kw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n,e="euclidean",t=null,s=!1){n=w(n,"x","norm");const r=df(n,e,t);let o=r.shape;if(s){const a=me(t,n.shape);o=Ke(r.shape,a)}return _(r,o)}function df(n,e,t=null){if(n.rank===0)return Ve(n);if(n.rank!==1&&t===null)return df(_(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ue(Ve(n),t);if(e===1/0)return wn(Ve(n),t);if(e===-1/0)return Hr(Ve(n),t);if(e==="euclidean"||e===2)return It(ue(Qn(Ve(n),K(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return wn(ue(Ve(n),t[0]),t[1]-1);if(e===1/0)return wn(ue(Ve(n),t[1]),t[0]);if(e===-1/0)return Hr(ue(Ve(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return It(ue(it(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const nr=C({norm_:Rw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _w(n,e=null,t=!1){return nr(n,"euclidean",e,t)}const pf=C({euclideanNorm_:_w});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw(n){const t={x:w(n,"x","exp")};return T.runKernel(Di,t)}const tn=C({exp_:Aw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ow(n,e=0){const t=w(n,"x","expandDims","string_or_numeric");v(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return T.runKernel(Pi,s,r)}const Me=C({expandDims_:Ow});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n){const t={x:w(n,"x","expm1")};return T.runKernel(Fi,t)}const hf=C({expm1_:Dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n,e){const t=w(n,"x","tile","string_or_numeric");v(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return T.runKernel(uo,s,r)}const qn=C({tile_:Pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fw(n,e,t,s="float32"){e==null&&(e=n);const r=le([n,e],s),o=n<=e?n:e;for(let i=0;i<o;++i)r.set(1,i,i);const a=_(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return qn(Me(a,0),[t[0],1,1]);if(t.length===2)return qn(Me(Me(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return qn(Me(Me(Me(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Xc=C({eye_:Fw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n){const t={x:w(n,"x","floor","float32")};return T.runKernel(Mi,t)}const Yc=C({floor_:Lw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n,e,t=0,s=0){const r=w(n,"x","gather"),o=w(e,"indices","gather","int32"),a={x:r,indices:o},i={axis:t,batchDims:s};return T.runKernel(zi,a,i)}const Qc=C({gather_:Bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(n,e){let t=w(n,"a","greater","string_or_numeric"),s=w(e,"b","greater","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(Hi,r)}const is=C({greater_:Vw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mw(n,e){let t=w(n,"a","greaterEqual","string_or_numeric"),s=w(e,"b","greaterEqual","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(ji,r)}const Zc=C({greaterEqual_:Mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n){const t={input:w(n,"input","imag")};return T.runKernel(qi,t)}const sr=C({imag_:Ww});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n){const t={x:w(n,"x","isFinite")};return T.runKernel(Xi,t)}const ff=C({isFinite_:Uw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n){const t={x:w(n,"x","isInf")};return T.runKernel(Yi,t)}const mf=C({isInf_:zw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(n){const t={x:w(n,"x","isNaN")};return T.runKernel(Qi,t)}const gf=C({isNaN_:Gw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e=.2){const s={x:w(n,"x","leakyRelu")},r={alpha:e};return T.runKernel(Zi,s,r)}const Jc=C({leakyRelu_:Hw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n,e){let t=w(n,"a","less","string_or_numeric"),s=w(e,"b","less","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(Ji,r)}const jr=C({less_:jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(n,e){let t=w(n,"a","lessEqual","string_or_numeric"),s=w(e,"b","lessEqual","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(eu,r)}const po=C({lessEqual_:Kw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return T.runKernel(tu,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n,e=5,t=1,s=1,r=.5){const o=w(n,"x","localResponseNormalization");v(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),v(vn(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=_(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:a},c={depthRadius:e,bias:t,alpha:s,beta:r},l=T.runKernel(iu,u,c);return i?_(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const xf=C({localResponseNormalization_:qw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n){const t={x:w(n,"x","log","float32")};return T.runKernel(nu,t)}const Zn=C({log_:Xw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yw(n){const t={x:w(n,"x","log1p")};return T.runKernel(su,t)}const el=C({log1p_:Yw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n){return v(Jt(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=w(e,"x","tf.grad","string_or_numeric"),r=t!=null?w(t,"dy","tf.grad"):null;return T.tidy(()=>{const{value:o,grads:a}=T.gradients(()=>n(s),[s],r);return r!=null&&Ce(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ho(a),a[0]})}}function Zw(n){return v(Jt(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{v(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Os(e,"args","tf.grads","string_or_numeric"),r=t!=null?w(t,"dy","tf.grads"):null;return T.tidy(()=>{const{value:o,grads:a}=T.gradients(()=>n(...s),s,r);return r!=null&&Ce(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ho(a),a})}}function Jw(n){return v(Jt(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{v(e instanceof te,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),v(t==null||t instanceof te,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=T.gradients(()=>n(e),[e],t);return ho(s),{grad:s[0],value:r}}}function e1(n){return v(Jt(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{v(Array.isArray(e)&&e.every(r=>r instanceof te),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),v(t==null||t instanceof te,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=T.gradients(()=>n(...e),e,t);return t!=null&&Ce(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ho(s.grads),s}}function bf(n,e){v(Jt(n),()=>"The f passed in variableGrads(f) must be a function"),v(e==null||Array.isArray(e)&&e.every(c=>c instanceof As),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in T.registeredVariables)e.push(T.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),v(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:i}=T.gradients(n,e,null,o);v(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),v(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return e.forEach((c,l)=>{i[l]!=null&&(u[c.name]=i[l])}),s!=null&&s.forEach(c=>u[c.name]=null),{value:a,grads:u}}function kt(n){return T.customGrad(n)}function ho(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1(n){const t={x:w(n,"x","neg")};return T.runKernel(wu,t)}const bt=C({neg_:t1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1(n){const t={x:w(n,"x","softplus")};return T.runKernel(nc,t)}const tl=C({softplus_:n1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1(n){const e=w(n,"x","logSigmoid");return kt(s=>({value:bt(tl(bt(s))),gradFunc:a=>L(a,Tt(bt(s)))}))(e)}const wf=C({logSigmoid_:s1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r1(n,e){let t=w(n,"a","sub"),s=w(e,"b","sub");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(bc,r)}const H=C({sub_:r1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1(n,e=-1){const t=w(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return kt((r,o)=>{const i=wn(r,e,!0),u=H(r,i),c=H(ee(u,"float32"),Zn(ue(tn(u),e,!0)));return o([c]),{value:c,gradFunc:(d,p)=>{const[h]=p,f=!0,g=tn(h);return H(d,L(ue(d,e,f),g))}}})(t)}const $f=C({logSoftmax_:o1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1(n,e=null,t=!1){const s=w(n,"x","logSumExp"),r=me(e,s.shape),o=wn(s,r,!0),a=H(s,o),i=tn(a),u=ue(i,r),c=Zn(u),l=W(_(o,c.shape),c);if(t){const d=Ke(l.shape,r);return _(l,d)}return l}const nl=C({logSumExp_:a1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1(n,e){const t=w(n,"a","logicalAnd","bool"),s=w(e,"b","logicalAnd","bool");X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(ru,r)}const Bs=C({logicalAnd_:i1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1(n){const t={x:w(n,"x","logicalNot","bool")};return T.runKernel(ou,t)}const sl=C({logicalNot_:u1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1(n,e){const t=w(n,"a","logicalOr","bool"),s=w(e,"b","logicalOr","bool");X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(au,r)}const rl=C({logicalOr_:c1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1(n,e){const t=w(n,"a","logicalXor","bool"),s=w(e,"b","logicalXor","bool");return X(t.shape,s.shape),Bs(rl(n,e),sl(Bs(n,e)))}const vf=C({logicalXor_:l1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hr=2147483648;function d1(n,e,t="left"){const s=w(n,"sortedSequence","searchSorted"),r=w(e,"values","searchSorted"),o=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],i=_(s,[-1,o]),u=_(r,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(P(u.shape)>=hr)throw new Error(`values tensor size must less than ${hr}`);if(i.shape[1]>=hr)throw new Error(`trailing dim_size must less than ${hr} for int32 output type, was ${i.shape[1]}`);const c={sortedSequence:i,values:u},l={side:t};return T.runKernel(qu,c,l)}const fo=C({searchSorted_:d1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sf(n,e){return fo(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(n,e,t,s,r){const o=w(n,"x","maxPool"),a=1;let i=o,u=!1;o.rank===3&&(u=!0,i=_(o,[1,o.shape[0],o.shape[1],o.shape[2]])),v(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),v(Ge(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ut("maxPool",s,r);const c={x:i},l={filterSize:e,strides:t,pad:s,dimRoundingMode:r},d=T.runKernel(lu,c,l);return u?_(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ol=C({maxPool_:p1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1(n,e=[1,1,1],t,s,r,o="NDHWC"){const a=w(n,"x","maxPool3d");let i=a,u=!1;a.rank===4&&(u=!0,i=_(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),v(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),v(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),ut("maxPool3d",s,r);const c={x:i},l={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},d=T.runKernel(du,c,l);return u?_(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Cf=C({maxPool3d_:h1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f1(n,e,t,s,r=!1){const a={x:w(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=T.runKernel(pu,a,i);return{result:u[0],indexes:u[1]}}const Tf=C({maxPoolWithArgmax_:f1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1(n,e){let t=w(n,"a","maximum"),s=w(e,"b","maximum");[t,s]=pe(t,s),t.dtype==="bool"&&(t=ee(t,"int32"),s=ee(s,"int32")),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(cu,r)}const al=C({maximum_:m1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1(n,e=null,t=!1){const r={x:w(n,"x","mean")},o={axis:e,keepDims:t};return T.runKernel(hu,r,o)}const Vs=C({mean_:g1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nn(n,e="float32"){if(ze(n),e==="complex64"){const s=nn(n,"float32"),r=nn(n,"float32");return Ut(s,r)}const t=Wt(P(n),e);return T.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(n,e="float32"){if(ze(n),e==="complex64"){const s=Yt(n,"float32"),r=nn(n,"float32");return Ut(s,r)}const t=La(P(n),e);return T.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nf(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=w(n,"x","meshgrid",n instanceof te?n.dtype:"float32");if(e===void 0)return[s];let r=w(e,"y","meshgrid",e instanceof te?e.dtype:"float32");const o=P(s.shape),a=P(r.shape);return t==="xy"?(s=_(s,[1,-1]),r=_(r,[-1,1]),[Z(Yt([a,1],s.dtype),s),Z(r,Yt([1,o],r.dtype))]):(s=_(s,[-1,1]),r=_(r,[1,-1]),[Z(s,Yt([1,a],s.dtype)),Z(Yt([o,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1(n,e){let t=w(n,"a","minimum"),s=w(e,"b","minimum");[t,s]=pe(t,s),t.dtype==="bool"&&(t=ee(t,"int32"),s=ee(s,"int32")),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel(mu,r)}const Ms=C({minimum_:y1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n,e,t){v(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=w(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");v(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let i=0;i<s.rank;i++)v(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),v(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},a={x:s};return T.runKernel(gu,a,o)}const il=C({mirrorPad_:x1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(n,e){let t=w(n,"a","mod"),s=w(e,"b","mod");[t,s]=pe(t,s);const r={a:t,b:s};return T.runKernel(yu,r)}const Ef=C({mod_:b1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(n,e=null,t=!1){n=w(n,"x","moments");const s=me(e,n.shape),r=Vs(n,s,t);let o=r.shape;t||(o=Ke(r.shape,s));const a=it(H(ee(n,"float32"),_(r,o))),i=Vs(a,s,t);return{mean:r,variance:i}}const If=C({moments_:w1});function $1(n,e,t,s){const r=w(e,"data","multiRNNCell"),o=Os(t,"c","multiRNNCell"),a=Os(s,"h","multiRNNCell");let i=r;const u=[];for(let d=0;d<n.length;d++){const p=n[d](i,o[d],a[d]);u.push(p[0]),u.push(p[1]),i=p[1]}const c=[],l=[];for(let d=0;d<u.length;d+=2)c.push(u[d]),l.push(u[d+1]);return[c,l]}const kf=C({multiRNNCell_:$1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1(n,e,t,s=!1){const r=w(n,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?_(r,[1,-1]):r},c={numSamples:e,seed:t,normalized:s},l=T.runKernel(xu,u,c);return a===1?_(l,[l.size]):l}const Rf=C({multinomial_:v1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1(n,e){let t=w(n,"a","notEqual","string_or_numeric"),s=w(e,"b","notEqual","string_or_numeric");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s};return T.runKernel($u,r)}const ul=C({notEqual_:S1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:w(n,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:t,offValue:s};return T.runKernel(Nu,a,i)}const Ws=C({oneHot_:C1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n){const t={x:w(n,"x","onesLike")};return T.runKernel(Tu,t)}const _f=C({onesLike_:T1});function N1(n,e){const t=w(n,"v1","outerProduct"),s=w(e,"v2","outerProduct");v(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=_(t,[-1,1]),o=_(s,[1,-1]);return Z(r,o)}const Af=C({outerProduct_:N1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(n,e,t=0){const s=w(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return T.runKernel(Iu,o,r)}const Fn=C({pad_:E1});function I1(n,e,t=0){return v(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Fn(n,[e],t)}const Of=C({pad1d_:I1});function k1(n,e,t=0){return v(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fn(n,e,t)}const Df=C({pad2d_:k1});function R1(n,e,t=0){return v(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fn(n,e,t)}const cl=C({pad3d_:R1});function _1(n,e,t=0){return v(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fn(n,e,t)}const Pf=C({pad4d_:_1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e,t){const s=w(n,"x","spaceToBatchND");v(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),v(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),v(s.shape.reduce((a,i,u)=>u>0&&u<=e.length?a&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return T.runKernel(oc,r,o)}const ll=C({spaceToBatchND_:A1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1(n,e,t,s,r,o,a){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const i=w(n,"x","maxPool");let u=i,c=!1;i.rank===3&&(c=!0,u=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),v(Ge(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const l=Pn(u.shape,e,o,r,s),d=[l.dilationHeight,l.dilationWidth];let p;s==="same"?p=P1([l.filterHeight,l.filterWidth],d):p=[[0,0],[0,0]];const h=d[0]===1&&d[1]===1,[f,g]=D1([l.inHeight,l.inWidth],d,p),m=h?s:"valid",y=h?u:ll(u,d,f),$=(t==="avg"?()=>Uc(y,e,o,m,a):()=>ol(y,e,o,m,a))(),S=h?$:zc($,d,g);return c?_(S,[S.shape[1],S.shape[2],S.shape[3]]):S}function D1(n,e,t){const s=t.map(l=>l[0]),r=t.map(l=>l[1]),o=n.concat(s,r),a=e.map((l,d)=>(l-o[d]%l)%l),i=r.map((l,d)=>l+a[d]),u=e.map((l,d)=>[s[d],i[d]]),c=e.map((l,d)=>[0,a[d]]);return[u,c]}function P1(n,e){const s=n.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,i)=>a-r[i]);return s.map((a,i)=>[r[i],o[i]])}const Ff=C({pool_:O1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(n,e){const t=w(n,"x","prelu"),s=w(e,"alpha","prelu"),r={x:t,alpha:s};return T.runKernel(Ru,r)}const dl=C({prelu_:F1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1(n,e=null,t=!1){let s=w(n,"x","prod");s.dtype==="bool"&&(s=ee(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return T.runKernel(_u,r,o)}const Lf=C({prod_:L1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1(n,e,t,s){const r=n.map((l,d)=>w(l,`tensors${d}`,"raggedGather","int32")),o=w(e,"paramsDenseValues","raggedGather"),a=w(t,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:o,indices:a},u={outputRaggedRank:s},c=T.runKernel(Au,i,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const Bf=C({raggedGather_:B1});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(n,e,t){const s=w(n,"starts","raggedRange"),r=w(e,"limits","raggedRange",s.dtype),o=w(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:o},i=T.runKernel(Ou,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const Vf=C({raggedRange_:V1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1(n,e,t,s,r){const o=w(n,"shape","raggedTensorToTensor","int32"),a=w(e,"values","raggedTensorToTensor"),i=w(t,"defaultValue","raggedTensorToTensor",a.dtype),u=s.map((d,p)=>w(d,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:o,values:a,defaultValue:i,rowPartitionTensors:u},l={rowPartitionTypes:r};return T.runKernel(Du,c,l)}const Mf=C({raggedTensorToTensor_:M1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1(n,e,t){ze(n);const s=P(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return T.makeTensor(r,n,t)}const Wf=C({rand_:W1});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1=.001,Uf=.1;function z1(n,e,t){return t==null&&(t=pl()),pa(n,e,(s,r)=>hl(s,r,t))}function pl(){return T.backend.floatPrecision()===32?U1:Uf}function pa(n,e,t){let s=!0;if((ye(n)||ye(e))&&(s=!1),ye(n)&&ye(e)&&(s=!0),s){const a=n.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=Et(n),i=Et(e);if(!ce(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}const r=ye(n)?n:Nt(n),o=ye(e)?e:Nt(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const i=r[a],u=o[a];if(!t(i,u))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${u}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function G1(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function H1(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Ft(n)||Ft(n[0])||Ft(e)||Ft(e[0])?pa(n,t,(s,r)=>s==r):pa(n,e,(s,r)=>hl(s,r,0))}function j1(n,e,t){if(t==null&&(t=pl()),!hl(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function hl(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function K1(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function q1(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function zf(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?zf(t):n[e]=Lt(t)}return n}function X1(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function Y1(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const Q1=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Uf,createVideoElement:X1,encodeStrings:zf,expectArrayBuffersEqual:q1,expectArraysClose:z1,expectArraysEqual:H1,expectNumbersClose:j1,expectPromiseToFail:G1,expectValuesInRange:K1,play:Y1,testEpsilon:pl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fl{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Pa.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Z1{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=Pa.alea(o.toString()),this.randn=new fl(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<t||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class J1{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Pa.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(n,e,t=1,s="float32",r){if(ze(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new Z1(e,t,s,r),a=le(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const Gf=C({randomGamma_:e$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n,e=0,t=1,s,r){if(ze(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new fl(e,t,s,!1,r),a=le(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ml=C({randomNormal_:t$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ml(n,0,1,e,t)}const Hf=C({randomStandardNormal_:n$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e=0,t=1,s="float32",r){ze(n);const o=le(n,s),a=new J1(e,t,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const mo=C({randomUniform_:s$});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n,e,t,s){return mo(n,e,t,"int32",s)}const jf=C({randomUniformInt_:r$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sn(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return T.runKernel(Pu,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(n){const t={input:w(n,"input","real")};return T.runKernel(Fu,t)}const Jn=C({real_:o$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n){const t={x:w(n,"x","reciprocal")};return T.runKernel(Lu,t)}const Kf=C({reciprocal_:a$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n){const t={x:w(n,"x","relu")};return T.runKernel(Bu,t)}const rr=C({relu_:i$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(n){const t={x:w(n,"x","relu6")};return T.runKernel(Uu,t)}const gl=C({relu6_:u$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(n,e){const s={x:w(n,"x","reverse")},r={dims:e};return T.runKernel(zu,s,r)}const rn=C({reverse_:c$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const e=w(n,"x","reverse");return v(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),rn(e,0)}const qf=C({reverse1d_:l$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n,e){const t=w(n,"x","reverse");return v(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),rn(t,e)}const Xf=C({reverse2d_:d$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(n,e){const t=w(n,"x","reverse");return v(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),rn(t,e)}const Yf=C({reverse3d_:p$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n,e){const t=w(n,"x","reverse");return v(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),rn(t,e)}const Qf=C({reverse4d_:h$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n){const t={x:w(n,"x","round")};return T.runKernel(Gu,t)}const yl=C({round_:f$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n){const t={x:w(n,"x","rsqrt","float32")};return T.runKernel(Hu,t)}const Zf=C({rsqrt_:m$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(n){const t={x:w(n,"x","selu")};return T.runKernel(Yu,t)}const Jf=C({selu_:g$});function y$(n,e,t,s,r,o=[1,1],a="NHWC"){const i=w(n,"x","separableConv2d"),u=w(e,"depthwiseFilter","separableConv2d"),c=w(t,"pointwiseFilter","separableConv2d");let l=i,d=!1;if(i.rank===3&&(d=!0,l=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");v(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),v(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),v(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),v(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),v(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=u.shape[2],h=u.shape[3];v(c.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${c.shape[2]}.`);const f=lo(l,u,s,r,a,o),m=er(f,c,1,"valid",a);return d?_(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const em=C({separableConv2d_:y$});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function x$(n,e){const t=w(n,"x","setdiff1d"),s=w(e,"y","setdiff1d");v(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),v(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),v(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),a=new Set(o);let i=0;for(let l=0;l<r.length;l++)a.has(r[l])||i++;const u=new Cn([i],t.dtype),c=new Cn([i],"int32");for(let l=0,d=0;l<r.length;l++)a.has(r[l])||(u.values[d]=r[l],c.values[d]=l,d++);return[u.toTensor(),c.toTensor()]}const tm=x$;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n){const t={x:w(n,"x","sign")};return T.runKernel(ec,t)}const nm=C({sign_:b$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$(n){const t={x:w(n,"x","sin","float32")};return T.runKernel(Zu,t)}const sm=C({sin_:w$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n){const t={x:w(n,"x","sinh")};return T.runKernel(Ju,t)}const rm=C({sinh_:$$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(n,e,t){const s=w(n,"x","slice1d");return v(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),re(s,[e],[t])}const om=C({slice1d_:v$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(n,e,t){const s=w(n,"x","slice2d");return v(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),re(s,e,t)}const am=C({slice2d_:S$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$(n,e,t){const s=w(n,"x","slice3d");return v(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),re(s,e,t)}const im=C({slice3d_:C$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(n,e,t){const s=w(n,"x","slice4d");return v(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),re(s,e,t)}const um=C({slice4d_:T$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(n,e=-1){const t=w(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return T.runKernel(ic,s,r)}const cm=C({softmax_:N$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(n){v(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return T.runKernel(Li,e)}const go=C({fft_:E$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n){v(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return T.runKernel(Ki,e)}const Us=C({ifft_:I$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=_(n,[t,e]);s=Us(r)}else{const r=[t,2*(e-1)],o=_(Jn(n),[t,e]),a=_(sr(n),[t,e]),i=rn(re(o,[0,1],[t,e-2]),1),u=L(rn(re(a,[0,1],[t,e-2]),1),K(-1)),c=Se([o,i],1),l=Se([a,u],1),d=_(Ut(c,l),[r[0],r[1]]);s=Us(d)}if(s=Jn(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=_(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const xl=C({irfft_:k$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(n,e,t=0){const r={x:w(n,"x","split")},o={numOrSizeSplits:e,axis:t};return T.runKernel(ac,r,o)}const es=C({split_:R$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n,e){v(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=e,r=re(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,r=Se([n,nn(f)],n.shape.length-1),t=e}else r=n;const o=We(r),a=_(Ut(r,o),[s,t]),i=go(a),u=Math.floor(t/2)+1,c=Jn(i),l=sr(i),d=es(c,[u,t-u],c.shape.length-1),p=es(l,[u,t-u],l.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=u,_(Ut(d[0],p[0]),h)}const yo=C({rfft_:_$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(n,e){let t=w(n,"a","squaredDifference"),s=w(e,"b","squaredDifference");[t,s]=pe(t,s),X(t.shape,s.shape);const r={a:t,b:s},o={};return T.runKernel(hc,r,o)}const bl=C({squaredDifference_:A$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(n,e){const t=w(n,"x","squeeze","string_or_numeric");return _(t,zt(t.shape,e).newShape)}const st=C({squeeze_:O$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n,e=0){const t=Os(n,"tensors","stack","string_or_numeric");v(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&v(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return T.runKernel(Eu,s,r)}const Rt=C({stack_:D$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(n,e=0){const s={x:w(n,"x","step")},r={alpha:e};return T.runKernel(Ic,s,r)}const wl=C({step_:P$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(n,e,t,s,r=0,o=0,a=0,i=0,u=0){const l={x:w(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return T.runKernel(mc,l,d)}const lm=C({stridedSlice_:F$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const t={x:w(n,"x","tan","float32")};return T.runKernel(wc,t)}const dm=C({tan_:L$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rt(n,e){On(n);const t=Et(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return on(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $n(n,e,t){if(On(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Et(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return on(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(n,e,t){if(On(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Et(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return on(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pm(n,e,t){if(On(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Et(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return on(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hm(n,e,t){if(On(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Et(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return on(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fm(n,e,t){if(On(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Et(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,on(n,e,s,t)}function vl(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(o+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function xo(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}vl(t,e,n)}function or(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let a=1;for(let d=r;d<o;++d)a*=t[d];const i=r<1?1:r,u=P(e.shape)/i,c=[...xe(t.slice(0,r)),1],l=P(t);return{sliceRank:r,numUpdates:u,sliceSize:a,strides:c,outputSize:l}}const B$=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:or,validateInput:xo,validateUpdateShape:vl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n,e,t){const s=w(n,"tensor","tensorScatterupdate"),r=w(e,"indices","tensorScatterupdate","int32"),o=w(t,"updates","tensorScatterupdate");if(xo(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const a={tensor:s,indices:r,updates:o},i={};return T.runKernel(Ku,a,i)}const mm=C({tensorScatterUpdate_:V$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(n,e=1,t=!0){const s=w(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},a={k:e,sorted:t},[i,u]=T.runKernel(vc,o,a);return{values:i,indices:u}}const gm=C({topk_:M$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n,e=0,t=1,s,r){if(ze(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new fl(e,t,s,!0,r),a=le(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ym=C({truncatedNormal_:W$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n,e=0){const t=w(n,"x","unique","string_or_numeric");v(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,a]=T.runKernel(Cc,s,r);return{values:o,indices:a}}const xm=C({unique_:U$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t){const s=w(n,"x","unsortedSegmentSum"),r=w(e,"segmentIds","unsortedSegmentSum","int32");v(vn(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},a={numSegments:t};return T.runKernel(Nc,o,a)}const bm=C({unsortedSegmentSum_:z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e=0){const t=w(n,"x","unstack","string_or_numeric");v(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return T.runKernel(Tc,s,r)}const an=C({unstack_:G$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wm(n,e){return fo(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $m(n,e=!0,t,s){return T.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=le(n,"int32"),r=le([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const a=s.indexToLoc(t[o]),i=o*n.length;r.values.set(a,i)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function H$(n){const e=w(n,"condition","whereAsync","bool"),t=await e.data(),s=Sl(e.shape,t);return n!==e&&e.dispose(),s}const Cl=H$;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function j$(n,e,t){const s=w(n,"tensor","boolMask"),r=w(e,"mask","boolMask","bool"),o=t??0,a=r.rank,i=s.shape;v(a>0,()=>"mask cannot be scalar"),Ce(i.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let g=o;g<o+a;g++)u*=i[g];const c=i.slice(0,o).concat([u],i.slice(o+a)),l=_(s,c),d=_(r,[-1]),p=await Cl(d),h=st(p,[1]),f=Qc(l,h,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),h.dispose(),l.dispose(),d.dispose(),p.dispose(),f}const vm=j$;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(n,e,t){const s=w(n,"x","transpose");if(e==null&&(e=s.shape.map((a,i)=>i).reverse()),v(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{v(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?U(()=>{let a=Jn(s),i=sr(s);return a=T.runKernel(Es,{x:a},o),i=T.runKernel(Es,{x:i},o),t&&(i=bt(i)),Ut(a,i)}):T.runKernel(Es,r,o)}const zs=C({transpose_:K$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n,e,t,s,r=!0){const o=w(n,"v","movingAverage"),a=w(e,"x","movingAverage"),i=w(t,"decay","movingAverage");nh(o,a),v(ce(o.shape,a.shape),()=>"Shape mismatch in v and x");const u=K(1),c=H(u,i);let l=L(H(a,o),c);if(r){v(s!=null,()=>"When using zeroDebias: true, step is required.");const d=w(s,"step","movingAverage");l=ae(l,H(u,Qn(i,d)))}return W(o,l)}const Sm=C({movingAverage_:q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n,e,t){ze(t);const s=w(n,"indices","scatterND","int32"),r=w(e,"updates","scatterND");xo(r,s,t);const o={indices:s,updates:r},a={shape:t};return T.runKernel(ju,o,a)}const Cm=C({scatterND_:X$});function Y$(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(n,e,t,s=0){ze(t);const r=w(n,"sparseIndices","sparseToDense","int32"),o=w(e,"sparseValues","sparseToDense","string_or_numeric"),a=w(s,"defaultValue","sparseToDense",o.dtype);Y$(r,o,t,a);const i={sparseIndices:r,sparseValues:o,defaultValue:a},u={outputShape:t};return T.runKernel(pc,i,u)}const Tm=C({sparseToDense_:Q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n,e){const t=w(e,"indices","gatherND","int32"),r={params:w(n,"x","gatherND","string_or_numeric"),indices:t};return T.runKernel(Gi,r)}const Nm=C({gatherND_:Z$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n,e){if(e==null)return n.shape.slice();if(ce(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n,e,t,s){const r=w(n,"x","dropout");if(v(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),v(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof te?r.clone():r;const o=J$(r,t),a=1-e,i=ae(Yc(W(mo(o,0,1,"float32",s),a)),a);return L(r,i)}const Em=C({dropout_:ev});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function bo(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const a=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(a)}return rt(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function tv(n,e,t=1){const s=w(n,"predictions","inTopK"),r=w(e,"targets","inTopK");v(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),v(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ce(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];v(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const a=await s.data(),i=await r.data(),[u,c]=[a.length/o,o],l=Mt("bool",u);for(let d=0;d<u;d++){const p=d*c,h=a.subarray(p,p+c),f=[];for(let g=0;g<h.length;g++)f.push({value:h[g],index:g});f.sort((g,m)=>m.value-g.value),l[d]=0;for(let g=0;g<t;g++)if(f[g].index===i[d]){l[d]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),at(l,r.shape,"bool")}const Im=tv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n,e,t,s,r,o="NHWC",a){let i=n;n.rank===3&&(i=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=_(e,[1,e.shape[0],e.shape[1],e.shape[2]])),v(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),v(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),v(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=o==="NHWC"?i.shape[3]:i.shape[1],l=o==="NHWC"?u.shape[3]:u.shape[1];v(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),v(l===t[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${t[3]}).`),ut("conv2dDerFilter",r,a);const d={x:i,dy:u},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:t};return T.runKernel(pi,d,p)}const sv=C({conv2DBackpropFilter_:nv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return L(n,wl(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function $o(n,e){let t=e;const s=Hc(n.shape,e.shape);return s.length>0&&(t=ue(t,s)),_(t,n.shape)}function vo(n,e,t,s){if(e==="linear")return n;if(e==="relu")return rr(n);if(e==="elu")return jc(n);if(e==="relu6")return gl(n);if(e==="prelu")return dl(n,t);if(e==="leakyrelu")return Jc(n,s);if(e==="sigmoid")return Tt(n);throw new Error(`Unknown fused activation ${e}.`)}const So=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",So(T.state.gradientDepth,u)===!1){v(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=er(n,e,t,s,r,o,a);return i!=null&&(E=W(E,i)),vo(E,u,c,l)}const d=w(n,"x","conv2d","float32"),p=w(e,"filter","conv2d","float32");let h=d,f=!1;d.rank===3&&(f=!0,h=_(d,[1,d.shape[0],d.shape[1],d.shape[2]])),v(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),v(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),ut("fused conv2d",s,a);const g=r==="NHWC"?h.shape[3]:h.shape[1];v(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),v(Ge(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const m=je(h.shape,p.shape,t,o,s,a);let y;i!=null&&(y=w(i,"bias","fused conv2d"),[y]=pe(y,d),r==="NHWC"?X(m.outShape,y.shape):(v(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),v(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let b;if(c!=null){const E=c.shape;if(v(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)v(E[0]===1||E[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${m.outChannels}).`);else if(E.length===3)try{X(E,m.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(R)}b=w(c,"prelu weights","fused conv2d")}const $=(E,k)=>{v(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,A,O,D]=k,V=wo(E,O,u);v(Fs(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const z=jh(A.shape,V,R,t,s),G=sv(A,V,R.shape,t,s),j=[z,G];if(D!=null){const q=$o(D,V);j.push(q)}return j},S={x:h,filter:p,bias:y,preluActivationWeights:b},N={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:l};return i==null?kt((k,R,A)=>{let O=T.runKernel(Mr,S,N);return A([R,k,O]),f&&(O=_(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:$}})(h,p):kt((k,R,A,O)=>{let D=T.runKernel(Mr,S,N);return O([R,k,D,A]),f&&(D=_(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:$}})(h,p,y)}const ov=C({fusedConv2d_:rv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n,e,t,s,r,o=[1,1],a){let i=n;n.rank===3&&(i=_(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:u},l={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:t};return T.runKernel(Ci,c,l)}const iv=C({depthwiseConv2dNativeBackpropFilter_:av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uv(n,e,t,s,r,o=[1,1],a){let i=e,u=!1;e.rank===3&&(u=!0,i=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:t},l={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:n},d=T.runKernel(Ti,c,l);return u?_(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const cv=C({depthwiseConv2dNativeBackpropInput_:uv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lv({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(So(T.state.gradientDepth,u)===!1){let N=lo(n,e,t,s,r,o,a);return i!=null&&(N=W(N,i)),vo(N,u,c,l)}const d=w(n,"x","depthwiseConv2d","float32"),p=w(e,"filter","depthwiseConv2d","float32");let h=d,f=!1;d.rank===3&&(f=!0,h=_(d,[1,d.shape[0],d.shape[1],d.shape[2]])),v(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),v(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),v(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),v(Ge(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ut("fused depthwiseConv2d",s,a);const g=je(h.shape,p.shape,t,o,s,a,!0);let m;i!=null&&(m=w(i,"bias","fused conv2d"),[m]=pe(m,d),X(g.outShape,m.shape));let y;c!=null&&(y=w(c,"prelu weights","fused depthwiseConv2d"));const b=(N,E)=>{v(Fs(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[k,R,A,O]=E,D=wo(N,A,u),V=cv(R.shape,D,k,t,s,o,a),z=iv(R,D,k.shape,t,s,o,a);if(O!=null){const G=$o(m,D);return[V,z,G]}return[V,z]},$={x:h,filter:p,bias:m,preluActivationWeights:y},S={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:l};return i==null?kt((E,k,R)=>{let A=T.runKernel(Wr,$,S);return R([k,E,A]),f&&(A=_(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(h,p):kt((E,k,R,A)=>{let O=T.runKernel(Wr,$,S);return A([k,E,O,R]),f&&(O=_(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(h,p,m)}const dv=C({fusedDepthwiseConv2d_:lv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pv({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(So(T.state.gradientDepth,o)===!1){let D=Z(n,e,t,s);return r!=null&&(D=W(D,r)),vo(D,o,a,i)}let u=w(n,"a","fused matMul"),c=w(e,"b","fused matMul");[u,c]=pe(u,c);const l=t?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?u.shape[u.rank-1]:u.shape[u.rank-2],h=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),g=c.shape.slice(0,-2),m=P(f),y=P(g);v(l===d,()=>`Error in fused matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const $=X(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,h]),S=t?_(u,[m,l,p]):_(u,[m,p,l]),N=s?_(c,[y,h,d]):_(c,[y,d,h]);let E;r!=null&&(E=w(r,"bias","fused matMul"),[E]=pe(E,u),X($,E.shape));let k;a!=null&&(k=w(a,"prelu weights","fused matMul"));const R=(D,V)=>{const[z,G,j,q]=V,Q=wo(_(D,j.shape),j,o);let J,he;if(!t&&!s?(J=Z(Q,G,!1,!0),he=Z(z,Q,!0,!1)):!t&&s?(J=Z(Q,G,!1,!1),he=Z(Q,z,!0,!1)):t&&!s?(J=Z(G,Q,!1,!0),he=Z(z,Q,!1,!1)):(J=Z(G,Q,!0,!0),he=Z(Q,z,!0,!0)),r!=null){const Fe=$o(q,Q);return[J,he,Fe]}else return[J,he]},A={a:S,b:N,bias:E,preluActivationWeights:k},O={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:i};return r==null?kt((V,z,G)=>{const j=T.runKernel(Vr,A,O);return G([V,z,j]),{value:_(j,$),gradFunc:R}})(S,N):kt((V,z,G,j)=>{const q=T.runKernel(Vr,A,O);return j([V,z,q,G]),{value:_(q,$),gradFunc:R}})(S,N,E)}const hv=C({fusedMatMul_:pv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const km=Object.freeze(Object.defineProperty({__proto__:null,conv2d:ov,depthwiseConv2d:dv,matMul:hv},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n){return bo(n,.54,.46)}const mv=C({hammingWindow_:fv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n){return bo(n,.5,.5)}const Rm=C({hannWindow_:gv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(n,e,t,s=!1,r=0){let o=0;const a=[];for(;o+e<=n.size;)a.push(re(n,o,e)),o+=t;if(s)for(;o<n.size;){const i=o+e-n.size,u=Se([re(n,o,e-i),as([i],r)]);a.push(u),o+=t}return a.length===0?$n([],[0,e]):_(Se(a),[a.length,e])}const _m=C({frame_:yv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n,e,t,s,r=Rm){s==null&&(s=Tl(e));const o=_m(n,e,t),a=L(o,r(e));return yo(a,s)}const bv=C({stft_:xv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wv(n,e,t,s,r="bilinear",o=0){const a=w(n,"image","cropAndResize"),i=w(e,"boxes","cropAndResize","float32"),u=w(t,"boxInd","cropAndResize","int32"),c=i.shape[0];v(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),v(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),v(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),v(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),v(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),v(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const l={image:a,boxes:i,boxInd:u},d={method:r,extrapolationValue:o,cropSize:s};return T.runKernel(wi,l,d)}const $v=C({cropAndResize_:wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n){const e=w(n,"image","flipLeftRight","float32");v(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return T.runKernel(Vi,t,{})}const Sv=C({flipLeftRight_:vv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n){const e=w(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];v(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),v(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,qn(e,r)}const Tv=C({grayscaleToRGB_:Cv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nv(n,e,t=0,s=.5){const r=w(n,"image","rotateWithOffset","float32");v(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},a={radians:e,fillValue:t,center:s};return T.runKernel(kc,o,a)}const Ev=C({rotateWithOffset_:Nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function us(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=n.shape[0];return t=Math.min(t,a),v(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),v(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),v(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),v(e.rank===1,()=>"scores must be a 1D tensor"),v(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),v(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=w(n,"boxes","nonMaxSuppression","float32"),a=w(e,"scores","nonMaxSuppression","float32"),i=us(o,a,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return T.runKernel(vu,{boxes:o,scores:a},u)}const kv=C({nonMaxSuppression_:Iv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n,e,t){const s=_v(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function _v(n,e,t){return Ov(n,e,t||Av)}function Av(n,e){return n>e?1:n<e?-1:0}function Ov(n,e,t){let s=0,r=n.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const i=t(e,n[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(n,e,t,s,r){return kl(n,e,t,s,r,0)}function El(n,e,t,s,r,o){return kl(n,e,t,s,r,0,!1,o,!0)}function Il(n,e,t,s,r,o){return kl(n,e,t,s,r,o,!0)}function kl(n,e,t,s,r,o,a=!1,i=!1,u=!1){const c=[];for(let m=0;m<e.length;m++)e[m]>r&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(hd);const l=o>0?-.5/o:0,d=[],p=[];for(;d.length<t&&c.length>0;){const m=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:$}=m;if(y<r)break;let S=!1;for(let N=d.length-1;N>=$;--N){const E=Dv(n,b,d[N]);if(E>=s){S=!0;break}if(m.score=m.score*Pv(s,l,E),m.score<=r)break}m.suppressBeginIndex=d.length,S||(m.score===y?(d.push(b),p.push(m.score)):m.score>r&&Rv(c,m,hd))}const h=d.length,f=t-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const g={selectedIndices:d};return a&&(g.selectedScores=p),u&&(g.validOutputs=h),g}function Dv(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),l=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),h=(i-o)*(u-a),f=(d-c)*(p-l);if(h<=0||f<=0)return 0;const g=Math.max(o,c),m=Math.max(a,l),y=Math.min(i,d),b=Math.min(u,p),$=Math.max(y-g,0)*Math.max(b-m,0);return $/(h+f-$)}function Pv(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function hd(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Fv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=w(n,"boxes","nonMaxSuppressionAsync"),a=w(e,"scores","nonMaxSuppressionAsync"),i=us(o,a,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u=await Promise.all([o.data(),a.data()]),c=u[0],l=u[1],{selectedIndices:d}=Nl(c,l,t,s,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),rt(d,"int32")}const Lv=Fv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=w(n,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=us(a,i,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const c={boxes:a,scores:i},l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},d=T.runKernel(Cu,c,l);return{selectedIndices:d[0],selectedScores:d[1]}}const Vv=C({nonMaxSuppressionWithScore_:Bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Mv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=w(n,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=us(a,i,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const c=await Promise.all([a.data(),i.data()]),l=c[0],d=c[1],{selectedIndices:p,selectedScores:h}=Il(l,d,t,s,r,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:rt(p,"int32"),selectedScores:rt(h)}}const Wv=Mv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=w(n,"boxes","nonMaxSuppression"),i=w(e,"scores","nonMaxSuppression"),u=us(a,i,t,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,p={boxes:a,scores:i},h={maxOutputSize:c,iouThreshold:l,scoreThreshold:d,padToMaxOutputSize:o},f=T.runKernel(Su,p,h);return{selectedIndices:f[0],validOutputs:f[1]}}const zv=C({nonMaxSuppressionPadded_:Uv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Gv(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=w(n,"boxes","nonMaxSuppressionAsync"),i=w(e,"scores","nonMaxSuppressionAsync"),u=us(a,i,t,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,[p,h]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:g}=El(p,h,c,l,d,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:rt(f,"int32"),validOutputs:K(g,"int32")}}const Hv=Gv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e,t=!1,s=!1){const r=w(n,"images","resizeBilinear");v(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),v(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),v(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=_(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},c=T.runKernel(Wu,i,u);return a?_(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Kv=C({resizeBilinear_:jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n,e,t=!1,s=!1){const r=w(n,"images","resizeNearestNeighbor");v(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),v(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),v(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),v(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=_(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},c=T.runKernel(Mu,i,u);return a?_(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Xv=C({resizeNearestNeighbor_:qv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n,e="binary",t=!1,s=.5){const r=w(n,"image","threshold"),o=.2989,a=.587,i=.114,u=r.shape[0]*r.shape[1];let c=L(rt([s]),255),l,d,p,h;if(v(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),v(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),v(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),v(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[l,d,p]=es(r,[1,1,1],-1);const m=L(l,o),y=L(d,a),b=L(p,i);h=W(W(m,y),b)}else h=n;if(e==="otsu"){const m=Gc(ee(yl(h),"int32"),at([]),256);c=Qv(m,u)}const f=t?po(h,c):is(h,c);return ee(L(f,255),"int32")}function Qv(n,e){let t=rt([-1]),s=rt([0]),r=rt([0]),o,a,i,u,c,l;for(let d=0;d<n.size-1;d++){o=re(n,0,d+1),a=re(n,d+1),c=ae(ue(o),e),l=ae(ue(a),e);const p=ue(L(o,sn(0,o.size)));i=ae(p,ue(o));const h=as(a.shape,o.size),f=W(sn(0,a.size),h),g=L(a,f);u=ae(ue(g),ue(a));const m=H(i,u),y=H(i,u),b=L(c,l);r=L(L(b,m),y);const $=is(r,s);s=Vt($,r,s),t=Vt($,rt([d]),t)}return t}const Zv=C({threshold_:Yv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jv(n,e,t="nearest",s="constant",r=0,o){const a=w(n,"image","transform","float32"),i=w(e,"transforms","transform","float32");v(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),v(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),v(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:a,transforms:i},c={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return T.runKernel(Sc,u,c)}const eS=C({transform_:Jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(n,e,t){const s=w(n,"a","bandPart");v(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,a]=s.shape.slice(-2);let i,u;typeof e=="number"?(v(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),v(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),i=w(e<0?o:e,"numLower","bandPart")):(v(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=Vt(jr(e,0),o,Ms(e,o))),typeof t=="number"?(v(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),v(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),u=w(t<0?a:t,"numUpper","bandPart")):(v(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Vt(jr(t,0),a,Ms(t,a)));const c=_(sn(0,o,1,"int32"),[-1,1]),l=sn(0,a,1,"int32"),d=H(c,l),p=Bs(po(d,i),Zc(d,bt(u))),h=nn([o,a],s.dtype);return _(Rt(an(_(s,[-1,o,a])).map(f=>Vt(p,f,h))),r)}const nS=C({bandPart_:tS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(n){let e;if(Array.isArray(n)){e=!1,v(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)v(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=es(n,n.shape[0],0).map(r=>st(r,[0]));v(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(T.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){const i=L(ue(L(t[a],o)),t[a]);o=H(o,i)}return ae(o,nr(o,"euclidean"))}));return e?Rt(t,0):t}const rS=C({gramSchmidt_:sS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(n,e=!1){if(v(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return fd(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,c)=>u*c),s=an(_(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(u=>{const[c,l]=fd(u,e);r.push(c),o.push(l)});const a=_(Rt(r,0),n.shape),i=_(Rt(o,0),n.shape);return[a,i]}}function fd(n,e=!1){return T.tidy(()=>{v(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=Xc(t),o=Bt(n);const a=$n([[1]],[1,1]);let i=Bt(a);const u=t>=s?s:t;for(let c=0;c<u;++c){const l=o,d=i,p=r;[i,o,r]=T.tidy(()=>{const h=re(o,[c,c],[t-c,1]),f=nr(h),g=re(o,[c,c],[1,1]),m=Vt(is(g,0),$n([[-1]]),$n([[1]])),y=H(g,L(m,f)),b=ae(h,y);b.shape[0]===1?i=Bt(a):i=Se([a,re(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const $=bt(ae(Z(m,y),f)),S=re(o,[c,0],[t-c,s]),N=L($,i),E=zs(i);if(c===0)o=H(S,Z(N,Z(E,S)));else{const A=H(S,Z(N,Z(E,S)));o=Se([re(o,[0,0],[c,s]),A],0)}const k=zs(N),R=re(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=H(R,Z(Z(R,i),k));else{const A=H(R,Z(Z(R,i),k));r=Se([re(r,[0,0],[t,c]),A],1)}return[i,o,r]}),_e([l,d,p])}return!e&&t>s&&(r=re(r,[0,0],[t,s]),o=re(o,[0,0],[s,s])),[r,o]})}const aS=C({qr_:oS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ke;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ke||(ke={}));function iS(n,e,t=ke.SUM_BY_NONZERO_WEIGHTS){const s=w(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=w(e,"weights","computeWeightedLoss"));const o=r==null?s:L(s,r);if(t===ke.NONE)return o;if(t===ke.SUM)return ue(o);if(t===ke.MEAN){if(r==null)return Vs(o);{const a=s.size/r.size,i=ae(ue(o),ue(r));return a>1?ae(i,K(a)):i}}if(t===ke.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ae(ue(o),K(s.size));{const a=L(r,Yt(s.shape)),i=ee(ue(ul(a,K(0))),"float32");return ae(ue(o),i)}}throw Error(`Unknown reduction: ${t}`)}const Gt=C({computeWeightedLoss_:iS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uS(n,e,t,s=ke.SUM_BY_NONZERO_WEIGHTS){const r=w(n,"labels","absoluteDifference"),o=w(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=w(t,"weights","absoluteDifference")),Ce(r.shape,o.shape,"Error in absoluteDifference: ");const i=Ve(H(r,o));return Gt(i,a,s)}const cS=C({absoluteDifference_:uS});function lS(n,e,t,s,r=ke.SUM_BY_NONZERO_WEIGHTS){const o=w(n,"labels","cosineDistance"),a=w(e,"predictions","cosineDistance");let i=null;s!=null&&(i=w(s,"weights","cosineDistance")),Ce(o.shape,a.shape,"Error in cosineDistance: ");const u=K(1),c=H(u,ue(L(o,a),t,!0));return Gt(c,i,r)}const dS=C({cosineDistance_:lS});function pS(n,e,t,s=ke.SUM_BY_NONZERO_WEIGHTS){let r=w(n,"labels","hingeLoss");const o=w(e,"predictions","hingeLoss");let a=null;t!=null&&(a=w(t,"weights","hingeLoss")),Ce(r.shape,o.shape,"Error in hingeLoss: ");const i=K(1);r=H(L(K(2),r),i);const u=rr(H(i,L(r,o)));return Gt(u,a,s)}const hS=C({hingeLoss_:pS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(n,e,t,s=1,r=ke.SUM_BY_NONZERO_WEIGHTS){const o=w(n,"labels","huberLoss"),a=w(e,"predictions","huberLoss");let i=null;t!=null&&(i=w(t,"weights","huberLoss")),Ce(o.shape,a.shape,"Error in huberLoss: ");const u=K(s),c=Ve(H(a,o)),l=Ms(c,u),d=H(c,l),p=W(L(K(.5),it(l)),L(u,d));return Gt(p,i,r)}const mS=C({huberLoss_:fS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(n,e,t,s=1e-7,r=ke.SUM_BY_NONZERO_WEIGHTS){const o=w(n,"labels","logLoss"),a=w(e,"predictions","logLoss");let i=null;t!=null&&(i=w(t,"weights","logLoss")),Ce(o.shape,a.shape,"Error in logLoss: ");const u=K(1),c=K(s),l=bt(L(o,Zn(W(a,c)))),d=L(H(u,o),Zn(W(H(u,a),c))),p=H(l,d);return Gt(p,i,r)}const yS=C({logLoss_:gS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xS(n,e,t,s=ke.SUM_BY_NONZERO_WEIGHTS){const r=w(n,"labels","meanSquaredError"),o=w(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=w(t,"weights","meanSquaredError")),Ce(r.shape,o.shape,"Error in meanSquaredError: ");const i=bl(r,o);return Gt(i,a,s)}const bS=C({meanSquaredError_:xS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e){const t=w(n,"labels","sigmoidCrossEntropyWithLogits"),s=w(e,"logits","sigmoidCrossEntropyWithLogits");Ce(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=rr(s),o=L(s,t),a=el(tn(bt(Ve(s))));return W(H(r,o),a)}function $S(n,e,t,s=0,r=ke.SUM_BY_NONZERO_WEIGHTS){let o=w(n,"multiClassLabels","sigmoidCrossEntropy");const a=w(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=w(t,"weights","sigmoidCrossEntropy")),Ce(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=K(s),l=K(1),d=K(.5);o=W(L(o,H(l,c)),L(d,c))}const u=wS(o,a);return Gt(u,i,r)}const vS=C({sigmoidCrossEntropy_:$S});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SS(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return kt((r,o,a)=>{const u=nl(o,[t],!0),c=H(ee(o,"float32"),u);a([r,c]);const l=bt(L(c,r));return{value:ue(l,[t]),gradFunc:(h,f)=>{const[g,m]=f,y=Ke(h.shape,[t]);return[L(_(h,y),H(ee(g,"float32"),tn(m))),L(_(h,y),H(tn(m),ee(g,"float32")))]}}})(n,e)}function CS(n,e,t,s=0,r=ke.SUM_BY_NONZERO_WEIGHTS){let o=w(n,"onehotLabels","softmaxCrossEntropy");const a=w(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=w(t,"weights","softmaxCrossEntropy")),Ce(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const c=K(s),l=K(1),d=K(o.shape[1]);o=W(L(o,H(l,c)),ae(c,d))}const u=SS(o,a);return Gt(u,i,r)}const TS=C({softmaxCrossEntropy_:CS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n,e,t,s){const r=w(n,"indices","sparseFillEmptyRows","int32"),o=w(e,"values","sparseFillEmptyRows"),a=w(t,"denseShape","sparseFillEmptyRows","int32"),i=w(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:r,values:o,denseShape:a,defaultValue:i},c=T.runKernel(uc,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const ES=C({sparseFillEmptyRows_:NS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IS(n,e,t){const s=w(n,"inputIndices","sparseReshape","int32"),r=w(e,"inputShape","sparseReshape","int32"),o=w(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:s,inputShape:r,newShape:o},i=T.runKernel(cc,a);return{outputIndices:i[0],outputShape:i[1]}}const kS=C({sparseReshape_:IS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RS(n,e,t){const s=w(n,"data","sparseSegmentMean"),r=w(e,"indices","sparseSegmentMean","int32"),o=w(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return T.runKernel(lc,a)}const _S=C({sparseSegmentMean_:RS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n,e,t){const s=w(n,"data","sparseSegmentSum"),r=w(e,"indices","sparseSegmentSum","int32"),o=w(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return T.runKernel(dc,a)}const OS=C({sparseSegmentSum_:AS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(n,e,t,s,r,o,a,i){const u=w(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=w(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const l={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:a,preserveShortSequences:i},d={data:u,dataSplits:c},p=T.runKernel(gc,d,l);return{nGrams:p[0],nGramsSplits:p[1]}}const PS=C({stringNGrams_:DS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n,e,t=!0){const s=w(n,"input","stringSplit","string"),r=w(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},a={input:s,delimiter:r},i=T.runKernel(yc,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const LS=C({stringSplit_:FS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(n,e){const t=w(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return T.runKernel(xc,r,s)}const VS=C({stringToHashBucketFast_:BS});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n,e,t,s=!0){const r=w(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return T.runKernel(fc,{x:r},o)}const WS=C({staticRegexReplace_:MS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Am={fft:go,ifft:Us,rfft:yo,irfft:xl},Om={hammingWindow:mv,hannWindow:Rm,frame:_m,stft:bv},In={flipLeftRight:Sv,grayscaleToRGB:Tv,resizeNearestNeighbor:Xv,resizeBilinear:Kv,rotateWithOffset:Ev,cropAndResize:$v,nonMaxSuppression:kv,nonMaxSuppressionAsync:Lv,nonMaxSuppressionWithScore:Vv,nonMaxSuppressionWithScoreAsync:Wv,nonMaxSuppressionPadded:zv,nonMaxSuppressionPaddedAsync:Hv,threshold:Zv,transform:eS},Dm={bandPart:nS,gramSchmidt:rS,qr:aS},Pm={absoluteDifference:cS,computeWeightedLoss:Gt,cosineDistance:dS,hingeLoss:hS,huberLoss:mS,logLoss:yS,meanSquaredError:bS,sigmoidCrossEntropy:vS,softmaxCrossEntropy:TS},Fm={sparseFillEmptyRows:ES,sparseReshape:kS,sparseSegmentMean:_S,sparseSegmentSum:OS},Lm={stringNGrams:PS,stringSplit:LS,stringToHashBucketFast:VS,staticRegexReplace:WS};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const US=new Map,ha=new Map;class Bm{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class qt{constructor(){this.classNameMap={}}static getMap(){return qt.instance==null&&(qt.instance=new qt),qt.instance}static register(e){qt.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Vm(n,e,t){v(n.className!=null,()=>"Class being registered does not have the static className property defined."),v(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),v(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return qt.register(n),US.set(r,n),ha.set(n,r),n}function zS(n){return ha.has(n)?ha.get(n):n.className}const GS=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Bm,SerializationMap:qt,getRegisteredName:zS,registerClass:Vm},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class un extends Bm{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return _e(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return bf(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:K(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(un,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rl extends un{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=T.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=T.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:U(()=>We(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:U(()=>We(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const u=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;U(()=>{const l=W(L(u,this.rho),L(it(i),1-this.rho)),d=L(ae(It(W(c,this.epsilon)),It(W(u,this.epsilon))),i),p=W(L(c,this.rho),L(it(d),1-this.rho));u.assign(l),c.assign(p);const h=W(L(d,-this.learningRate),o);o.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(e=>e.variable)),_e(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _l extends un{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=T.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:U(()=>as(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=this.accumulatedGrads[r].variable;U(()=>{const u=W(i,it(a));i.assign(u);const c=W(L(ae(a,It(W(u,T.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Al extends un{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],U(()=>{this.accBeta1=K(t).variable(),this.accBeta2=K(s).variable()}),r==null&&(this.epsilon=T.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=H(1,this.accBeta1),r=H(1,this.accBeta2);t.forEach((o,a)=>{const i=T.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:U(()=>We(i).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:U(()=>We(i).variable(u))});const c=Array.isArray(e)?e[a].tensor:e[o];if(c==null)return;const l=this.accumulatedFirstMoment[a].variable,d=this.accumulatedSecondMoment[a].variable,p=W(L(l,this.beta1),L(c,1-this.beta1)),h=W(L(d,this.beta2),L(it(c),1-this.beta2)),f=ae(p,s),g=ae(h,r);l.assign(p),d.assign(h);const m=W(L(ae(f,W(It(g),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(L(this.accBeta1,this.beta1)),this.accBeta2.assign(L(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),U(()=>{this.accBeta1.assign(Qn(this.beta1,this.iterations_+1)),this.accBeta2.assign(Qn(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ol extends un{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],U(()=>{this.iteration=K(0).variable(),this.accBeta1=K(t).variable()}),r==null&&(this.epsilon=T.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=H(1,this.accBeta1),r=ae(-this.learningRate,W(L(this.iteration,this.decay),1));t.forEach((o,a)=>{const i=T.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:We(i).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:We(i).variable(u)});const c=Array.isArray(e)?e[a].tensor:e[o];if(c==null)return;const l=this.accumulatedFirstMoment[a].variable,d=this.accumulatedWeightedInfNorm[a].variable,p=W(L(l,this.beta1),L(c,1-this.beta1)),h=L(d,this.beta2),f=Ve(c),g=al(h,f);l.assign(p),d.assign(g);const m=W(L(ae(r,s),ae(p,W(g,this.epsilon))),i);i.assign(m)}),this.iteration.assign(W(this.iteration,1)),this.accBeta1.assign(L(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Co extends un{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=T.registeredVariables[s];U(()=>{const i=W(L(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=xt(K(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dl extends Co{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=K(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=T.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:U(()=>We(o).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[s];i!=null&&U(()=>{let u;const c=W(L(this.m,a),i);this.useNesterov?u=W(L(this.c,W(i,L(c,this.m))),o):u=W(L(this.c,c),o),a.assign(c),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pl extends un{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=T.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=T.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:U(()=>We(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:U(()=>We(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:U(()=>We(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const u=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;U(()=>{const l=W(L(u,this.decay),L(it(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,p=W(L(d,this.decay),L(i,1-this.decay)),h=ae(L(i,this.learningRate),It(H(l,W(it(p),this.epsilon)))),f=W(L(c,this.momentum),h);u.assign(l),d.assign(p),c.assign(f);const g=H(o,f);o.assign(g)}else{const d=W(L(u,this.decay),L(it(i),1-this.decay)),p=W(L(c,this.momentum),ae(L(i,this.learningRate),It(W(d,this.epsilon))));u.assign(d),c.assign(p);const h=H(o,p);o.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HS=[Rl,_l,Al,Ol,Dl,Pl,Co];function jS(){for(const n of HS)Vm(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KS="model",qS=".json",XS=".weights.bin";function md(n){return new Promise(e=>setTimeout(e)).then(n)}class kn{constructor(e){if(!I().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(kn.URL_SCHEME)&&(e=e.slice(kn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=KS),this.modelJsonFileName=e+qS,this.weightDataFileName=e+XS}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=vt.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=ih(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=a,await md(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await md(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ys(e)}}}}kn.URL_SCHEME="downloads://";class YS{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),a=o.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const u=Lc(o,c=>this.loadWeights(c));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(o).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=a=>{const i=a.target.result;s(i)},o.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>pd(o.name)),r={};for(const o of e)o.paths.forEach(a=>{const i=pd(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const QS=n=>I().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(kn.URL_SCHEME)?ZS(n.slice(kn.URL_SCHEME.length)):null;de.registerSaveRouter(QS);function ZS(n="model"){return new kn(n)}function JS(n){return new YS(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gd(n,e,t,s){a(n),t=t??0,s=s??1,i(t,s);let r=0;const o=u=>(u.then(c=>{const l=t+ ++r/n.length*(s-t);return e(l),c}),u);function a(u){v(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){v(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),v(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),v(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Mm(n,e){e==null&&(e={});const t=e.fetchFunc==null?I().platform.fetch:e.fetchFunc,s=n.map(d=>t(d,e.requestInit,{isBinary:!0})),r=0,o=.5,i=(e.onProgress==null?await Promise.all(s):await gd(s,e.onProgress,r,o)).map(d=>d.arrayBuffer()),u=.5,c=1;return e.onProgress==null?await Promise.all(i):await gd(i,e.onProgress,u,c)}async function eC(n,e="",t,s){return Wm(a=>Mm(a,{requestInit:s}))(n,e,t)}function Wm(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],i=[];if(e.forEach((h,f)=>{let g=0;h.weights.forEach(m=>{const y="quantization"in m?m.quantization.dtype:m.dtype,b=ia[y]*P(m.shape),$=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:m,groupOffset:g,sizeBytes:b})};s!=null?s.forEach((S,N)=>{S===m.name&&($(),a[N]=!0)}):$(),i.push(m.name),g+=b})}),!a.every(h=>h)){const h=s.filter((f,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=r.reduce((h,f,g)=>(f&&h.push(g),h),[]),c=[];u.forEach(h=>{e[h].paths.forEach(f=>{const g=t+(t.endsWith("/")?"":"/")+f;c.push(g)})});const l=await n(c),d={};let p=0;return u.forEach(h=>{const f=e[h].paths.length,g=new vt(l.slice(p,p+f));o[h].forEach(y=>{const b=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),$=ah(b,[y.manifestEntry]);for(const S in $)d[S]=$[S]}),p+=f}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tC="application/octet-stream",nC="application/json";class Fl{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(v(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=I().platform.fetch,v(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&v(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=ih(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:nC}),"model.json"),e.weightData!=null){const a=vt.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:tC}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Ys(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Lc(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=sC(t),o=this.weightPathPrefix||s,a=ch(e),i=[],u=[];for(const l of e)for(const d of l.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(d)):i.push(o+d+r);this.weightUrlConverter&&i.push(...await Promise.all(u));const c=await Mm(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,c]}}Fl.URL_SCHEME_REGEX=/^https?:\/\//;function sC(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function fa(n){return n.match(Fl.URL_SCHEME_REGEX)!=null}const Um=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>fa(s)):t=fa(n),t)return Ll(n,e)}return null};de.registerSaveRouter(Um);de.registerLoadRouter(Um);function Ll(n,e){return new Fl(n,e)}function rC(n,e){return Ll(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vo{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class zm{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class oC{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function aC(n,e,t,s){const r=arguments;return new oC(Gm(...r))}function Gm(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Vo(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Vo({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Vo({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function iC(n){return new zm(n)}function uC(n){return new zm(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:vt,browserFiles:JS,browserHTTPRequest:rC,concatenateArrayBuffers:mb,copyModel:Lb,decodeWeights:ah,encodeWeights:db,fromMemory:aC,fromMemorySync:Gm,getLoadHandlers:Sb,getModelArtifactsForJSON:Lc,getModelArtifactsForJSONSync:uh,getModelArtifactsInfoForJSON:Ys,getSaveHandlers:vb,getWeightSpecs:ch,http:Ll,isHTTPScheme:fa,listModels:Pb,loadWeights:eC,moveModel:Bb,registerLoadRouter:$b,registerSaveRouter:wb,removeModel:Fb,weightsLoaderFactory:Wm,withSaveHandler:iC,withSaveHandlerSync:uC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(n,e,t){const s=w(n,"labels","confusionMatrix"),r=w(e,"predictions","confusionMatrix");v(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),v(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),v(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),v(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),v(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const o=Ws(ee(s,"int32"),t),a=Ws(ee(r,"int32"),t),i=zs(o),u=Z(i,a);return ee(u,"int32")}const lC=C({confusionMatrix_:cC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dC=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:lC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dn,yd=!1;function Hm(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,a=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(_s(Br,T.backendName)!=null){const f={pixels:n},g={numChannels:e};return T.runKernel(Br,f,g)}const[c,l]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d;if(a)d=n.getContext("2d").getImageData(0,0,c,l).data;else if(s||t)d=n.data;else if(o||r||i){if(dn==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")dn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else dn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});dn.canvas.width=c,dn.canvas.height=l,dn.drawImage(n,0,0,c,l),d=dn.getImageData(0,0,c,l).data}let p;if(e===4)p=new Int32Array(d);else{const f=c*l;p=new Int32Array(f*e);for(let g=0;g<f;g++)for(let m=0;m<e;++m)p[g*e+m]=d[g*4+m]}return $l(p,[l,c,e],"int32")}function pC(n){return n!=null&&n.data instanceof Uint8Array}function hC(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function fC(n){return n!=null&&n.width!==0&&n.height!==0}function mC(n){return hC()&&!(n instanceof ImageBitmap)&&fC(n)&&!pC(n)}async function gC(n,e=3){let t=null;if(I().getBool("WRAP_TO_IMAGEBITMAP")&&mC(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return Hm(t,e)}function jm(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function yC(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function To(n,e){let t=w(n,"img","toPixels");if(!(n instanceof te)){const c=t;t=ee(c,"int32"),c.dispose()}jm(t);const[s,r]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],a=await t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let c=0;c<s*r;++c){const l=[0,0,0,255];for(let p=0;p<o;p++){const h=a[c*o+p];if(t.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(t.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);o===1?(l[0]=h*i,l[1]=h*i,l[2]=h*i):l[p]=h*i}const d=c*4;u[d+0]=Math.round(l[0]),u[d+1]=Math.round(l[1]),u[d+2]=Math.round(l[2]),u[d+3]=Math.round(l[3])}if(e!=null){yd||_s(Ii,T.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),yd=!0),e.width=r,e.height=s;const c=e.getContext("2d"),l=new ImageData(u,r,s);c.putImageData(l,0,0)}return t!==n&&t.dispose(),u}function xC(n,e,t){let s=w(n,"img","draw");if(!(n instanceof te)){const a=s;s=ee(a,"int32"),a.dispose()}jm(s),yC(t==null?void 0:t.imageOptions);const r={image:s},o={canvas:e,options:t};T.runKernel(Ii,r,o)}const No=C({fromPixels_:Hm}),bC=Object.freeze(Object.defineProperty({__proto__:null,draw:xC,fromPixels:No,fromPixelsAsync:gC,toPixels:To},Symbol.toStringTag,{value:"Module"}));function Vl(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(P(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let a=1;for(let d=0;d<r.length-1;++d)a*=r[d];const i=n.shape,u=r.slice();u.pop();let c=1;for(let d=o;d<t;++d)c*=i[d],u.push(i[d]);const l=[...xe(n.shape).map(d=>d/c),1].slice(0,o);return[u,a,c,l]}const wC=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Vl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ma=-2,$C=-1;function Km(n,e,t){const s=n.shape.length;v(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),v(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)v(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function vC(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function qm(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function Xm(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Ym(n,e,t){return t<=n?t:t-(e-1)}function Qm(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function SC(n,e,t,s,r,o,a,i,u){const c=n.length;let l=new Array(c),d=new Array(c),p=new Array(c);if(e.length&&t>0){const h=e[0],f=t+1;l=Zm(a,h,f,s,n),d=Jm(i,h,f,r,n),p=Xm(o,h,f,n)}else for(let h=0;h<c;h++)l[h]=tg(a,s,o,n,h,u),d[h]=ng(i,r,o,n,h,u),p[h]=eg(o,h,u);return{begin:l,end:d,strides:p}}function Zm(n,e,t,s,r){const o=[...r],a=Qm(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const u=Ym(e,t,i);let c=s[u];n&1<<u&&(c=0),o[i]=c}return o}function Jm(n,e,t,s,r){const o=[...r],a=Qm(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const u=Ym(e,t,i);let c=s[u];n&1<<u&&(c=Number.MAX_SAFE_INTEGER),o[i]=c}for(let i=0;i<o.length;i++){const u=r[i];o[i]<0&&(o[i]+=u),o[i]=Is(0,o[i],r[i])}return o}function eg(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function tg(n,e,t,s,r,o){let a=e[r];const i=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),a=Is(0,a,u-1),a}function ng(n,e,t,s,r,o){let a=e[r];const i=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),i>0?a=Is(0,a,u):a=Is(-1,a,u-1),a}function Ml(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Wl(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function sg(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{v(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((a,i)=>a>=0?a:(v(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),n.shape[i]-s[i])),[s,o]}function rg(n,e,t,s,r,o,a,i,u){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};for(let $=0;$<d.dims;$++)l&&1<<$&i&&d.numAddAxisAfterEllipsis++,1<<$&a&&(l=!0);l||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};CC(d,p);let h=!0,f=!0,g=!0;const m=[],y=[];for(let $=0;$<n.length;++$){if(p.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const S=!!(p.shrinkAxisMask&1<<$),N=n[$];if(N===-1){m.push(S?1:-1);continue}const E=[p.beginMask&1<<$,p.endMask&1<<$],k=[p.strides[$]>0?0:-1,p.strides[$]>0?N:N-1];if(S&&p.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[$]===1;const R=!!(p.beginMask&1<<$&&p.endMask&1<<$);if(p.beginValid&&p.endValid){if(S){const V=p.begin[$]<0?N+p.begin[$]:p.begin[$];if(p.begin[$]=V,p.end[$]=p.begin[$]+1,V<0||V>=N)throw Error(`slice index ${p.begin[$]} of dimension ${$} out of bounds.`)}else p.begin[$]=xd(p.begin[$],0,p.strides[$],N,E,k),p.end[$]=xd(p.end[$],1,p.strides[$],N,E,k);const D=p.strides[$]===1&&p.begin[$]===0&&p.end[$]===N;h=h&&D,f=f&&($===0&&p.strides[$]===1||D)}else h=h&&p.strides[$]===1&&R,f=f&&($===0&&p.strides[$]===1||R);let A,O=!1;if(p.beginValid&&p.endValid?(A=p.end[$]-p.begin[$],O=!0):S?(A=1,O=!0):R&&N>=0&&(p.strides[$]<0?A=-N:A=N,O=!0),O){let D;A===0||A<0!=p.strides[$]<0?D=0:D=Math.trunc(A/p.strides[$])+(A%p.strides[$]!==0?1:0),m.push(D)}else m.push(-1)}for(let $=0;$<p.finalShapeGatherIndices.length;++$){const S=p.finalShapeGatherIndices[$];S>=0?y.push(m[S]):S===ma&&y.push(1)}return{finalShapeSparse:y.filter(($,S)=>p.finalShapeGatherIndices[S]!==ma),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function CC(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(ma),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push($C),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function xd(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const a=n<0?s+n:n;return a<o[0]?o[0]:a>o[1]?o[1]:a}}const og=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Km,computeFlatOffset:Wl,computeOutShape:qm,getNormalizedAxes:SC,isSliceContinous:Ml,maskToAxes:vC,parseSliceParams:sg,sliceInfo:rg,startForAxis:tg,startIndicesWithElidedDims:Zm,stopForAxis:ng,stopIndicesWithElidedDims:Jm,stridesForAxis:eg,stridesWithElidedDims:Xm},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const TC="4.8.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ag{static sgd(e){return new Co(e)}static momentum(e,t,s=!1){return new Dl(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,o=!1){return new Pl(e,t,s,r,o)}static adam(e=.001,t=.9,s=.999,r=null){return new Al(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new Rl(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,o=0){return new Ol(e,t,s,r,o)}static adagrad(e,t=.1){return new _l(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NC=ag;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EC=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function ig(){return new Promise(n=>EC(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ug(n,e){const t=n[0].length;n.forEach((r,o)=>{v(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),v(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let a=0;a<t;a++)v(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Rn(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gt;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(gt||(gt={}));function cg(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],a=s[s.length-t.length+r],i=s[a];if(o>=0)if(i>=0){if(i!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${i}`)}else s[a]=o}return s}function lg(n){const e={FIRST_DIM_SIZE:gt.FIRST_DIM_SIZE,VALUE_ROWIDS:gt.VALUE_ROWIDS,ROW_LENGTHS:gt.ROW_LENGTHS,ROW_SPLITS:gt.ROW_SPLITS,ROW_LIMITS:gt.ROW_LIMITS,ROW_STARTS:gt.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function dg(n){return n.length===0?0:n[0]===gt.FIRST_DIM_SIZE?n.length-1:n.length}function pg(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],a=e[r+1];if(o>=0&&a>=0&&o!==1&&o!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul=30;function Eo(n){return n<=Ul?n:Fr(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hg(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zl(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let a=0;a<o;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(o+1))}return r}function Gl(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function Hl(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function fg(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function mg(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gg=1.7580993408473768,yg=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xg=.3275911,bg=.254829592,wg=-.284496736,$g=1.421413741,vg=-1.453152027,Sg=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function IC(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function kC(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function RC(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function _C(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function AC(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function OC(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function DC(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mo="->",PC=/->/g,bd=",",wd="...";function Cg(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(PC,"").length)/Mo.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Mo}").`);const[s,r]=n.split(Mo);v(s.indexOf(wd)===-1,()=>`The ellipsis notation ("${wd}") is not supported yet.`);const o=s.split(bd),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<r.length;++p){const h=r[p];if(!o.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let p=0;p<s.length;++p){const h=s[p];i.indexOf(h)===-1&&h!==bd&&i.push(h)}const u=new Array(o.length);for(let p=0;p<a;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let h=0;h<o[p].length;++h)u[p].push(i.indexOf(o[p][h]))}const c=i.length,l=r.length,d=[];for(let p=l;p<c;++p)d.push(p);return{allDims:i,summedDims:d,idDims:u}}function Tg(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Ng(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=o[a]:v(s[e[r][a]]===o[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function Eg(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const o=[];for(let a=0;a<t.length;++a){const i=t[a],u=FC(e,i);for(const c of u)o.indexOf(c)===-1&&(s[a].push(c),o.push(c))}return{path:t,steps:s}}function Ig(n){return n.every((e,t)=>e===t)}function FC(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function kg(n,e,t=0){let s=[];if(typeof e=="number")v(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);v(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,u)=>u>0?i+u:i);e[o]=n.shape[t]-a}v(n.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rg(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function _g(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Ag(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Og(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Dg(n,e){return`size ${n} must be non-negative, not ${e}`}function Pg(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Fg(n,e){const t=P(n),s=P(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Lg(n,e){const t=P(n),s=P(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(){return"segment ids must be >= 0"}function Bg(){return"segment ids are not increasing"}function Vg(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Mg(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wg(n,e){let t=!1,s;for(n<=Ul?(s=n,t=!0):s=Fr(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=Fr(n,s+1);return s}function Ug(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function zg(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const a=n.shape[t],i=[];let u=1,c=1,l=1;for(let d=0;d<s;++d)i.push(n.shape[d]),u*=n.shape[d];for(let d=s;d<t;d++)i.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<r;d++)i.push(e.shape[d]);for(let d=t+1;d<o;d++)i.push(n.shape[d]),l*=n.shape[d];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:a,outputShape:i}}const LC=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:zg,computeOutShape:Ug,segOpComputeOptimalWindowSize:Wg},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(n){try{return n.map(e=>Sn(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Gg(n){return n.map(e=>Lt(e))}const Hg=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:bg,ERF_A2:wg,ERF_A3:$g,ERF_A4:vg,ERF_A5:Sg,ERF_P:xg,PARALLELIZE_THRESHOLD:Ul,get RowPartitionType(){return gt},SELU_SCALE:yg,SELU_SCALEALPHA:gg,applyActivation:vo,assertAndGetBroadcastShape:X,assertAxesAreInnerMostDims:St,assertParamsConsistent:ug,assignToTypedArray:AC,axesAreInnerMostDims:Kc,calculateShapes:or,checkEinsumDimSizes:Ng,checkPadOnDimRoundingMode:ut,combineLocations:lf,combineRaggedTensorToTensorShapes:cg,complexWithEvenIndex:kC,complexWithOddIndex:RC,computeConv2DInfo:je,computeConv3DInfo:Zs,computeDefaultPad:Wc,computeDilation2DInfo:_h,computeOptimalWindowSize:Eo,computeOutAndReduceShapes:_t,computeOutShape:Rn,computePool2DInfo:Pn,computePool3DInfo:Qs,convertConv2DDataFormat:os,decodeEinsumEquation:Cg,eitherStridesOrDilationsAreOne:Ge,expandShapeToKeepDim:Ke,exponent:DC,exponents:OC,fromStringArrayToUint8:Gg,fromUint8ToStringArray:ts,getAxesPermutation:ct,getBroadcastDims:Ls,getComplexWithIndex:_C,getEinsumComputePath:Eg,getEinsumPermutation:Tg,getFusedBiasGradient:$o,getFusedDyActivation:wo,getImageCenter:hg,getInnerMostAxes:lt,getPermuted:Gl,getRaggedRank:dg,getReductionAxes:Hc,getReshaped:zl,getReshapedPermuted:Hl,getRowPartitionTypesHelper:lg,getSliceBeginCoords:fg,getSliceSize:mg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Rg,getSparseFillEmptyRowsNegativeIndexErrorMessage:_g,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Ag,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Pg,getSparseReshapeInputOutputMismatchErrorMessage:Lg,getSparseReshapeInputOutputMultipleErrorMessage:Fg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Og,getSparseReshapeNegativeOutputDimErrorMessage:Dg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Mg,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ya,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Bg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Vg,getUndoAxesPermutation:qc,isIdentityPermutation:Ig,log:Ax,mergeRealAndImagArrays:ga,prepareAndValidate:Vl,prepareSplitSize:kg,segment_util:LC,shouldFuse:So,slice_util:og,splitRealAndImagArrays:IC,stridesOrDilationsArePositive:En,tupleValuesAreOne:Fs,upcastType:wt,validateDefaultValueShape:pg,validateInput:xo,validateUpdateShape:vl,warn:nt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BC=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Nl,nonMaxSuppressionV4Impl:El,nonMaxSuppressionV5Impl:Il,whereImpl:Sl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jS();const jg=Object.freeze(Object.defineProperty({__proto__:null,Abs:Ma,Acos:Wa,Acosh:Ua,AdadeltaOptimizer:Rl,AdagradOptimizer:_l,AdamOptimizer:Al,AdamaxOptimizer:Ol,Add:oo,AddN:za,All:Ga,Any:Ha,ArgMax:ja,ArgMin:Ka,Asin:qa,Asinh:Xa,Atan:Ya,Atan2:Za,Atanh:Qa,AvgPool:Ja,AvgPool3D:ei,AvgPool3DGrad:Mp,AvgPoolGrad:Vp,BatchMatMul:ti,BatchToSpaceND:ni,Bincount:si,BitwiseAnd:ri,BroadcastArgs:oi,BroadcastTo:Sx,Cast:ao,Ceil:ai,ClipByValue:ii,Complex:ui,ComplexAbs:ci,Concat:li,Conv2D:di,Conv2DBackpropFilter:pi,Conv2DBackpropInput:hi,Conv3D:fi,Conv3DBackpropFilterV2:Wp,Conv3DBackpropInputV2:mi,Cos:gi,Cosh:yi,CropAndResize:wi,Cumprod:xi,Cumsum:bi,DataStorage:Tp,DenseBincount:$i,DepthToSpace:vi,DepthwiseConv2dNative:Si,DepthwiseConv2dNativeBackpropFilter:Ci,DepthwiseConv2dNativeBackpropInput:Ti,Diag:Ni,Dilation2D:Ei,Dilation2DBackpropFilter:Tx,Dilation2DBackpropInput:Cx,Draw:Ii,get ENV(){return Ba},Einsum:Ri,Elu:_i,EluGrad:Up,Environment:Lp,Equal:Oi,Erf:Ai,Exp:Di,ExpandDims:Pi,Expm1:Fi,FFT:Li,Fill:Bi,FlipLeftRight:Vi,Floor:Mi,FloorDiv:Wi,FromPixels:Br,FusedBatchNorm:Ui,FusedConv2D:Mr,FusedDepthwiseConv2D:Wr,GatherNd:Gi,GatherV2:zi,Greater:Hi,GreaterEqual:ji,IFFT:Ki,Identity:io,Imag:qi,IsFinite:Xi,IsInf:Yi,IsNan:Qi,KernelBackend:Fa,LRN:iu,LRNGrad:zp,LeakyRelu:Zi,Less:Ji,LessEqual:eu,LinSpace:tu,Log:nu,Log1p:su,LogSoftmax:Ex,LogicalAnd:ru,LogicalNot:ou,LogicalOr:au,LogicalXor:Nx,LowerBound:Ix,MatrixBandPart:kx,Max:uu,MaxPool:lu,MaxPool3D:du,MaxPool3DGrad:Hp,MaxPoolGrad:Gp,MaxPoolWithArgmax:pu,Maximum:cu,Mean:hu,Min:fu,Minimum:mu,MirrorPad:gu,Mod:yu,MomentumOptimizer:Dl,Multinomial:xu,Multiply:bu,Neg:wu,NonMaxSuppressionV3:vu,NonMaxSuppressionV4:Su,NonMaxSuppressionV5:Cu,NotEqual:$u,OP_SCOPE_SUFFIX:Pc,OneHot:Nu,OnesLike:Tu,Optimizer:un,OptimizerConstructors:ag,Pack:Eu,PadV2:Iu,Pool:Rx,Pow:ku,Prelu:Ru,Prod:_u,RMSPropOptimizer:Pl,RaggedGather:Au,RaggedRange:Ou,RaggedTensorToTensor:Du,Range:Pu,get Rank(){return ta},Real:Fu,RealDiv:ki,Reciprocal:Lu,get Reduction(){return ke},Relu:Bu,Relu6:Uu,Reshape:Vu,ResizeBilinear:Wu,ResizeBilinearGrad:Kp,ResizeNearestNeighbor:Mu,ResizeNearestNeighborGrad:jp,Reverse:zu,RotateWithOffset:kc,Round:Gu,Rsqrt:Hu,SGDOptimizer:Co,ScatterNd:ju,SearchSorted:qu,Select:Xu,Selu:Yu,Sigmoid:tc,Sign:ec,Sin:Zu,Sinh:Ju,Slice:Qu,Softmax:ic,Softplus:nc,SpaceToBatchND:oc,SparseFillEmptyRows:uc,SparseReshape:cc,SparseSegmentMean:lc,SparseSegmentSum:dc,SparseToDense:pc,SplitV:ac,Sqrt:sc,Square:qp,SquaredDifference:hc,StaticRegexReplace:fc,Step:Ic,StridedSlice:mc,StringNGrams:gc,StringSplit:yc,StringToHashBucketFast:xc,Sub:bc,Sum:rc,Tan:wc,Tanh:$c,Tensor:te,TensorBuffer:Cn,TensorScatterUpdate:Ku,Tile:uo,TopK:vc,Transform:Sc,Transpose:Es,Unique:Cc,Unpack:Tc,UnsortedSegmentSum:Nc,UpperBound:_x,Variable:As,ZerosLike:Ec,_FusedMatMul:Vr,abs:Ve,acos:wh,acosh:$h,add:W,addN:vh,all:Sh,any:Ch,argMax:Mc,argMin:Th,asin:Nh,asinh:Eh,atan:Ih,atan2:kh,atanh:Rh,avgPool:Uc,avgPool3d:Ah,backend:bh,backend_util:Hg,basicLSTMCell:Oh,batchNorm:Js,batchNorm2d:Dh,batchNorm3d:Ph,batchNorm4d:Fh,batchToSpaceND:zc,bincount:Gc,bitwiseAnd:Lh,booleanMaskAsync:vm,broadcastArgs:Bh,broadcastTo:Kn,broadcast_util:fw,browser:bC,buffer:le,cast:ee,ceil:Vh,clipByValue:Mh,clone:Bt,complex:Ut,concat:Se,concat1d:Wh,concat2d:Uh,concat3d:zh,concat4d:Gh,conv1d:Hh,conv2d:er,conv2dTranspose:Kh,conv3d:qh,conv3dTranspose:Xh,copyRegisteredKernels:Fx,cos:Yh,cosh:Qh,cosineWindow:bo,cumprod:Zh,cumsum:Jh,customGrad:kt,denseBincount:ef,deprecationWarn:qb,depthToSpace:tf,depthwiseConv2d:lo,device_util:ub,diag:nf,dilation2d:sf,disableDeprecationWarnings:Kb,dispose:_e,disposeVariables:Xb,div:ae,divNoNan:rf,dot:of,dropout:Em,einsum:af,elu:jc,enableDebugMode:jb,enableProdMode:Hb,enclosingPowerOfTwo:Tl,engine:ft,ensureShape:uf,env:I,equal:tr,erf:cf,euclideanNorm:pf,exp:tn,expandDims:Me,expm1:hf,eye:Xc,fft:go,fill:as,findBackend:n0,findBackendFactory:s0,floor:Yc,floorDiv:Vc,fused:km,gather:Qc,gatherND:Nm,gather_util:wC,getBackend:yh,getGradient:Jo,getKernel:_s,getKernelsForBackend:Ur,grad:Qw,grads:Zw,greater:is,greaterEqual:Zc,ifft:Us,imag:sr,image:In,inTopKAsync:Im,io:Bl,irfft:xl,isFinite:ff,isInf:mf,isNaN:gf,keep:xt,kernel_impls:BC,leakyRelu:Jc,less:jr,lessEqual:po,linalg:Dm,linspace:yf,localResponseNormalization:xf,log:Zn,log1p:el,logSigmoid:wf,logSoftmax:$f,logSumExp:nl,logicalAnd:Bs,logicalNot:sl,logicalOr:rl,logicalXor:vf,losses:Pm,lowerBound:Sf,matMul:Z,math:dC,max:wn,maxPool:ol,maxPool3d:Cf,maxPoolWithArgmax:Tf,maximum:al,mean:Vs,memory:Yb,meshgrid:Nf,min:Hr,minimum:Ms,mirrorPad:il,mod:Ef,moments:If,movingAverage:Sm,mul:L,multiRNNCell:kf,multinomial:Rf,neg:bt,nextFrame:ig,norm:nr,notEqual:ul,oneHot:Ws,ones:Yt,onesLike:_f,op:C,outerProduct:Af,pad:Fn,pad1d:Of,pad2d:Df,pad3d:cl,pad4d:Pf,pool:Ff,pow:Qn,prelu:dl,print:Bc,prod:Lf,profile:Qb,raggedGather:Bf,raggedRange:Vf,raggedTensorToTensor:Mf,rand:Wf,randomGamma:Gf,randomNormal:ml,randomStandardNormal:Hf,randomUniform:mo,randomUniformInt:jf,range:sn,ready:e0,real:Jn,reciprocal:Kf,registerBackend:xh,registerGradient:Ox,registerKernel:Rc,relu:rr,relu6:gl,removeBackend:t0,reshape:_,reverse:rn,reverse1d:qf,reverse2d:Xf,reverse3d:Yf,reverse4d:Qf,rfft:yo,round:yl,rsqrt:Zf,scalar:K,scatterND:Cm,scatter_util:B$,searchSorted:fo,selu:Jf,separableConv2d:em,serialization:GS,setBackend:Jb,setPlatform:r0,setdiff1dAsync:tm,sigmoid:Tt,sign:nm,signal:Om,sin:sm,sinh:rm,slice:re,slice1d:om,slice2d:am,slice3d:im,slice4d:um,slice_util:og,softmax:cm,softplus:tl,spaceToBatchND:ll,sparse:Fm,sparseToDense:Tm,spectral:Am,split:es,sqrt:It,square:it,squaredDifference:bl,squeeze:st,stack:Rt,step:wl,stridedSlice:lm,string:Lm,sub:H,sum:ue,sumOutType:co,tan:dm,tanh:Gr,tensor:at,tensor1d:rt,tensor2d:$n,tensor3d:$l,tensor4d:pm,tensor5d:hm,tensor6d:fm,tensorScatterUpdate:mm,tensor_util:sb,test_util:Q1,tidy:U,tile:qn,time:Zb,topk:gm,train:NC,transpose:zs,truncatedNormal:ym,unique:xm,unregisterGradient:Px,unregisterKernel:Dx,unsortedSegmentSum:bm,unstack:an,upcastType:wt,upperBound:wm,util:zx,valueAndGrad:Jw,valueAndGrads:e1,variable:$m,variableGrads:bf,version_core:TC,where:Vt,whereAsync:Cl,zeros:nn,zerosLike:We},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VC=I();VC.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Je;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Je||(Je={}));var $d;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})($d||($d={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MC={};function Kg(n){return MC[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const i=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd,c=i<0?e.inputNames.length+i:i;if(o.type==="tensor")return be(e.inputNames[c],t,s,r);if(o.type==="tensors"){const p=e.inputs.slice(i,u);return e.inputNames.slice(i,u).filter((f,g)=>{var m;return((m=p[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(f=>be(f,t,s,r))}const l=be(e.inputNames[c],t,s,r),d=l.dataSync();return o.type==="number"?d[0]:bn(l.shape,d)}const a=e.attrParams[n];return a&&a.value}function be(n,e,t,s){const[r,o]=Be(n,t);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const a=t.currentContextIds.find(i=>!!e[Kr(r,i)]);return a!==void 0?e[Kr(r,a)][o]:void 0}function vd(n,e,t){return e[Kr(n,t.currentContextId)]}function At(n,e){const[t,s,r]=Be(n,e);return[Kr(t,e&&e.currentContextId),s,r]}function Kr(n,e){return e?`${n}-${e}`:n}function Be(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],a=s.length===3?s[1]:void 0,i=Number(s[s.length-1]);r=[o,i,a]}return t&&e.parseNodeNameCache.set(n,r),r}function Or(n,e,t){let s=x("pad",n,e,t);if(s==="explicit"){s=x("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function Ot(n){return n.kept?n:Bt(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WC=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UC=Object.freeze(Object.defineProperty({__proto__:null,json:WC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zC=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],GC=Object.freeze(Object.defineProperty({__proto__:null,json:zC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HC=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],jC=Object.freeze(Object.defineProperty({__proto__:null,json:HC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KC=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],qC=Object.freeze(Object.defineProperty({__proto__:null,json:KC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XC=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],YC=Object.freeze(Object.defineProperty({__proto__:null,json:XC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QC=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZC=Object.freeze(Object.defineProperty({__proto__:null,json:QC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JC=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],eT=Object.freeze(Object.defineProperty({__proto__:null,json:JC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],nT=Object.freeze(Object.defineProperty({__proto__:null,json:tT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],rT=Object.freeze(Object.defineProperty({__proto__:null,json:sT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],aT=Object.freeze(Object.defineProperty({__proto__:null,json:oT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iT=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],uT=Object.freeze(Object.defineProperty({__proto__:null,json:iT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cT=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],lT=Object.freeze(Object.defineProperty({__proto__:null,json:cT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],pT=Object.freeze(Object.defineProperty({__proto__:null,json:dT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],fT=Object.freeze(Object.defineProperty({__proto__:null,json:hT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mT=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gT=Object.freeze(Object.defineProperty({__proto__:null,json:mT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yT=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],xT=Object.freeze(Object.defineProperty({__proto__:null,json:yT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],wT=Object.freeze(Object.defineProperty({__proto__:null,json:bT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $T=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],vT=Object.freeze(Object.defineProperty({__proto__:null,json:$T},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ST=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],CT=Object.freeze(Object.defineProperty({__proto__:null,json:ST},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sd{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[UC,GC,jC,qC,YC,ZC,eT,nT,rT,aT,uT,lT,pT,fT,gT,xT,wT,vT,CT],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],a=[],i=s.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(g[m.name]):m.op==="Const"?o.push(g[m.name]):(m.input==null||m.input.length===0)&&a.push(g[m.name]),g),{});let u=[];const c=[];let l={},d={};t!=null&&(l=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const p=Object.keys(i);p.forEach(g=>{const m=i[g];m.inputNames.forEach((y,b)=>{const[$,,S]=At(y),N=i[$];if(N.outputs!=null){const E=N.outputs.indexOf(S);if(E!==-1){const k=`${$}:${E}`;m.inputNames[b]=k}}m.inputs.push(N),N.children.push(m)})}),Object.keys(d).length===0?p.forEach(g=>{const m=i[g];m.children.length===0&&c.push(m)}):Object.keys(d).forEach(g=>{const[m]=At(g),y=i[m];y!=null&&(y.signatureKey=d[g],c.push(y))}),Object.keys(l).length>0?Object.keys(l).forEach(g=>{const[m]=At(g),y=i[m];y&&(y.signatureKey=l[g],u.push(y))}):u=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));const f={nodes:i,inputs:u,outputs:c,weights:o,placeholders:r,signature:t,functions:h};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Kg(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const a=o.type;let i;switch(o.type){case"string":i=xa(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=xa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=Ta(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Ta(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=wa(e.attr,o.tfName,o.defaultValue||0),i===void 0&&o.tfDeprecatedName&&(i=wa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=Ca(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Ca(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=ba(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=ba(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=Ea(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Ea(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=Sa(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Sa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=Na(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Na(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=$a(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=$a(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=va(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=va(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=Cd(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Cd(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:i,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((d,p)=>(d[p.name]=this.mapNode(p),p.op==="Const"&&r.push(d[p.name]),d),{}));const a=[],i=[];e.signature.inputArg.forEach(d=>{const[p]=At(d.name),h={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:jl(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,a.push(h),o[p]=h}),Object.keys(o).forEach(d=>{const p=o[d];p.inputNames.forEach((h,f)=>{const[g,,m]=At(h),y=o[g];if(y.outputs!=null){const b=y.outputs.indexOf(m);if(b!==-1){const $=`${g}:${b}`;p.inputNames[f]=$}}p.inputs.push(y),y.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(d=>{const[p,h]=At(c[d.name]),f=o[p];f!=null&&(f.defaultOutput=h,i.push(f))});const l=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:i,weights:r,placeholders:s,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function TT(n){const e=I().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function qg(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):TT(n);return e?t:t.toLowerCase()}function xa(n,e,t,s=!1){const r=n[e];return r!=null?qg(r.s,s):t}function ba(n,e,t){const s=n[e];return s?s.b:t}function wa(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function jl(n){switch(typeof n=="string"&&(n=Je[n]),n){case Je.DT_FLOAT:case Je.DT_HALF:return"float32";case Je.DT_INT32:case Je.DT_INT64:case Je.DT_INT8:case Je.DT_UINT8:return"int32";case Je.DT_BOOL:return"bool";case Je.DT_DOUBLE:return"float32";case Je.DT_STRING:return"string";default:return null}}function Cd(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function $a(n,e,t){const s=n[e];return s&&s.type?jl(s.type):t}function va(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>jl(r)):t}function Xg(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Sa(n,e,t){const s=n[e];return s&&s.shape?Xg(s.shape):t}function Ca(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Ta(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>qg(o,s)):t}function Na(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>Xg(r)):t}function Ea(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NT{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return be(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return be(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return wa(this.node.rawAttrs,e,t);if(s.s!=null)return xa(this.node.rawAttrs,e,t);if(s.b!=null)return ba(this.node.rawAttrs,e,t);if(s.shape!=null)return Sa(this.node.rawAttrs,e,t);if(s.type!=null)return $a(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Ca(this.node.rawAttrs,e,t);if(s.list.s!=null)return Ta(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Na(this.node.rawAttrs,e,t);if(s.list.b!=null)return Ea(this.node.rawAttrs,e,t);if(s.list.type!=null)return va(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $e=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Pc,abs:Ve,acos:wh,acosh:$h,add:W,addN:vh,all:Sh,any:Ch,argMax:Mc,argMin:Th,asin:Nh,asinh:Eh,atan:Ih,atan2:kh,atanh:Rh,avgPool:Uc,avgPool3d:Ah,basicLSTMCell:Oh,batchNorm:Js,batchNorm2d:Dh,batchNorm3d:Ph,batchNorm4d:Fh,batchToSpaceND:zc,bincount:Gc,bitwiseAnd:Lh,booleanMaskAsync:vm,broadcastArgs:Bh,broadcastTo:Kn,buffer:le,cast:ee,ceil:Vh,clipByValue:Mh,clone:Bt,complex:Ut,concat:Se,concat1d:Wh,concat2d:Uh,concat3d:zh,concat4d:Gh,conv1d:Hh,conv2d:er,conv2dTranspose:Kh,conv3d:qh,conv3dTranspose:Xh,cos:Yh,cosh:Qh,cosineWindow:bo,cumprod:Zh,cumsum:Jh,denseBincount:ef,depthToSpace:tf,depthwiseConv2d:lo,diag:nf,dilation2d:sf,div:ae,divNoNan:rf,dot:of,dropout:Em,einsum:af,elu:jc,enclosingPowerOfTwo:Tl,ensureShape:uf,equal:tr,erf:cf,euclideanNorm:pf,exp:tn,expandDims:Me,expm1:hf,eye:Xc,fft:go,fill:as,floor:Yc,floorDiv:Vc,fused:km,gather:Qc,gatherND:Nm,greater:is,greaterEqual:Zc,ifft:Us,imag:sr,image:In,inTopKAsync:Im,irfft:xl,isFinite:ff,isInf:mf,isNaN:gf,leakyRelu:Jc,less:jr,lessEqual:po,linalg:Dm,linspace:yf,localResponseNormalization:xf,log:Zn,log1p:el,logSigmoid:wf,logSoftmax:$f,logSumExp:nl,logicalAnd:Bs,logicalNot:sl,logicalOr:rl,logicalXor:vf,losses:Pm,lowerBound:Sf,matMul:Z,max:wn,maxPool:ol,maxPool3d:Cf,maxPoolWithArgmax:Tf,maximum:al,mean:Vs,meshgrid:Nf,min:Hr,minimum:Ms,mirrorPad:il,mod:Ef,moments:If,movingAverage:Sm,mul:L,multiRNNCell:kf,multinomial:Rf,neg:bt,norm:nr,notEqual:ul,oneHot:Ws,ones:Yt,onesLike:_f,op:C,outerProduct:Af,pad:Fn,pad1d:Of,pad2d:Df,pad3d:cl,pad4d:Pf,pool:Ff,pow:Qn,prelu:dl,print:Bc,prod:Lf,raggedGather:Bf,raggedRange:Vf,raggedTensorToTensor:Mf,rand:Wf,randomGamma:Gf,randomNormal:ml,randomStandardNormal:Hf,randomUniform:mo,randomUniformInt:jf,range:sn,real:Jn,reciprocal:Kf,relu:rr,relu6:gl,reshape:_,reverse:rn,reverse1d:qf,reverse2d:Xf,reverse3d:Yf,reverse4d:Qf,rfft:yo,round:yl,rsqrt:Zf,scalar:K,scatterND:Cm,searchSorted:fo,selu:Jf,separableConv2d:em,setdiff1dAsync:tm,sigmoid:Tt,sign:nm,signal:Om,sin:sm,sinh:rm,slice:re,slice1d:om,slice2d:am,slice3d:im,slice4d:um,softmax:cm,softplus:tl,spaceToBatchND:ll,sparse:Fm,sparseToDense:Tm,spectral:Am,split:es,sqrt:It,square:it,squaredDifference:bl,squeeze:st,stack:Rt,step:wl,stridedSlice:lm,string:Lm,sub:H,sum:ue,tan:dm,tanh:Gr,tensor:at,tensor1d:rt,tensor2d:$n,tensor3d:$l,tensor4d:pm,tensor5d:hm,tensor6d:fm,tensorScatterUpdate:mm,tile:qn,topk:gm,transpose:zs,truncatedNormal:ym,unique:xm,unsortedSegmentSum:bm,unstack:an,upperBound:wm,variable:$m,where:Vt,whereAsync:Cl,zeros:nn,zerosLike:We},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ET=(n,e,t,s=$e)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(x("a",n,e,t),x("b",n,e,t))];case"AddN":return[s.addN(x("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(x("a",n,e,t),x("b",n,e,t))];case"Mul":return[s.mul(x("a",n,e,t),x("b",n,e,t))];case"RealDiv":case"Div":return[s.div(x("a",n,e,t),x("b",n,e,t))];case"DivNoNan":return[s.divNoNan(x("a",n,e,t),x("b",n,e,t))];case"FloorDiv":return[s.floorDiv(x("a",n,e,t),x("b",n,e,t))];case"Sub":return[s.sub(x("a",n,e,t),x("b",n,e,t))];case"Minimum":return[s.minimum(x("a",n,e,t),x("b",n,e,t))];case"Maximum":return[s.maximum(x("a",n,e,t),x("b",n,e,t))];case"Pow":return[s.pow(x("a",n,e,t),x("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IT=(n,e,t,s=$e)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(x("x",n,e,t))];case"Acos":return[s.acos(x("x",n,e,t))];case"Acosh":return[s.acosh(x("x",n,e,t))];case"Asin":return[s.asin(x("x",n,e,t))];case"Asinh":return[s.asinh(x("x",n,e,t))];case"Atan":return[s.atan(x("x",n,e,t))];case"Atan2":return[s.atan2(x("x",n,e,t),x("y",n,e,t))];case"Atanh":return[s.atanh(x("x",n,e,t))];case"Ceil":return[s.ceil(x("x",n,e,t))];case"Complex":return[s.complex(x("real",n,e,t),x("imag",n,e,t))];case"Cos":return[s.cos(x("x",n,e,t))];case"Cosh":return[s.cosh(x("x",n,e,t))];case"Elu":return[s.elu(x("x",n,e,t))];case"Erf":return[s.erf(x("x",n,e,t))];case"Exp":return[s.exp(x("x",n,e,t))];case"Expm1":return[s.expm1(x("x",n,e,t))];case"Floor":return[s.floor(x("x",n,e,t))];case"Log":return[s.log(x("x",n,e,t))];case"Log1p":return[s.log1p(x("x",n,e,t))];case"Imag":return[s.imag(x("x",n,e,t))];case"Neg":return[s.neg(x("x",n,e,t))];case"Reciprocal":return[s.reciprocal(x("x",n,e,t))];case"Real":return[s.real(x("x",n,e,t))];case"Relu":return[s.relu(x("x",n,e,t))];case"Round":return[s.round(x("x",n,e,t))];case"Selu":return[s.selu(x("x",n,e,t))];case"Sigmoid":return[s.sigmoid(x("x",n,e,t))];case"Sin":return[s.sin(x("x",n,e,t))];case"Sign":return[s.sign(x("x",n,e,t))];case"Sinh":return[s.sinh(x("x",n,e,t))];case"Softplus":return[s.softplus(x("x",n,e,t))];case"Sqrt":return[s.sqrt(x("x",n,e,t))];case"Square":return[s.square(x("x",n,e,t))];case"Tanh":return[s.tanh(x("x",n,e,t))];case"Tan":return[s.tan(x("x",n,e,t))];case"ClipByValue":return[s.clipByValue(x("x",n,e,t),x("clipValueMin",n,e,t),x("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(x("x",n,e,t))];case"Rsqrt":return[s.rsqrt(be(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(x("x",n,e,t),x("alpha",n,e,t))];case"Prelu":return[s.prelu(x("x",n,e,t),x("alpha",n,e,t))];case"IsNan":return[s.isNaN(be(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(be(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(be(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function et(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){v(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];v(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Td(n){return!(typeof n=="number"||n.some(e=>e<0))}function bs(n,e,t){let s=Ia(n,t);const r=!Td(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=Ia(o.shape,s)}),!Td(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Ia(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kT{constructor(e,t,s,r,o,a,i){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=K(0),xt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),et(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,xt(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return at([],[0].concat(this.elementShape));const s=this.readMany(e);return et(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Rt(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return at([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return et(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Se(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,an(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,a=[];U(()=>{t=_(t,[1,s,o]);for(let u=0;u<e.length;++u){const l=[0,u===0?0:r[u-1],0],d=[1,e[u],o];a[u]=_(re(t,l,d),this.elementShape)}return a});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _n{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);et(t,o.shape,"TensorList shape mismatch: "),xt(o)}),this.idTensor=K(0),this.maxNumElements=r,xt(this.idTensor)}copy(){return new _n([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);et(e,this.elementShape,"TensorList shape mismatch: ");const r=bs(this.elementShape,this.tensors,e);return U(()=>{const o=this.tensors.map(a=>_(a,r));return Rt(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=bs(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,et(r.shape,e,"TensorList shape mismatch: "),_(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(et(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");xt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new _n([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);et(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=bs(this.elementShape,this.tensors,t);return _(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);et(this.elementShape,t.shape,"TensorList shape mismatch: "),xt(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);et(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=bs(this.elementShape,this.tensors,s);return e.length===0?at([],[0].concat(r)):U(()=>{const o=e.map(a=>_(this.tensors[a],r));return Rt(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);et(this.elementShape,t,"TensorList shape mismatch: ");const s=bs(this.elementShape,this.tensors,t);return this.size()===0?at([],[0].concat(s)):U(()=>{const r=this.tensors.map(o=>_(o,s));return Se(r,0)})}}function RT(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);et(r,e,"TensorList shape mismatch: ");const o=an(n);return new _n(o,e,s)}function _T(n,e,t,s){return new _n([],n,e,s)}function AT(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new _n([],t,n.dtype,s),a=an(n,0);return e.forEach((i,u)=>{o.setItem(i,a[u])}),o}function OT(n,e,t){let s=0;const r=e.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),a=Ia(o,t),i=s===0?0:n.size/s,u=U(()=>{const l=[];n=_(n,[1,s,i]);for(let d=0;d<e.length;++d){const h=[0,d===0?0:r[d-1],0],f=[1,e[d],i];l[d]=_(re(n,h,f),a)}return n.dispose(),l}),c=new _n([],t,n.dtype,e.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DT=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=x("thenBranch",n,e,t),r=x("elseBranch",n,e,t),o=x("cond",n,e,t),a=x("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=x("body",n,e,t),r=x("cond",n,e,t),o=x("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),i=o.map(l=>l.id);let u=await a[0].data();a.forEach(l=>{!l.kept&&i.indexOf(l.id)===-1&&l.dispose()});let c=o;for(;u[0];){const l=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const d=c.map(h=>h.id);l.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});const p=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);u=await p[0].data(),p.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return c}case"LoopCond":{const s=x("pred",n,e,t);return[Ot(s)]}case"Switch":{const s=x("pred",n,e,t);let r=x("data",n,e,t);return r.kept||(r=Ot(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>be(r,e,t)!==void 0);if(s){const r=be(s,e,t);return[Ot(r)]}return}case"Enter":{const s=x("frameName",n,e,t),r=x("tensor",n,e,t);return t.enterFrame(s),[Ot(r)]}case"Exit":{const s=x("tensor",n,e,t);return t.exitFrame(),[Ot(s)]}case"NextIteration":{const s=x("tensor",n,e,t);return t.nextIteration(),[Ot(s)]}case"TensorArrayV3":{const s=x("size",n,e,t),r=x("dtype",n,e,t),o=x("elementShape",n,e,t),a=x("dynamicSize",n,e,t),i=x("clearAfterRead",n,e,t),u=x("identicalElementShapes",n,e,t),c=x("name",n,e,t),l=new kT(c,r,s,o,u,a,i);return t.addTensorArray(l),[l.idTensor,K(1)]}case"TensorArrayWriteV3":{const s=x("tensorArrayId",n,e,t),r=x("index",n,e,t),o=x("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{const s=x("tensorArrayId",n,e,t),r=x("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=x("tensorArrayId",n,e,t),r=x("indices",n,e,t),o=x("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=x("tensorArrayId",n,e,t),r=x("indices",n,e,t),o=x("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=x("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=x("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=x("tensorArrayId",n,e,t),r=x("tensor",n,e,t),o=x("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{const s=x("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[K(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=x("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=x("tensorListId",n,e,t),r=x("index",n,e,t),o=x("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{const s=x("tensorListId",n,e,t),r=x("index",n,e,t),o=x("elementShape",n,e,t),a=x("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=x("indices",n,e,t),r=x("tensor",n,e,t),o=x("elementShape",n,e,t),a=x("numElements",n,e,t),i=AT(r,s,o,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=x("elementShape",n,e,t),r=x("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=x(o,n,e,t),i=n.op==="TensorListReserve"?-1:a,u=_T(s,r,a,i);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=x("tensorListId",n,e,t),r=x("indices",n,e,t),o=x("elementShape",n,e,t),a=x("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{const s=x("tensorListId",n,e,t),r=x("elementShape",n,e,t),o=x("elementDType",n,e,t),a=x("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{const s=x("tensor",n,e,t),r=x("elementShape",n,e,t),o=x("elementDType",n,e,t),a=RT(s,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=x("tensorListId",n,e,t),r=t.getTensorList(s.id),o=x("dtype",n,e,t),a=x("elementShape",n,e,t);return[r.concat(o,a)]}case"TensorListPushBack":{const s=x("tensorListId",n,e,t),r=x("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=x("tensorListId",n,e,t),r=x("elementShape",n,e,t),o=x("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=x("tensor",n,e,t),r=x("elementShape",n,e,t),o=x("lengths",n,e,t),a=OT(s,o,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=x("tensorListId",n,e,t),r=t.getTensorList(s.id);return[K(r.size(),"int32")]}case"TensorListResize":{const s=x("tensorListId",n,e,t),r=x("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nd(n,e,t){const[s,r]=x("fusedOps",n,e,t),o=s==="biasadd",a=!o,i=r==="prelu",u=s==="fusedbatchnorm",c=x("numArgs",n,e,t);if(o){if(i&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=x("strides",n,e,t),d=Or(n,e,t),p=x("dataFormat",n,e,t).toUpperCase(),h=x("dilations",n,e,t);let[f,g]=x("args",n,e,t);a&&(g=f,f=void 0);const m=x("leakyreluAlpha",n,e,t);return{stride:l,pad:d,dataFormat:p,dilations:h,biasArg:f,preluArg:g,activationFunc:r,leakyreluAlpha:m}}const PT=(n,e,t,s=$e)=>{switch(n.op){case"Conv1D":{const r=x("stride",n,e,t),o=x("pad",n,e,t),a=x("dataFormat",n,e,t).toUpperCase(),i=x("dilation",n,e,t);return[s.conv1d(x("x",n,e,t),x("filter",n,e,t),r,o,a,i)]}case"Conv2D":{const r=x("strides",n,e,t),o=Or(n,e,t),a=x("dataFormat",n,e,t).toUpperCase(),i=x("dilations",n,e,t);return[s.conv2d(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2]],o,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:d}=Nd(n,e,t);return[s.fused.conv2d({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:d}=Nd(n,e,t);return[s.fused.depthwiseConv2d({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=x("outputShape",n,e,t),o=x("strides",n,e,t),a=Or(n,e,t);return[s.conv2dTranspose(x("x",n,e,t),x("filter",n,e,t),r,[o[1],o[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=x("strides",n,e,t),o=Or(n,e,t),a=x("dilations",n,e,t),i=x("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(x("input",n,e,t),x("filter",n,e,t),[r[1],r[2]],o,i,[a[1],a[2]])]}case"Conv3D":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("dataFormat",n,e,t).toUpperCase(),i=x("dilations",n,e,t);return[s.conv3d(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2],r[3]],o,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("kernelSize",n,e,t);return[s.avgPool(x("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("kernelSize",n,e,t);return[s.maxPool(x("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("kernelSize",n,e,t),i=x("includeBatchInIndex",n,e,t),{result:u,indexes:c}=s.maxPoolWithArgmax(x("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o,i);return[u,c]}case"AvgPool3D":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("kernelSize",n,e,t);return[s.avgPool3d(x("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("kernelSize",n,e,t);return[s.maxPool3d(x("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=x("strides",n,e,t),o=x("pad",n,e,t),a=x("dilations",n,e,t),i=r[1],u=r[2],c=a[1],l=a[2];return[s.dilation2d(x("x",n,e,t),x("filter",n,e,t),[i,u],o,[c,l],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FT=(n,e,t,s=$e)=>{switch(n.op){case"Fill":{const r=x("shape",n,e,t),o=x("dtype",n,e,t),a=x("value",n,e,t);return[s.fill(r,a,o)]}case"LinSpace":{const r=x("start",n,e,t),o=x("stop",n,e,t),a=x("num",n,e,t);return[s.linspace(r,o,a)]}case"Multinomial":{const r=x("logits",n,e,t),o=x("numSamples",n,e,t),a=x("seed",n,e,t);return[s.multinomial(r,o,a)]}case"OneHot":{const r=x("indices",n,e,t),o=x("depth",n,e,t),a=x("onValue",n,e,t),i=x("offValue",n,e,t),u=x("dtype",n,e,t);return[s.oneHot(r,o,a,i,u)]}case"Ones":return[s.ones(x("shape",n,e,t),x("dtype",n,e,t))];case"OnesLike":return[s.onesLike(x("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(x("shape",n,e,t),x("dtype",n,e,t),x("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(x("shape",n,e,t),x("minval",n,e,t),x("maxval",n,e,t),x("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(x("shape",n,e,t),x("minval",n,e,t),x("maxval",n,e,t),x("seed",n,e,t))];case"Range":{const r=x("start",n,e,t),o=x("stop",n,e,t),a=x("step",n,e,t);return[s.range(r,o,a,x("dtype",n,e,t))]}case"TruncatedNormal":{const r=x("shape",n,e,t),o=x("mean",n,e,t),a=x("stdDev",n,e,t),i=x("seed",n,e,t);return[s.truncatedNormal(r,o,a,x("dtype",n,e,t),i)]}case"Zeros":return[s.zeros(x("shape",n,e,t),x("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(n,e,t){const s=x("boxes",n,e,t),r=x("scores",n,e,t),o=x("maxOutputSize",n,e,t),a=x("iouThreshold",n,e,t),i=x("scoreThreshold",n,e,t),u=x("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}const LT=async(n,e,t,s,r=$e)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=Wo(n,e,t),d=await r.image.nonMaxSuppressionWithScoreAsync(o,a,i,u,c,l);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Wo(n,e,t),l=x("padToMaxOutputSize",n,e,t),d=await r.image.nonMaxSuppressionPaddedAsync(o,a,i,u,c,l);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Wo(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,a,i,u,c)]}case"Where":{const o=r.cast(x("condition",n,e,t),"bool"),a=[await r.whereAsync(o)];return o.dispose(),a}case"ListDiff":return r.setdiff1dAsync(x("x",n,e,t),x("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BT=(n,e,t,s=$e)=>{switch(n.op){case"LowerBound":{const r=x("sortedSequence",n,e,t),o=x("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=x("x",n,e,t),o=x("k",n,e,t),a=x("sorted",n,e,t),i=s.topk(r,o,a);return[i.values,i.indices]}case"UpperBound":{const r=x("sortedSequence",n,e,t),o=x("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=x("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=x("x",n,e,t),o=x("axis",n,e,t),a=s.unique(r,o);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VT=(n,e,t,s=$e)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=x("default",n,e,t);return[be(n.name,e,t)||r];case"Placeholder":return[be(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=x("x",n,e,t);return[Ot(l)]}case"IdentityN":return x("x",n,e,t).map(l=>Ot(l));case"Snapshot":const o=x("x",n,e,t);return[Ot(o)];case"Shape":return[s.tensor1d(x("x",n,e,t).shape,"int32")];case"ShapeN":return x("x",n,e,t).map(l=>s.tensor1d(l.shape));case"Size":return[s.scalar(x("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(x("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=x("x",n,e,t),i=x("data",n,e,t),u=x("message",n,e,t),c=x("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MT{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=K(0),this.tensorMap=new Map,xt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return K(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),U(()=>{const r=an(t),o=s.length,a=r.length;v(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){const u=s[i],c=r[i];xt(c),this.tensorMap.set(u,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return U(()=>{const r=[];for(let o=0;o<s.length;o++){const a=s[o],i=this.findWithDefault(a,t);r.push(i)}return Rt(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WT=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=x("keyDType",n,e,t),a=x("valueDType",n,e,t),i=new MT(o,a);return s.addHashTable(n.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=x("tableHandle",n,e,t,s),o=x("keys",n,e,t),a=x("values",n,e,t);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=x("tableHandle",n,e,t,s),o=x("keys",n,e,t),a=x("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=x("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UT=(n,e,t,s=$e)=>{switch(n.op){case"ResizeBilinear":{const r=x("images",n,e,t),o=x("size",n,e,t),a=x("alignCorners",n,e,t),i=x("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],a,i)]}case"ResizeNearestNeighbor":{const r=x("images",n,e,t),o=x("size",n,e,t),a=x("alignCorners",n,e,t),i=x("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],a,i)]}case"CropAndResize":{const r=x("image",n,e,t),o=x("boxes",n,e,t),a=x("boxInd",n,e,t),i=x("cropSize",n,e,t),u=x("method",n,e,t),c=x("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,a,i,u,c)]}case"ImageProjectiveTransformV3":{const r=x("images",n,e,t),o=x("transforms",n,e,t),a=x("outputShape",n,e,t),i=x("fillValue",n,e,t),u=x("interpolation",n,e,t),c=x("fillMode",n,e,t);return[s.image.transform(r,o,u.toLowerCase(),c.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zT=(n,e,t,s=$e)=>{switch(n.op){case"Equal":return[s.equal(x("a",n,e,t),x("b",n,e,t))];case"NotEqual":return[s.notEqual(x("a",n,e,t),x("b",n,e,t))];case"Greater":return[s.greater(x("a",n,e,t),x("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(x("a",n,e,t),x("b",n,e,t))];case"Less":return[s.less(x("a",n,e,t),x("b",n,e,t))];case"LessEqual":return[s.lessEqual(x("a",n,e,t),x("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(x("a",n,e,t),x("b",n,e,t))];case"LogicalNot":return[s.logicalNot(x("a",n,e,t))];case"LogicalOr":return[s.logicalOr(x("a",n,e,t),x("b",n,e,t))];case"Select":case"SelectV2":return[s.where(x("condition",n,e,t),x("a",n,e,t),x("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GT=(n,e,t,s=$e)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(x("a",n,e,t),x("b",n,e,t),x("transposeA",n,e,t),x("transposeB",n,e,t))];case"Einsum":return[s.einsum(x("equation",n,e,t),...x("tensors",n,e,t))];case"Transpose":return[s.transpose(x("x",n,e,t),x("perm",n,e,t))];case"_FusedMatMul":const[r,o]=x("fusedOps",n,e,t),a=r==="biasadd",i=o==="prelu",u=x("numArgs",n,e,t),c=x("leakyreluAlpha",n,e,t);if(a){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,d]=x("args",n,e,t);return[s.fused.matMul({a:x("a",n,e,t),b:x("b",n,e,t),transposeA:x("transposeA",n,e,t),transposeB:x("transposeB",n,e,t),bias:l,activation:o,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(x("a",n,e,t),x("numLower",n,e,t),x("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HT=(n,e,t,s=$e)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(x("x",n,e,t),x("axis",n,e,t),x("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(x("x",n,e,t),x("radius",n,e,t),x("bias",n,e,t),x("alpha",n,e,t),x("beta",n,e,t))];case"Softmax":return[s.softmax(x("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jT=(n,e,t,s=$e)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(x("paramsNestedSplits",n,e,t),x("paramsDenseValues",n,e,t),x("indices",n,e,t),x("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(x("starts",n,e,t),x("limits",n,e,t),x("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(x("shape",n,e,t),x("values",n,e,t),x("defaultValue",n,e,t),x("rowPartitionTensors",n,e,t),x("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KT=(n,e,t,s=$e)=>{switch(n.op){case"Max":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.max(x("x",n,e,t),i,u)]}case"Mean":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.mean(x("x",n,e,t),i,u)]}case"Min":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.min(x("x",n,e,t),i,u)]}case"Sum":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.sum(x("x",n,e,t),i,u)]}case"All":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.all(x("x",n,e,t),i,u)]}case"Any":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.any(x("x",n,e,t),i,u)]}case"ArgMax":{const i=x("axis",n,e,t);return[s.argMax(x("x",n,e,t),i)]}case"ArgMin":{const i=x("axis",n,e,t);return[s.argMin(x("x",n,e,t),i)]}case"Prod":{const i=x("axis",n,e,t),u=x("keepDims",n,e,t);return[s.prod(x("x",n,e,t),i,u)]}case"Cumprod":{const i=x("axis",n,e,t),u=x("exclusive",n,e,t),c=x("reverse",n,e,t);return[s.cumprod(x("x",n,e,t),i,u,c)]}case"Cumsum":{const i=x("axis",n,e,t),u=x("exclusive",n,e,t),c=x("reverse",n,e,t);return[s.cumsum(x("x",n,e,t),i,u,c)]}case"Bincount":const r=x("x",n,e,t),o=x("weights",n,e,t),a=x("size",n,e,t);return[s.bincount(r,o,a)];case"DenseBincount":{const i=x("x",n,e,t),u=x("weights",n,e,t),c=x("size",n,e,t),l=x("binaryOutput",n,e,t);return[s.denseBincount(i,u,c,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qT=(n,e,t,s=$e)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=x("n",n,e,t),o=x("axis",n,e,t);let a=x("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,o)]}case"Gather":{const r=x("x",n,e,t),o=x("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=x("axis",n,e,t),o=x("batchDims",n,e,t),a=x("x",n,e,t),i=x("indices",n,e,t);return[s.gather(a,s.cast(i,"int32"),r,o)]}case"Reverse":{const r=x("dims",n,e,t),o=[];for(let i=0;i<r.length;i++)r[i]&&o.push(i);const a=x("x",n,e,t);return[s.reverse(a,o)]}case"ReverseV2":{const r=x("axis",n,e,t),o=x("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=x("begin",n,e,t),o=x("size",n,e,t);return[s.slice(x("x",n,e,t),r,o)]}case"StridedSlice":{const r=x("begin",n,e,t),o=x("end",n,e,t),a=x("strides",n,e,t),i=x("beginMask",n,e,t),u=x("endMask",n,e,t),c=x("ellipsisMask",n,e,t),l=x("newAxisMask",n,e,t),d=x("shrinkAxisMask",n,e,t),p=x("x",n,e,t);return[s.stridedSlice(p,r,o,a,i,u,c,l,d)]}case"Pack":return U(()=>{const r=x("axis",n,e,t),o=x("tensors",n,e,t),a=o[0].shape,i=s.squeeze(o[0]).shape,u=o.map(c=>{const l=ce(c.shape,a);if(!l&&!ce(s.squeeze(c).shape,i))throw new Error("the input tensors shape does not match");return l?c:s.reshape(c,a)});return[s.stack(u,r)]});case"Unpack":{const r=x("axis",n,e,t),o=x("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=x("reps",n,e,t);return[s.tile(x("x",n,e,t),r)]}case"Split":case"SplitV":{const r=x("axis",n,e,t),o=x("numOrSizeSplits",n,e,t),a=x("x",n,e,t);return s.split(a,o,r)}case"ScatterNd":{const r=x("indices",n,e,t),o=x("values",n,e,t),a=x("shape",n,e,t);return[s.scatterND(r,o,a)]}case"GatherNd":{const r=x("x",n,e,t),o=x("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=x("sparseIndices",n,e,t),o=x("outputShape",n,e,t),a=x("sparseValues",n,e,t),i=x("defaultValue",n,e,t);return[s.sparseToDense(r,a,o,a.dtype===i.dtype?i:s.cast(i,a.dtype))]}case"TensorScatterUpdate":{const r=x("indices",n,e,t),o=x("values",n,e,t),a=x("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XT=(n,e,t,s=$e)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:a,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(x("indices",n,e,t),x("values",n,e,t),x("denseShape",n,e,t),x("defaultValue",n,e,t));return[r,o,a,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(x("inputIndices",n,e,t),x("inputShape",n,e,t),x("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YT=(n,e,t,s=$e)=>{switch(n.op){case"FFT":return[s.fft(x("x",n,e,t))];case"IFFT":return[s.ifft(x("x",n,e,t))];case"RFFT":return[s.rfft(x("x",n,e,t))];case"IRFFT":return[s.irfft(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QT=(n,e,t,s=$e)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(x("input",n,e,t),x("pattern",n,e,t),x("rewrite",n,e,t),x("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(x("data",n,e,t),x("dataSplits",n,e,t),x("separator",n,e,t),x("nGramWidths",n,e,t),x("leftPad",n,e,t),x("rightPad",n,e,t),x("padWidth",n,e,t),x("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:a}=s.string.stringSplit(x("input",n,e,t),x("delimiter",n,e,t),x("skipEmpty",n,e,t));return[r,o,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(x("input",n,e,t),x("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT=(n,e,t,s=$e)=>{switch(n.op){case"Cast":return[s.cast(x("x",n,e,t),x("dtype",n,e,t))];case"ExpandDims":{const r=x("axis",n,e,t);return[s.expandDims(x("x",n,e,t),r)]}case"Squeeze":{const r=x("axis",n,e,t);return[s.squeeze(x("x",n,e,t),r)]}case"Reshape":return[s.reshape(x("x",n,e,t),x("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(x("x",n,e,t),x("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(x("x",n,e,t),x("padding",n,e,t),x("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(x("x",n,e,t),x("padding",n,e,t),x("constantValue",n,e,t))];case"SpaceToBatchND":{const r=x("blockShape",n,e,t),o=x("paddings",n,e,t);return[s.spaceToBatchND(x("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=x("blockShape",n,e,t),o=x("crops",n,e,t);return[s.batchToSpaceND(x("x",n,e,t),r,o)]}case"DepthToSpace":{const r=x("blockSize",n,e,t),o=x("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(x("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(x("x",n,e,t),x("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(x("s0",n,e,t),x("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n,e,t,s,r=U){const o=((a,i,u)=>{switch(a.category){case"arithmetic":return r(()=>ET(a,i,u));case"basic_math":return r(()=>IT(a,i,u));case"control":return DT(a,i,u);case"convolution":return r(()=>PT(a,i,u));case"creation":return r(()=>FT(a,i,u));case"dynamic":return LT(a,i,u);case"evaluation":return r(()=>BT(a,i,u));case"image":return r(()=>UT(a,i,u));case"graph":return r(()=>VT(a,i,u));case"logical":return r(()=>zT(a,i,u));case"matrices":return r(()=>GT(a,i,u));case"normalization":return r(()=>HT(a,i,u));case"ragged":return r(()=>jT(a,i,u));case"reduction":return r(()=>KT(a,i,u));case"slice_join":return r(()=>qT(a,i,u));case"sparse":return r(()=>XT(a,i,u));case"spectral":return r(()=>YT(a,i,u));case"string":return r(()=>QT(a,i,u));case"transformation":return r(()=>ZT(a,i,u));case"hash_table":return WT(a,i,u,s);case"custom":const c=Kg(a.op);if(c&&c.customExecutor)return c.customExecutor(new NT(a,i,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return en(o)?o.then(a=>[].concat(a)):[].concat(o)}class Id{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(n,e,t,s){const r=new Set,o=[];let a=null,i=null;const u=new Set,c=new Set(Object.keys(n).map(p=>Be(p)[0]));s=s||[];const l=new Set(s.map(p=>Be(p.name)[0])),d=[...e];for(;d.length>0;){const p=d.pop();if((mn(p)||aN(p)||iN(p))&&a==null&&(a=p,i=a.children.map(h=>h.name).filter(h=>r.has(h))),r.add(p.name),t[p.name]==null&&!c.has(p.name)&&!l.has(p.name)){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(h=>{u.has(h.name)||(u.add(h.name),d.push(h))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:i}}function JT(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(m=>Be(m)[0]).map(m=>n.nodes[m]),o=n.initNodes||[],a=m=>t.has(typeof m=="string"?m:m.name);function i(m){return[...new Map(m.map(y=>[y.name,y])).values()]}const u=i([...r,...n.weights,...o]).filter(a),c=i([...u,...Object.values(n.nodes)]).filter(a),l=new Map(c.map(m=>[m.name,m])),d={};for(const m of c){d[m.name]=d[m.name]||0;for(const y of m.children)a(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const p=Object.entries(d).filter(([,m])=>m===0).map(([m])=>m),h=[...p];for(;p.length>0;){const m=p.pop(),y=l.get(m);for(const b of y.children.filter(a))--d[b.name]===0&&(h.push(b.name),p.push(b.name))}const f=h.map(m=>l.get(m)),g=eN(f,u);return tN(g,u),g}function eN(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),i=t.get(a);for(const u of i.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(a=>r.has(a.name))}class fr extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function tN(n,e){const t=new Map(n.map((i,u)=>[i.name,u])),s=new Set(e.map(i=>i.name)),r=i=>s.has(typeof i=="string"?i:i.name),o=new Set(n.map(i=>i.name)),a=i=>o.has(typeof i=="string"?i:i.name);for(const i of n){for(const u of i.children.filter(a)){if(!t.has(u.name))throw new fr(`Child ${u.name} of node ${i.name} is unreachable.`);if(t.get(i.name)>t.get(u.name))throw new fr(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!r(i))for(const u of i.inputs){if(!t.has(u.name))throw new fr(`Input ${u.name} of node ${i.name} is unreachable.`);if(t.get(u.name)>t.get(i.name))throw new fr(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function nN(n){const e=new Map(n.map((i,u)=>[i.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((i,u)=>mn(i)?t:u),r=i=>{const u=s[e.get(i.name)];return u??-1},o=n.map((i,u)=>i.children.map(r).reduce((c,l)=>Math.max(c,l),s[u])),a=new Map;for(let i=0;i<n.length;++i){const u=o[i];if(u===t)continue;const c=n[i],l=n[u];a.has(l.name)||a.set(l.name,[]),a.get(l.name).push(c)}return a}const sN=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),rN=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),oN=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function mn(n){return sN.has(n.op)}function aN(n){return rN.has(n.op)}function iN(n){return oN.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qr{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new qr(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=kd(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const c=t.map(d=>d.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}const i=JT(this.graph,s),u=nN(i);return{orderedNodes:i,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return xt(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(p=>this.graph.nodes[Be(p)[0]]),o=t.map(p=>Be(p)[0]),a=new Set(o);let i=o.map(p=>this.graph.nodes[p]);i.length===0&&(i=this._outputs);const u=this.getCompilationKey(r,i);let c=this.compiledMap.get(u);c==null&&(c=this.compile(e,i),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=I().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const l={},d={};return U(()=>{const p=new Id(this.weightMap,l,d,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,$]=Be(y,p),S=[];S[$]=e[y],h[b]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(S))});const f=this.getFrozenTensorIds(h),{orderedNodes:g,nodeLiveUntilMap:m}=c;for(const y of g){if(h[y.name])continue;const b=Ed(y,h,p,this._resourceManager);if(en(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);h[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,h,p,f,a,m.get(y.name))}return this.parent==null&&p.dispose(f),t.map(y=>be(y,h,p))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,a,i){if(!(mn(t)||a.has(e))){for(const u of s[e])u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length);for(const u of t.inputs){if(mn(u))continue;const c=vd(u.name,s,r);if(c!=null)for(const l of c){if(!l||l.kept||o.has(l.id))continue;const d=i[l.id];d===1?(l.dispose(),delete i[l.id]):d!=null&&i[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,a){function i(u){return mn(u)||o.has(u.name)}if(!(mn(e)||a==null))for(const u of a){if(i(u))continue;const c=vd(u.name,t,s);for(const l of c)!l||l.kept||r.has(l.id)||l.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=I().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const a=new Id(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,s),u=t.map(p=>be(p,i,a)),c=u.map(p=>p.id),l=Object.keys(e).map(p=>e[p].id),d=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(p=>{p.forEach(h=>{h&&!h.isDisposed&&!d.has(h.id)&&h.dispose()})}),this.parent==null&&a.dispose(d),u}async executeFunctionAsync(e,t,s){const r=e.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),a=o.map(S=>this.graph.nodes[Be(S)[0]]),i=s.map(S=>Be(S)[0]),u=new Set(i);let c=i.map(S=>this.graph.nodes[S]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:d,dynamicNode:p,syncInputs:h}=kd(e,c,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[N,E]=Be(S),k=[];k[E]=e[S],g[N]=k});const m={},y=this.getFrozenTensorIds(g),b={};for(;f.length>0;){const S=this.processStack(a,f,t,g,b,y,u,m,l);await Promise.all(S)}p==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=c.filter(S=>!mn(S)&&!be(S.name,g,t)).map(S=>S.name);if($.length>0){let S="";throw p!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${d}]. ${S}`)}return g}processStack(e,t,s,r,o,a,i,u,c){const l=[];for(;t.length>0;){const d=t.pop();s.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&x("isConstant",d.node,r,s)&&([p]=At(d.node.name,s)),r[d.node.name]==null){const h=Ed(d.node,r,s,this._resourceManager);p||([p]=At(d.node.name,s));const f=s.currentContext;en(h)?l.push(h.then(g=>(r[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),s.currentContext=f,this.checkTensorForDisposal(p,d.node,r,s,a,i,u),this.processChildNodes(d.node,t,s,r,o,c),g))):(r[p]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(h)),this.checkTensorForDisposal(p,d.node,r,s,a,i,u),this.processChildNodes(d.node,t,s,r,o,c))}else this.processChildNodes(d.node,t,s,r,o,c)}return l}processChildNodes(e,t,s,r,o,a){e.children.forEach(i=>{const[u]=At(i.name,s);o[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(c=>!!be(c,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:i})):i.inputNames.every(c=>!!be(c,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Be(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,i=a.length===s.shape.length&&s.shape.every((u,c)=>a[c]===-1||a[c]===u);v(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&v(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];a!=null?r[a.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Be(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Be(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class uN{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cN="?tfjs-format=file",lN="model.json";class dN{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Bl){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new uN}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return en(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new qr(Sd.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Sd.Instance.transformGraph(e.modelInitializer);this.initializer=new qr(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof te?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof te)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const a in o){const i=o[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,a)=>{var i,u,c;const l=(c=(u=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||u===void 0?void 0:u[a])===null||c===void 0?void 0:c.resourceId;return l!=null?o[a]=this.resourceIdToCapturedInput[l]:o[a]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],a=t[o];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Kl(n,e={},t=Bl){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=pN(n));const s=new dN(n,e,t);return await s.load(),s}function pN(n){return n.endsWith("/")||(n=n+"/"),`${n}${lN}${cN}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var ka=function(n,e){return ka=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var r in s)s.hasOwnProperty(r)&&(t[r]=s[r])},ka(n,e)};function Yg(n,e){function t(){this.constructor=n}ka(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Ne=function(){return Ne=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n},Ne.apply(this,arguments)};function ne(n,e,t,s){return new(t||(t=Promise))(function(r,o){function a(c){try{u(s.next(c))}catch(l){o(l)}}function i(c){try{u(s.throw(c))}catch(l){o(l)}}function u(c){var l;c.done?r(c.value):(l=c.value,l instanceof t?l:new t(function(d){d(l)})).then(a,i)}u((s=s.apply(n,e||[])).next())})}function se(n,e){var t,s,r,o,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(u){return function(c){return function(l){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,s&&(r=2&l[0]?s.return:l[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,l[1])).done)return r;switch(s=0,r&&(l=[2&l[0],r.value]),l[0]){case 0:case 1:r=l;break;case 4:return a.label++,{value:l[1],done:!1};case 5:a.label++,s=l[1],l=[0];continue;case 7:l=a.ops.pop(),a.trys.pop();continue;default:if(r=a.trys,!((r=r.length>0&&r[r.length-1])||l[0]!==6&&l[0]!==2)){a=0;continue}if(l[0]===3&&(!r||l[1]>r[0]&&l[1]<r[3])){a.label=l[1];break}if(l[0]===6&&a.label<r[1]){a.label=r[1],r=l;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(l);break}r[2]&&a.ops.pop(),a.trys.pop();continue}l=e.call(n,a)}catch(d){l=[6,d],s=0}finally{t=r=0}if(5&l[0])throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}([u,c])}}}function Xr(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function ql(n){return ne(this,void 0,void 0,function(){var e,t;return se(this,function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof te?[4,To(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=Xr(n.width),e.height=Xr(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}})})}function Qg(n){return ne(this,void 0,void 0,function(){var e,t,s,r,o,a;return se(this,function(i){switch(i.label){case 0:return n instanceof te?(e=n.shape.slice(0,2),t=e[0],s=e[1],r=ImageData.bind,[4,To(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,i.sent(),s,t]))];case 2:return o=document.createElement("canvas"),a=o.getContext("2d"),o.width=Xr(n.width),o.height=Xr(n.height),a.drawImage(n,0,0),[2,a.getImageData(0,0,o.width,o.height)]}})})}function Zg(n){return ne(this,void 0,void 0,function(){var e,t;return se(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,ql(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,No(e,4)]}})})}function Io(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}function Jg(n){var e=n.shape[2],t=Mc(n,2),s=_(t,[-1]);return Ws(s,e)}function mr(n,e){return U(function(){return ee(is(n,K(e)),"int32")})}function hN(n,e){var t=e.shape,s=t[0],r=t[1],o=t[2];return U(function(){var a=Jg(e),i=Me(sn(0,o,1,"int32"),1),u=ee(Z(a,i),"int32"),c=_(u,[s,r]),l=W(c,K(1,"int32"));return H(function(d,p){return L(d,p)}(l,n),K(1,"int32"))})}var ey=function(){function n(e,t){this.model=e,this.outputStride=t;var s=this.model.inputs[0].shape;v(s[1]===-1&&s[2]===-1,function(){return"Input shape ["+s[1]+", "+s[2]+"] must both be equal to or -1"})}return n.prototype.predict=function(e){var t=this;return U(function(){var s=t.preprocessInput(ee(e,"float32")),r=Me(s,0),o=t.model.predict(r).map(function(i){return st(i,[0])}),a=t.nameOutputResults(o);return{heatmapScores:Tt(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd,segmentation:a.segmentation,partHeatmaps:a.partHeatmaps,longOffsets:a.longOffsets,partOffsets:a.partOffsets}})},n.prototype.dispose=function(){this.model.dispose()},n}(),fN=function(n){function e(){return n!==null&&n.apply(this,arguments)||this}return Yg(e,n),e.prototype.preprocessInput=function(t){return U(function(){return H(ae(t,127.5),1)})},e.prototype.nameOutputResults=function(t){return{offsets:t[0],segmentation:t[1],partHeatmaps:t[2],longOffsets:t[3],heatmap:t[4],displacementFwd:t[5],displacementBwd:t[6],partOffsets:t[7]}},e}(ey),ko=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],yt=ko.length,Yr=ko.reduce(function(n,e,t){return n[e]=t,n},{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(n){var e=n[0],t=n[1];return[Yr[e],Yr[t]]});function Xl(n,e,t){var s=n[0],r=n[1],o=e[0],a=e[1],i=t.top,u=t.bottom;return[a/(t.left+t.right+r),o/(i+u+s)]}function ty(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+yt)}}function ny(n,e,t){var s=ty(n.heatmapY,n.heatmapX,n.id,t),r=s.y,o=s.x;return{x:n.heatmapX*e+o,y:n.heatmapY*e+r}}function Rd(n,e,t){return n<e?e:n>t?t:n}function _d(n,e){return{x:n.x+e.x,y:n.y+e.y}}function mN(n,e,t){t===void 0&&(t=.3);for(var s=0,r=0,o=0;o<n.length;o++)e.keypoints[o].score>t&&(r+=1,s+=Math.pow(n[o].x-e.keypoints[o].position.x,2)+Math.pow(n[o].y-e.keypoints[o].position.y,2));return r===0?s=1/0:s/=r,s}function gN(n,e,t,s,r,o,a){for(var i=a[0],u=a[1],c=t(n),l=c.y*s+c.x,d=r[yt*(2*l)+e],p=r[yt*(2*l+1)+e],h=n.y+d,f=n.x+p,g=0;g<o;g++){h=Math.min(h,i-1);var m=t({x:f=Math.min(f,u-1),y:h}),y=m.y*s+m.x;h+=d=r[yt*(2*y)+e],f+=p=r[yt*(2*y+1)+e]}return{x:f,y:h}}function sy(n,e,t,s,r,o,a,i,u,c){for(var l=r[0],d=r[1],p=o[0],h=o[1],f=i[0],g=i[1],m=[],y=function(R){return function(A,O,D,V){var z=O[0],G=O[1],j=D[0],q=D[1],Q=Math.round(((z+A.y+1)*q-1)/V);return{x:Math.round(((G+A.x+1)*j-1)/V),y:Q}}(R,[l,d],[p,h],u)},b=0;b<s;b++){var $=gN(n,b,y,a,e,c,[f,g]);m.push($)}for(var S=-1,N=1/0,E=0;E<t.length;E++){var k=mN(m,t[E]);k<N&&(S=E,N=k)}return S}function ry(n,e){var t=n[0],s=n[1];return[Math.round((s-1)/e+1),Math.round((t-1)/e+1)]}function oy(n,e,t,s,r,o,a,i,u,c,l){for(var d=a[0],p=a[1],h=n.shape,f=h[0],g=h[1],m=e.shape.slice(0,2),y=m[0],b=m[1],$=_(e,[y,b,2,yt]),S=new Float32Array(l*yt*3).fill(0),N=0;N<t.length;N++)for(var E=N*yt*3,k=t[N],R=0;R<yt;R++){var A=k.keypoints[R],O=E+3*R;S[O]=A.score,S[O+1]=A.position.y,S[O+2]=A.position.x}var D=Xl([s,r],[d,p],i),V=D[0],z=D[1],G=at(S,[l,yt,3]),j=i.top,q=i.left,Q={variableNames:["segmentation","longOffsets","poses"],outputShape:[f,g],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `+j+", "+z+", "+o+`);
      float stridedW = convertToPositionInOutputFloat(
        w, `+q+", "+V+", "+o+`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `+l+`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `+yt+`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `+u+`; s++) {
            int yRounded = round(min(y, float(`+(s-1)+`)));
            int xRounded = round(min(x, float(`+(r-1)+`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `+j+", "+z+", "+o+`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `+q+", "+V+", "+o+`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `+c+`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `};return bh().compileAndRun(Q,[n,$,G])}function ay(){return yh()==="webgl"}function yN(n,e,t,s,r,o,a,i,u,c,l,d){var p=a[0],h=a[1];return u===void 0&&(u=.2),c===void 0&&(c=8),l===void 0&&(l=.3),d===void 0&&(d=10),ne(this,void 0,void 0,function(){var f,g,m,y,b;return se(this,function($){switch($.label){case 0:return f=t.filter(function(S){return S.score>=u}),ay()?(m=U(function(){var S=oy(n,e,f,s,r,o,[p,h],i,c,l,d),N=ft().makeTensorFromDataId(S.dataId,S.shape,S.dtype);return f.map(function(E,k){return function(R,A){return U(function(){return ee(tr(R,K(A)),"int32")})}(N,k)})}),[4,Promise.all(m.map(function(S){return S.data()}))]):[3,2];case 1:return g=$.sent(),m.forEach(function(S){return S.dispose()}),[3,5];case 2:return[4,n.data()];case 3:return y=$.sent(),[4,e.data()];case 4:b=$.sent(),g=function(S,N,E,k,R,A,O,D,V,z){var G=O[0],j=O[1];z===void 0&&(z=5);for(var q=E.map(function(ln){return new Uint8Array(k*R).fill(0)}),Q=D.top,J=D.left,he=Xl([k,R],[G,j],D),Fe=he[0],qe=he[1],pt=ry([G,j],A)[0],Xe=0;Xe<k;Xe+=1)for(var ht=0;ht<R;ht+=1){var Ye=Xe*R+ht;if(S[Ye]===1){var Qe=sy({x:ht,y:Xe},N,E,z,[Q,J],[Fe,qe],pt,[k,R],A,V);Qe>=0&&(q[Qe][Ye]=1)}}return q}(y,b,f,s,r,o,[p,h],i,c),$.label=5;case 5:return[2,g.map(function(S,N){return{data:S,pose:f[N],width:r,height:s}})]}})})}function xN(n,e,t,s,r,o,a,i,u,c,l,d,p){var h=i[0],f=i[1];return c===void 0&&(c=.2),l===void 0&&(l=8),d===void 0&&(d=.3),p===void 0&&(p=10),ne(this,void 0,void 0,function(){var g,m,y,b,$,S;return se(this,function(N){switch(N.label){case 0:return g=s.filter(function(E){return E.score>=c}),ay()?(y=U(function(){var E=oy(n,e,g,r,o,a,[h,f],u,l,d,p),k=ft().makeTensorFromDataId(E.dataId,E.shape,E.dtype);return g.map(function(R,A){return function(O,D,V){return U(function(){return H(L(ee(tr(O,K(V)),"int32"),W(D,1)),1)})}(k,t,A)})}),[4,Promise.all(y.map(function(E){return E.data()}))]):[3,2];case 1:return m=N.sent(),y.forEach(function(E){return E.dispose()}),[3,6];case 2:return[4,n.data()];case 3:return b=N.sent(),[4,e.data()];case 4:return $=N.sent(),[4,t.data()];case 5:S=N.sent(),m=function(E,k,R,A,O,D,V,z,G,j,q){var Q=z[0],J=z[1];q===void 0&&(q=5);for(var he=A.map(function(od){return new Int32Array(O*D).fill(-1)}),Fe=G.top,qe=G.left,pt=Xl([O,D],[Q,J],G),Xe=pt[0],ht=pt[1],Ye=ry([Q,J],V)[0],Qe=0;Qe<O;Qe+=1)for(var ln=0;ln<D;ln+=1){var ys=Qe*D+ln;if(E[ys]===1){var dr=sy({x:ln,y:Qe},k,A,q,[Fe,qe],[Xe,ht],Ye,[O,D],V,j);dr>=0&&(he[dr][ys]=R[ys])}}return he}(b,$,S,g,r,o,a,[h,f],u,l),N.label=6;case 6:return[2,m.map(function(E,k){return{pose:g[k],data:E,height:r,width:o}})]}})})}function Uo(n){return Math.floor(n/2)}var bN=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(Uo(e),e);)this.exchange(e,Uo(e)),e=Uo(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n}();function wN(n,e,t,s,r,o){for(var a=o.shape,i=a[0],u=a[1],c=!0,l=Math.max(t-r,0),d=Math.min(t+r+1,i),p=l;p<d;++p){for(var h=Math.max(s-r,0),f=Math.min(s+r+1,u),g=h;g<f;++g)if(o.get(p,g,n)>e){c=!1;break}if(!c)break}return c}var iy=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(n){var e=n[0],t=n[1];return[Yr[e],Yr[t]]}),zo=iy.map(function(n){return n[1]}),Ad=iy.map(function(n){return n[0]});function Go(n,e,t,s){return{y:Rd(Math.round(n.y/e),0,t-1),x:Rd(Math.round(n.x/e),0,s-1)}}function Od(n,e,t,s,r,o,a,i){i===void 0&&(i=2);for(var u=s.shape,c=u[0],l=u[1],d=function(b,$,S){var N=S.shape[2]/2;return{y:S.get($.y,$.x,b),x:S.get($.y,$.x,N+b)}}(n,Go(e.position,o,c,l),a),p=_d(e.position,d),h=0;h<i;h++){var f=Go(p,o,c,l),g=ty(f.y,f.x,t,r);p=_d({x:f.x*o,y:f.y*o},{x:g.x,y:g.y})}var m=Go(p,o,c,l),y=s.get(m.y,m.x,t);return{position:p,part:ko[t],score:y}}function $N(n,e,t,s,r,o){var a=e.shape[2],i=zo.length,u=new Array(a),c=n.part,l=n.score,d=ny(c,s,t);u[c.id]={score:l,part:ko[c.id],position:d};for(var p=i-1;p>=0;--p){var h=zo[p],f=Ad[p];u[h]&&!u[f]&&(u[f]=Od(p,u[h],f,e,t,s,o))}for(p=0;p<i;++p)h=Ad[p],f=zo[p],u[h]&&!u[f]&&(u[f]=Od(p,u[h],f,e,t,s,r));return u}function uy(n,e,t,s){var r=t.x,o=t.y;return n.some(function(a){var i,u,c,l,d,p,h=a.keypoints[s].position;return i=o,u=r,c=h.y,l=h.x,(d=c-i)*d+(p=l-u)*p<=e})}function vN(n,e,t){var s=t.reduce(function(r,o,a){var i=o.position,u=o.score;return uy(n,e,i,a)||(r+=u),r},0);return s/t.length}function gr(n,e,t,s,r,o,a,i){a===void 0&&(a=.5),i===void 0&&(i=20);for(var u=[],c=function(f,g,m){for(var y=m.shape,b=y[0],$=y[1],S=y[2],N=new bN(b*$*S,function(O){return O.score}),E=0;E<b;++E)for(var k=0;k<$;++k)for(var R=0;R<S;++R){var A=m.get(E,k,R);A<f||wN(R,A,E,k,g,m)&&N.enqueue({score:A,part:{heatmapY:E,heatmapX:k,id:R}})}return N}(a,1,n),l=i*i;u.length<o&&!c.empty();){var d=c.dequeue();if(!uy(u,l,ny(d.part,r,e),d.part.id)){var p=$N(d,n,e,r,t,s),h=vN(u,l,p);u.push({keypoints:p,score:h})}}return u}var ws,SN=[-123.15,-115.9,-103.06],CN=function(n){function e(){return n!==null&&n.apply(this,arguments)||this}return Yg(e,n),e.prototype.preprocessInput=function(t){return W(t,SN)},e.prototype.nameOutputResults=function(t){var s=t[0],r=t[1],o=t[2],a=t[3],i=t[4],u=t[5];return{offsets:i,segmentation:t[6],partHeatmaps:u,longOffsets:a,heatmap:o,displacementFwd:r,displacementBwd:s,partOffsets:t[7]}},e}(ey),Dd="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",Pd="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Ss(n){if(typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&e.offsetHeight!==0&&"offsetWidth"in e&&e.offsetWidth!==0)return[e.offsetHeight,e.offsetWidth];if(e.height!=null&&e.width!=null)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(n);if(typeof ImageData<"u"&&n instanceof ImageData)return[n.height,n.width];if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(n);if(n instanceof te)return[n.shape[0],n.shape[1]];throw new Error("error: Unknown input type: "+n+".")}function Fd(n,e){return function(t,s){return(t-1)%s==0}(n,e)?n:Math.floor(n/e)*e+1}var Cs={low:"low",medium:"medium",high:"high",full:"full"},TN=((ws={})[Cs.low]=.25,ws[Cs.medium]=.5,ws[Cs.high]=.75,ws[Cs.full]=1,ws);function yr(n,e,t){var s=t[0],r=t[1],o=function(a){if(typeof a=="string"){var i=TN[a];return v(typeof i=="number",function(){return"string value of inputResolution must be one of "+Object.values(Cs).join(",")+" but was "+a+"."}),i}return v(typeof a=="number"&&a<=2&&a>=.1,function(){return"inputResolution must be a string or number between 0.1 and 2, but was "+a}),a}(n);return[Fd(s*o,e),Fd(r*o,e)]}function Wn(n,e,t,s,r){var o=e[0],a=e[1],i=t[0],u=t[1],c=s[0],l=c[0],d=c[1],p=s[1],h=p[0],f=p[1];return r===void 0&&(r=!1),U(function(){var g=In.resizeBilinear(n,[i,u],!0);return r&&(g=Tt(g)),function(m,y,b){var $=y[0],S=y[1],N=b[0],E=N[0],k=N[1],R=b[1],A=R[0],O=R[1];return U(function(){var D=Me(m);return st(In.cropAndResize(D,[[E/($+E+k-1),A/(S+A+O-1),(E+$-1)/($+E+k-1),(A+S-1)/(S+A+O-1)]],[0],[$,S]),[0])})}(g,[o,a],[[l,d],[h,f]])})}function xr(n,e){var t=e[0],s=e[1],r=Ss(n),o=r[0],a=r[1],i=s/t,u=[0,0,0,0],c=u[0],l=u[1],d=u[2],p=u[3];a/o<i?(c=0,l=0,d=Math.round(.5*(i*o-a)),p=Math.round(.5*(i*o-a))):(c=Math.round(.5*(1/i*a-o)),l=Math.round(.5*(1/i*a-o)),d=0,p=0);var h=U(function(){var f=function(g){return g instanceof te?g:No(g)}(n);return f=cl(f,[[c,l],[d,p],[0,0]]),In.resizeBilinear(f,[t,s])});return{resized:h,padding:{top:c,left:d,right:p,bottom:l}}}function br(n){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function wr(n,e,t,s,r){var o=e[0],a=e[1],i=t[0],u=t[1],c=function(l,d,p,h,f){return h===void 0&&(h=0),f===void 0&&(f=0),p===1&&d===1&&h===0&&f===0?l:l.map(function(g){return function(m,y,b,$,S){return $===void 0&&($=0),S===void 0&&(S=0),{score:m.score,keypoints:m.keypoints.map(function(N){var E=N.score,k=N.part,R=N.position;return{score:E,part:k,position:{x:R.x*b+S,y:R.y*y+$}}})}}(g,d,p,h,f)})}(n,(o+s.top+s.bottom)/i,(a+s.left+s.right)/u,-s.top,-s.left);return r?function(l,d){return d<=0?l:l.map(function(p){return function(h,f){return{score:h.score,keypoints:h.keypoints.map(function(g){var m=g.score,y=g.part,b=g.position;return{score:m,part:y,position:{x:f-1-b.x,y:b.y}}})}}(p,d)})}(c,a):c}var Ld={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},Bd=["MobileNetV1","ResNet50"],Vd={MobileNetV1:[8,16,32],ResNet50:[32,16]},Md={MobileNetV1:[.5,.75,1],ResNet50:[1]},Wd=[1,2,4],$r={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},vr={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function Ud(n){var e=n.segmentationThreshold,t=n.maxDetections,s=n.scoreThreshold,r=n.nmsRadius;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(t<=0)throw new Error("Invalid maxDetections "+t+". Should be > 0");if(s<0||s>1)throw new Error("Invalid scoreThreshold "+s+". Should be in range [0.0, 1.0]");if(r<=0)throw new Error("Invalid nmsRadius "+r+".")}function zd(n){var e=n.segmentationThreshold,t=n.maxDetections,s=n.scoreThreshold,r=n.nmsRadius,o=n.minKeypointScore,a=n.refineSteps;if(e<0||e>1)throw new Error("segmentationThreshold "+e+". Should be in range [0.0, 1.0]");if(t<=0)throw new Error("Invalid maxDetections "+t+". Should be > 0");if(s<0||s>1)throw new Error("Invalid scoreThreshold "+s+". Should be in range [0.0, 1.0]");if(r<=0)throw new Error("Invalid nmsRadius "+r+".");if(o<0||o>1)throw new Error("Invalid minKeypointScore "+o+".Should be in range [0.0, 1.0]");if(a<=0||a>20)throw new Error("Invalid refineSteps "+a+".Should be in range [1, 20]")}var cy=function(){function n(e){this.baseModel=e}return n.prototype.predictForPersonSegmentation=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},n.prototype.predictForPersonSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,partHeatmapLogits:t.partHeatmaps,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},n.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,longOffsets:t.longOffsets,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd,partHeatmaps:t.partHeatmaps}},n.prototype.segmentPersonActivation=function(e,t,s){var r=this;s===void 0&&(s=.5);var o=Ss(e),a=o[0],i=o[1],u=yr(t,this.baseModel.outputStride,[a,i]),c=xr(e,u),l=c.resized,d=c.padding,p=U(function(){var b=r.predictForPersonSegmentation(l),$=b.segmentLogits,S=b.heatmapScores,N=b.offsets,E=b.displacementFwd,k=b.displacementBwd,R=l.shape,A=R[0],O=R[1],D=Wn($,[a,i],[A,O],[[d.top,d.bottom],[d.left,d.right]],!0);return{segmentation:mr(st(D),s),heatmapScores:S,offsets:N,displacementFwd:E,displacementBwd:k}}),h=p.segmentation,f=p.heatmapScores,g=p.offsets,m=p.displacementFwd,y=p.displacementBwd;return l.dispose(),{segmentation:h,heatmapScores:f,offsets:g,displacementFwd:m,displacementBwd:y,padding:d,internalResolutionHeightAndWidth:u}},n.prototype.segmentPerson=function(e,t){return t===void 0&&(t=$r),ne(this,void 0,void 0,function(){var s,r,o,a,i,u,c,l,d,p,h,f,g,m,y,b,$,S;return se(this,function(N){switch(N.label){case 0:return Ud(t=Ne(Ne({},$r),t)),s=this.segmentPersonActivation(e,t.internalResolution,t.segmentationThreshold),r=s.segmentation,o=s.heatmapScores,a=s.offsets,i=s.displacementFwd,u=s.displacementBwd,c=s.padding,l=s.internalResolutionHeightAndWidth,d=r.shape,p=d[0],h=d[1],[4,r.data()];case 1:return f=N.sent(),r.dispose(),[4,br([o,a,i,u])];case 2:return g=N.sent(),m=g[0],y=g[1],b=g[2],$=g[3],S=wr(S=gr(m,y,b,$,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[p,h],l,c,!1),o.dispose(),a.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:h,data:f,allPoses:S}]}})})},n.prototype.segmentMultiPerson=function(e,t){return t===void 0&&(t=vr),ne(this,void 0,void 0,function(){var s,r,o,a,i,u,c,l,d,p,h,f,g,m,y,b,$,S,N,E,k,R=this;return se(this,function(A){switch(A.label){case 0:return zd(t=Ne(Ne({},vr),t)),s=Ss(e),r=s[0],o=s[1],a=yr(t.internalResolution,this.baseModel.outputStride,[r,o]),i=xr(e,a),u=i.resized,c=i.padding,l=U(function(){var O,D=R.predictForMultiPersonInstanceSegmentationAndPart(u),V=D.segmentLogits,z=D.longOffsets,G=D.heatmapScores,j=D.offsets,q=D.displacementFwd,Q=D.displacementBwd,J=Wn(V,[r,o],a,[[c.top,c.bottom],[c.left,c.right]],!0);return O=z,{segmentation:mr(st(J),t.segmentationThreshold),longOffsets:O,heatmapScoresRaw:G,offsetsRaw:j,displacementFwdRaw:q,displacementBwdRaw:Q}}),d=l.segmentation,p=l.longOffsets,h=l.heatmapScoresRaw,f=l.offsetsRaw,g=l.displacementFwdRaw,m=l.displacementBwdRaw,[4,br([h,f,g,m])];case 1:return y=A.sent(),b=y[0],$=y[1],S=y[2],N=y[3],E=wr(E=gr(b,$,S,N,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,o],a,c,!1),[4,yN(d,p,E,r,o,this.baseModel.outputStride,a,c,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return k=A.sent(),u.dispose(),d.dispose(),p.dispose(),h.dispose(),f.dispose(),g.dispose(),m.dispose(),[2,k]}})})},n.prototype.segmentPersonPartsActivation=function(e,t,s){var r=this;s===void 0&&(s=.5);var o=Ss(e),a=o[0],i=o[1],u=yr(t,this.baseModel.outputStride,[a,i]),c=xr(e,u),l=c.resized,d=c.padding,p=U(function(){var b=r.predictForPersonSegmentationAndPart(l),$=b.segmentLogits,S=b.partHeatmapLogits,N=b.heatmapScores,E=b.offsets,k=b.displacementFwd,R=b.displacementBwd,A=l.shape,O=A[0],D=A[1],V=Wn($,[a,i],[O,D],[[d.top,d.bottom],[d.left,d.right]],!0),z=Wn(S,[a,i],[O,D],[[d.top,d.bottom],[d.left,d.right]],!0);return{partSegmentation:hN(mr(st(V),s),z),heatmapScores:N,offsets:E,displacementFwd:k,displacementBwd:R}}),h=p.partSegmentation,f=p.heatmapScores,g=p.offsets,m=p.displacementFwd,y=p.displacementBwd;return l.dispose(),{partSegmentation:h,heatmapScores:f,offsets:g,displacementFwd:m,displacementBwd:y,padding:d,internalResolutionHeightAndWidth:u}},n.prototype.segmentPersonParts=function(e,t){return t===void 0&&(t=$r),ne(this,void 0,void 0,function(){var s,r,o,a,i,u,c,l,d,p,h,f,g,m,y,b,$,S;return se(this,function(N){switch(N.label){case 0:return Ud(t=Ne(Ne({},$r),t)),s=this.segmentPersonPartsActivation(e,t.internalResolution,t.segmentationThreshold),r=s.partSegmentation,o=s.heatmapScores,a=s.offsets,i=s.displacementFwd,u=s.displacementBwd,c=s.padding,l=s.internalResolutionHeightAndWidth,d=r.shape,p=d[0],h=d[1],[4,r.data()];case 1:return f=N.sent(),r.dispose(),[4,br([o,a,i,u])];case 2:return g=N.sent(),m=g[0],y=g[1],b=g[2],$=g[3],S=wr(S=gr(m,y,b,$,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[p,h],l,c,!1),o.dispose(),a.dispose(),i.dispose(),u.dispose(),[2,{height:p,width:h,data:f,allPoses:S}]}})})},n.prototype.segmentMultiPersonParts=function(e,t){return t===void 0&&(t=vr),ne(this,void 0,void 0,function(){var s,r,o,a,i,u,c,l,d,p,h,f,g,m,y,b,$,S,N,E,k,R,A=this;return se(this,function(O){switch(O.label){case 0:return zd(t=Ne(Ne({},vr),t)),s=Ss(e),r=s[0],o=s[1],a=yr(t.internalResolution,this.baseModel.outputStride,[r,o]),i=xr(e,a),u=i.resized,c=i.padding,l=U(function(){var D=A.predictForMultiPersonInstanceSegmentationAndPart(u),V=D.segmentLogits,z=D.longOffsets,G=D.heatmapScores,j=D.offsets,q=D.displacementFwd,Q=D.displacementBwd,J=D.partHeatmaps,he=Wn(V,[r,o],a,[[c.top,c.bottom],[c.left,c.right]],!0),Fe=Wn(J,[r,o],a,[[c.top,c.bottom],[c.left,c.right]],!0),qe=z,pt=mr(st(he),t.segmentationThreshold),Xe=function(ht){var Ye=ht.shape,Qe=Ye[0],ln=Ye[1],ys=Ye[2];return U(function(){var dr=Jg(ht),od=Me(sn(0,ys,1,"int32"),1),rx=ee(Z(dr,od),"int32");return _(rx,[Qe,ln])})}(Fe);return{segmentation:pt,longOffsets:qe,heatmapScoresRaw:G,offsetsRaw:j,displacementFwdRaw:q,displacementBwdRaw:Q,partSegmentation:Xe}}),d=l.segmentation,p=l.longOffsets,h=l.heatmapScoresRaw,f=l.offsetsRaw,g=l.displacementFwdRaw,m=l.displacementBwdRaw,y=l.partSegmentation,[4,br([h,f,g,m])];case 1:return b=O.sent(),$=b[0],S=b[1],N=b[2],E=b[3],k=wr(k=gr($,S,N,E,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,o],a,c,!1),[4,xN(d,p,y,k,r,o,this.baseModel.outputStride,a,c,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return R=O.sent(),u.dispose(),d.dispose(),p.dispose(),h.dispose(),f.dispose(),g.dispose(),m.dispose(),y.dispose(),[2,R]}})})},n.prototype.dispose=function(){this.baseModel.dispose()},n}();function NN(n){return ne(this,void 0,void 0,function(){var e,t,s,r,o,a;return se(this,function(i){switch(i.label){case 0:if(e=n.outputStride,t=n.quantBytes,s=n.multiplier,jg==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=function(u,c,l){var d={1:"100",.75:"075",.5:"050"},p="model-stride"+u+".json";return l===4?Pd+"float/"+d[c]+"/"+p:Pd+"quant"+l+"/"+d[c]+"/"+p}(e,s,t),[4,Kl(n.modelUrl||r)];case 1:return o=i.sent(),a=new fN(o,e),[2,new cy(a)]}})})}function EN(n){return ne(this,void 0,void 0,function(){var e,t,s,r,o;return se(this,function(a){switch(a.label){case 0:if(e=n.outputStride,t=n.quantBytes,jg==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=function(i,u){var c="model-stride"+i+".json";return u===4?Dd+"float/"+c:Dd+"quant"+u+"/"+c}(e,t),[4,Kl(n.modelUrl||s)];case 1:return r=a.sent(),o=new CN(r,e),[2,new cy(o)]}})})}function IN(n){return n===void 0&&(n=Ld),ne(this,void 0,void 0,function(){return se(this,function(e){return(n=function(t){if((t=t||Ld).architecture==null&&(t.architecture="MobileNetV1"),Bd.indexOf(t.architecture)<0)throw new Error("Invalid architecture "+t.architecture+". Should be one of "+Bd);if(t.outputStride==null&&(t.outputStride=16),Vd[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride "+t.outputStride+". Should be one of "+Vd[t.architecture]+" for architecture "+t.architecture+".");if(t.multiplier==null&&(t.multiplier=1),Md[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier "+t.multiplier+". Should be one of "+Md[t.architecture]+" for architecture "+t.architecture+".");if(t.quantBytes==null&&(t.quantBytes=4),Wd.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes "+t.quantBytes+". Should be one of "+Wd+" for architecture "+t.architecture+".");return t}(n)).architecture==="ResNet50"?[2,EN(n)]:n.architecture==="MobileNetV1"?[2,NN(n)]:[2,null]})})}var Ra=["left_face","right_face","left_upper_arm_front","left_upper_arm_back","right_upper_arm_front","right_upper_arm_back","left_lower_arm_front","left_lower_arm_back","right_lower_arm_front","right_lower_arm_back","left_hand","right_hand","torso_front","torso_back","left_upper_leg_front","left_upper_leg_back","right_upper_leg_front","right_upper_leg_back","left_lower_leg_front","left_lower_leg_back","right_lower_leg_front","right_lower_leg_back","left_feet","right_feet"],Gd=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,ql(this.mask)]})})},n.prototype.toImageData=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,this.mask]})})},n.prototype.toTensor=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,Zg(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"imagedata"},n}();function kN(n){if(Io(n),n!==255)throw new Error("Foreground id must be 255 but got "+n);return"person"}function RN(n){if(Io(n),n>=Ra.length)throw new Error("Invalid body part value "+n);return Ra[n]}var _N=function(){function n(e){this.bodyPixModel=e}return n.prototype.segmentPeople=function(e,t){return ne(this,void 0,void 0,function(){var s,r,o,a;return se(this,function(i){switch(i.label){case 0:return e instanceof ImageBitmap&&((s=document.createElement("canvas")).getContext("2d").drawImage(e,0,0),e=s),t.segmentBodyParts?t.multiSegmentation?[4,this.bodyPixModel.segmentMultiPersonParts(e,t)]:[3,2]:[3,5];case 1:return o=i.sent(),[3,4];case 2:return[4,this.bodyPixModel.segmentPersonParts(e,t)];case 3:o=[i.sent()],i.label=4;case 4:return r=o.map(function(u){var c=u.data,l=u.width,d=u.height,p=new Uint8ClampedArray(l*d*4).fill(0);return c.forEach(function(h,f){h===-1?(p[4*f]=Ra.length,p[4*f+3]=0):(p[4*f]=h,p[4*f+3]=255)}),{maskValueToLabel:RN,mask:new Gd(new ImageData(p,l,d))}}),[3,10];case 5:return t.multiSegmentation?[4,this.bodyPixModel.segmentMultiPerson(e,t)]:[3,7];case 6:return a=i.sent(),[3,9];case 7:return[4,this.bodyPixModel.segmentPerson(e,t)];case 8:a=[i.sent()],i.label=9;case 9:r=a.map(function(u){var c=u.data,l=u.width,d=u.height,p=new Uint8ClampedArray(l*d*4).fill(0);return c.forEach(function(h,f){h===0?(p[4*f]=0,p[4*f+3]=0):(p[4*f]=255,p[4*f+3]=255)}),{maskValueToLabel:kN,mask:new Gd(new ImageData(p,l,d))}}),i.label=10;case 10:return[2,r]}})})},n.prototype.dispose=function(){this.bodyPixModel.dispose()},n.prototype.reset=function(){},n}();function AN(n){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,IN(n).then(function(t){return new _N(t)})]})})}var Hd={runtime:"mediapipe",modelType:"general"},ON=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,Qg(this.mask)]})})},n.prototype.toTensor=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,Zg(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function DN(n){return Io(n),"person"}var PN=function(){function n(e){var t,s=this;this.selfieMode=!1,this.selfieSegmentationSolution=new ix.SelfieSegmentation({locateFile:function(r,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+r:o+"/"+r}}),e.modelType==="landscape"?t=1:t=0,this.selfieSegmentationSolution.setOptions({modelSelection:t,selfieMode:this.selfieMode}),this.selfieSegmentationSolution.onResults(function(r){s.segmentation=[{maskValueToLabel:DN,mask:new ON(r.segmentationMask)}]})}return n.prototype.segmentPeople=function(e,t){return ne(this,void 0,void 0,function(){var s,r;return se(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.selfieSegmentationSolution.setOptions({selfieMode:this.selfieMode})),e instanceof te?(r=ImageData.bind,[4,To(e)]):[3,2];case 1:return s=new(r.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,o.label=3;case 3:return e=s,[4,this.selfieSegmentationSolution.send({image:e})];case 4:return o.sent(),[2,this.segmentation]}})})},n.prototype.dispose=function(){this.selfieSegmentationSolution.close()},n.prototype.reset=function(){this.selfieSegmentationSolution.reset(),this.segmentation=null,this.selfieMode=!1},n.prototype.initialize=function(){return this.selfieSegmentationSolution.initialize()},n}();function FN(n){return ne(this,void 0,void 0,function(){var e,t;return se(this,function(s){switch(s.label){case 0:return e=function(r){if(r==null)return Ne({},Hd);var o=Ne({},r);return o.runtime="mediapipe",o.modelType==null&&(o.modelType=Hd.modelType),o}(n),[4,(t=new PN(e)).initialize()];case 1:return s.sent(),[2,t]}})})}function LN(n,e,t,s){var r=n.width,o=n.height,a=s?-1:1,i=Math.cos(n.rotation),u=Math.sin(n.rotation),c=n.xCenter,l=n.yCenter,d=1/e,p=1/t,h=new Array(16);return h[0]=r*i*a*d,h[1]=-o*u*d,h[2]=0,h[3]=(-.5*r*i*a+.5*o*u+c)*d,h[4]=r*u*a*p,h[5]=o*i*p,h[6]=0,h[7]=(-.5*o*i-.5*r*u*a+l)*p,h[8]=0,h[9]=0,h[10]=r*d,h[11]=0,h[12]=0,h[13]=0,h[14]=0,h[15]=1,function(f){if(f.length!==16)throw new Error("Array length must be 16 but got "+f.length);return[[f[0],f[1],f[2],f[3]],[f[4],f[5],f[6],f[7]],[f[8],f[9],f[10],f[11]],[f[12],f[13],f[14],f[15]]]}(h)}function ly(n){return n instanceof te?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function Ho(n,e){v(n.width!==0,function(){return e+" width cannot be 0."}),v(n.height!==0,function(){return e+" height cannot be 0."})}function BN(n,e){var t=function(s,r,o,a){var i=r-s,u=a-o;if(i===0)throw new Error("Original min and max are both "+s+", range cannot be 0.");var c=u/i;return{scale:c,offset:o-s*c}}(0,255,e[0],e[1]);return U(function(){return W(L(n,t.scale),t.offset)})}function VN(n,e,t){var s=e.outputTensorSize,r=e.keepAspectRatio,o=e.borderMode,a=e.outputTensorFloatRange,i=ly(n),u=function(p,h){return h?{xCenter:h.xCenter*p.width,yCenter:h.yCenter*p.height,width:h.width*p.width,height:h.height*p.height,rotation:h.rotation}:{xCenter:.5*p.width,yCenter:.5*p.height,width:p.width,height:p.height,rotation:0}}(i,t),c=function(p,h,f){if(f===void 0&&(f=!1),!f)return{top:0,left:0,right:0,bottom:0};var g=h.height,m=h.width;Ho(h,"targetSize"),Ho(p,"roi");var y,b,$=g/m,S=p.height/p.width,N=0,E=0;return $>S?(y=p.width,b=p.width*$,E=(1-S/$)/2):(y=p.height/$,b=p.height,N=(1-$/S)/2),p.width=y,p.height=b,{top:E,left:N,right:N,bottom:E}}(u,s,r),l=LN(u,i.width,i.height,!1),d=U(function(){var p,h=(p=n)instanceof te?p:No(p),f=$n(function(y,b,$){return Ho($,"inputResolution"),[1/$.width*y[0][0]*b.width,1/$.height*y[0][1]*b.width,y[0][3]*b.width,1/$.width*y[1][0]*b.height,1/$.height*y[1][1]*b.height,y[1][3]*b.height,0,0]}(l,i,s),[1,8]),g=o==="zero"?"constant":"nearest",m=In.transform(Me(ee(h,"float32")),f,"bilinear",g,0,[s.height,s.width]);return a!=null?BN(m,a):m});return{imageTensor:d,padding:c,transformationMatrix:l}}function MN(n,e,t){return U(function(){var s=st(n,[0]),r=s.shape[2];if(r===1){var o=s;switch(e.activation){case"none":break;case"sigmoid":o=Tt(o);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+e.activation+")")}var a=t?In.resizeBilinear(o,[t.height,t.width]):o;return st(a,[2])}throw new Error("Unsupported number of tensor channels "+r)})}var jd={runtime:"tfjs",modelType:"general",modelUrl:"https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1"},Kd={flipHorizontal:!1},WN={outputTensorSize:{width:256,height:256},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},UN={outputTensorSize:{width:256,height:144},keepAspectRatio:!1,borderMode:"zero",outputTensorFloatRange:[0,1]},zN={activation:"none"},GN=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,ql(this.mask)]})})},n.prototype.toImageData=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,Qg(this.mask)]})})},n.prototype.toTensor=function(){return ne(this,void 0,void 0,function(){return se(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function HN(n){return Io(n),"person"}var Qr,jN=function(){function n(e,t){this.modelType=e,this.model=t}return n.prototype.segmentPeople=function(e,t){return ne(this,void 0,void 0,function(){var s,r=this;return se(this,function(o){return t=function(a){if(a==null)return Ne({},Kd);var i=Ne({},a);return i.flipHorizontal==null&&(i.flipHorizontal=Kd.flipHorizontal),i}(t),e==null?(this.reset(),[2,[]]):(s=U(function(){var a=VN(e,r.modelType==="general"?WN:UN).imageTensor,i=re(r.model.predict(a),[0,0,0,1],-1),u=ly(e),c=MN(i,zN,u),l=Me(c,2),d=Fn(l,[[0,0],[0,0],[0,1]]);return il(d,[[0,0],[0,0],[0,2]],"symmetric")}),[2,[{maskValueToLabel:HN,mask:new GN(s)}]])})})},n.prototype.dispose=function(){this.model.dispose()},n.prototype.reset=function(){},n}();function KN(n){return ne(this,void 0,void 0,function(){var e,t,s;return se(this,function(r){switch(r.label){case 0:return e=function(o){if(o==null)return Ne({},jd);var a=Ne({},o);if(a.runtime="tfjs",a.modelType==null&&(a.modelType=jd.modelType),a.modelType!=="general"&&a.modelType!=="landscape")throw new Error("Model type must be one of general or landscape, but got "+a.modelType);return a.modelUrl==null&&(a.modelType==="general"?a.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/general/1":a.modelUrl="https://tfhub.dev/mediapipe/tfjs-model/selfie_segmentation/landscape/1"),a}(n),t=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Kl(e.modelUrl,{fromTFHub:t})];case 1:return s=r.sent(),[2,new jN(e.modelType,s)]}})})}function HB(n,e){return ne(this,void 0,void 0,function(){var t,s;return se(this,function(r){switch(n){case Qr.MediaPipeSelfieSegmentation:if(t=void 0,(s=e)!=null){if(s.runtime==="tfjs")return[2,KN(s)];if(s.runtime==="mediapipe")return[2,FN(s)];t=s.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+t);case Qr.BodyPix:return[2,AN(s=e)];default:throw new Error(n+" is not a supported model name.")}})})}(function(n){n.BodyPix="BodyPix",n.MediaPipeSelfieSegmentation="MediaPipeSelfieSegmentation"})(Qr||(Qr={}));function qN(n,e,t,s,r,o){o===void 0&&(o={r:0,g:255,b:255,a:255});for(var a=-r;a<=r;a++)for(var i=-r;i<=r;i++)if(a!==0&&i!==0){var u=(e+a)*s+(t+i);n[4*u+0]=o.r,n[4*u+1]=o.g,n[4*u+2]=o.b,n[4*u+3]=o.a}}function XN(n,e,t,s,r,o,a){a===void 0&&(a=1);for(var i=0,u=-a;u<=a;u++)for(var c=-a;c<=a;c++)if(u!==0&&c!==0){var l=(e+u)*s+(t+c);(!r[n[4*l]]||n[4*l+3]<o)&&(i+=1)}return i>0}function jB(n,e,t,s,r,o){return e===void 0&&(e={r:0,g:0,b:0,a:0}),t===void 0&&(t={r:0,g:0,b:0,a:255}),s===void 0&&(s=!1),r===void 0&&(r=.5),o===void 0&&(o=Array.from(Array(256).keys())),ne(this,void 0,void 0,function(){var a,i,u,c,l,d,p,h,f,g,m,y,b,$;return se(this,function(S){switch(S.label){case 0:return(a=Array.isArray(n)?n:[n]).length===0?[2,null]:[4,Promise.all(a.map(function(N){return N.mask.toImageData()}))];case 1:for(i=S.sent(),u=i[0],c=u.width,l=u.height,d=new Uint8ClampedArray(c*l*4),p=Math.round(255*r),h=new Array(256).fill(!1),o.forEach(function(N){return h[N]=!0}),f=0;f<l;f++)for(g=0;g<c;g++)for(d[4*(m=f*c+g)+0]=t.r,d[4*m+1]=t.g,d[4*m+2]=t.b,d[4*m+3]=t.a,y=0,b=i;y<b.length;y++)$=b[y],h[$.data[4*m]]&&$.data[4*m+3]>=p&&(d[4*m]=e.r,d[4*m+1]=e.g,d[4*m+2]=e.b,d[4*m+3]=e.a,s&&f-1>=0&&f+1<l&&g-1>=0&&g+1<c&&XN($.data,f,g,c,h,p)&&qN(d,f,g,c,1));return[2,new ImageData(d,c,l)]}})})}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gn={},Sr={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function YN(n,e){gn[n]=e}function $t(n,e){if(!(n in gn)||e!=null){const s=ZN(n,e);if(s!==null)gn[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=gn[n];return t==null||t.isContextLost()?(delete gn[n],$t(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),gn[n])}function QN(n){if(!I().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function ZN(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??QN(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete gn[n]},!1),I().getBool("SOFTWARE_WEBGL_ENABLED")&&(Sr.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Sr)||t.getContext("experimental-webgl",Sr):t.getContext("webgl2",Sr)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Gs;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Gs||(Gs={}));var He;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(He||(He={}));var we;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(we||(we={}));function ar(n,e){return[e,n]}function JN(n,e){return n*e}function Cr(n){const e=P(n),t=Math.ceil(e/4);return Pr(t)}function cs(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function e2(n,e){const[t,s]=cs(n,e);return t*s*4}function Yl(n,e){const t=n;let s,r,o,a,i,u,c,l,d,p;return I().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,a=t.RGBA32F,i=t.RED,c=4,l=1,d=t.HALF_FLOAT,p=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,a=t.RGBA,i=n.RGBA,c=4,l=4,d=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B(n,e){const t=e();return I().getBool("DEBUG")&&t2(n),t}function t2(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+o2(n,e))}const n2=596e-10,s2=65504;function r2(n){return!!(I().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||n2<Math.abs(n)&&Math.abs(n)<s2)}function o2(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Tr(n,e){return Ht(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function a2(n,e){const t=Ht(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(B(n,()=>n.shaderSource(t,e)),B(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function i2(n,e){const t=Ht(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(B(n,()=>n.shaderSource(t,e)),B(n,()=>n.compileShader(t)),I().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw dy(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const u2=/ERROR: [0-9]+:([0-9]+):/g;function dy(n,e){const t=u2.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,a=r.map((d,p)=>xn((p+1).toString(),o)+d);let i=0;for(let d=0;d<a.length;d++)i=Math.max(a[d].length,i);const u=a.slice(0,s-1),c=a.slice(s-1,s),l=a.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${xn(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function c2(n){return Ht(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function l2(n,e){if(B(n,()=>n.linkProgram(e)),!I().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function jo(n,e){if(B(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function d2(n,e){const t=Ht(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return B(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),B(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function p2(n,e){const t=Ht(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return B(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),B(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function h2(n){return Ht(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function f2(n,e){const t=I().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function m2(n){return Ht(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function qd(n,e,t,s,r,o,a){const i=n.getAttribLocation(e,t);return i===-1?!1:(B(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),B(n,()=>n.vertexAttribPointer(i,r,n.FLOAT,!1,o,a)),B(n,()=>n.enableVertexAttribArray(i)),!0)}function g2(n,e,t){$2(n,t),B(n,()=>n.activeTexture(n.TEXTURE0+t)),B(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function y2(n,e,t){return Ht(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function x2(n,e,t){return n.getUniformLocation(e,t)}function b2(n,e,t,s){B(n,()=>g2(n,e,s)),B(n,()=>n.uniform1i(t,s))}function Ko(n,e,t){B(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),B(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Xd(n,e){B(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),B(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Nr(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+w2(n,e))}function w2(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Ht(n,e,t){const s=B(n,()=>e());if(s==null)throw new Error(t);return s}function $2(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ns(n,e=2){return P(n.slice(0,n.length-e))}function ss(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Er(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ns(n),...ss(n)]),e}function v2(n,e=!1){let t=I().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=I().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&I().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((i,u)=>u>=n.length-2?so(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=zt(n).newShape);let r=P(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const a=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||a)if(e){const i=ns(n);let u=2,c=2;n.length&&([u,c]=ss(n)),r=i*(u/2)*(c/2),o=Pr(r).map(l=>l*2)}else o=Pr(r);return o}function Ir(n){return n%2===0}function Zr(n,e){if(n=n.slice(-2),e=e.slice(-2),ce(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Ir(t)&&Ir(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Ir(n[0])&&Ir(e[0])}let qo,Xo;function S2(n){if(qo==null){const e=$t(n);qo=e.getParameter(e.MAX_TEXTURE_SIZE)}return qo}function C2(n){if(Xo==null){const e=$t(n);Xo=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Xo)}function T2(n){if(n===0)return 0;let e;const t=$t(n);return ot(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:ot(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ot(n,e){return n.getExtension(e)!=null}function Yd(n){try{if($t(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function N2(n){if(n===0)return!1;const e=$t(n);if(n===1){if(!ot(e,"OES_texture_float"))return!1}else if(!ot(e,"EXT_color_buffer_float"))return!1;return _a(e)}function E2(n){if(n===0)return!1;const e=$t(n);if(n===1){if(!ot(e,"OES_texture_float")||!ot(e,"WEBGL_color_buffer_float"))return!1}else{if(ot(e,"EXT_color_buffer_float"))return _a(e);const s="EXT_color_buffer_half_float";if(ot(e,s)){const r=e.getExtension(s);return I2(e,r)}return!1}return _a(e)}function _a(n){const e=Yl(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),a}function I2(n,e){const t=Yl(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const r=1,o=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),i}function k2(n){return n!==2?!1:$t(n).fenceSync!=null}function ir(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&v(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M=I();M.registerFlag("HAS_WEBGL",()=>M.getNumber("WEBGL_VERSION")>0);M.registerFlag("WEBGL_VERSION",()=>Yd(2)?2:Yd(1)?1:0);M.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);M.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>M.get("WEBGL_VERSION")===2);M.registerFlag("WEBGL_CPU_FORWARD",()=>!0);M.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);M.registerFlag("WEBGL_PACK",()=>M.getBool("HAS_WEBGL"));M.registerFlag("WEBGL_PACK_NORMALIZATION",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_CLIP",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_PACK_REDUCE",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_LAZILY_UNPACK",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_CONV_IM2COL",()=>M.getBool("WEBGL_PACK"));M.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>S2(M.getNumber("WEBGL_VERSION")));M.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>C2(M.getNumber("WEBGL_VERSION")));M.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=M.getNumber("WEBGL_VERSION");return n===0?0:T2(n)});M.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>M.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Oc());M.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>N2(M.getNumber("WEBGL_VERSION")));M.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>M.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:M.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));M.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>E2(M.getNumber("WEBGL_VERSION")));M.registerFlag("WEBGL_FENCE_API_ENABLED",()=>k2(M.getNumber("WEBGL_VERSION")));M.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>M.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);M.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});M.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Oc()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});M.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);M.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);M.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);M.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);M.registerFlag("WEBGL_EXP_CONV",()=>!1);M.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>M.getBool("IS_TEST"));M.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);M.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);M.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);M.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oe(){let n,e,t,s,r,o,a,i,u,c;return I().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",a="out vec4 outputColor;",i=I().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ln(n,e,t="index"){const s=xe(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${r}`,i=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${a}; ${i};`}).join("")}function Ro(n,e,t="index"){const s=xe(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,i=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function R2(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function _2(n,e,t="index"){const s=n.map((o,a)=>a),r=R2(s,e);return r.map((o,a)=>{const i=`int ${n[a]} = ${t} / ${r[a]}`,u=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${i}; ${u};`}).join("")}function Ql(n){const e=xe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Zl(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const py=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:hy}=Hg;function A2(n,e,t){const s=[];if(n.forEach(h=>{const f=P(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?s.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${h.name};`),s.push(`uniform int offset${h.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Jl(t.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${h.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${h.name}Shape;`);break}s.push(`uniform ivec2 ${h.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(h=>{s.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(h=>O2(h,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=Oe(),u=F2(i);let c,l,d=V2(i);return e.isPacked?(c=D2(e.logicalShape,a,t.enableShapeUniforms),l=B2(i)):(c=P2(e.logicalShape,a,t.enableShapeUniforms),l=L2(i)),t.packedInputs&&(d+=z2),[d,u,l,r,c,o,t.userCode].join(`
`)}function ls(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return tE(n,e);case 1:return sE(n,e);case 2:return oE(n,e);case 3:return iE(n,e);case 4:return cE(n,e);case 5:return lE(n);case 6:return dE(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function fy(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return eE(n);case 1:return nE(n,e);case 2:return rE(n,e);case 3:return aE(n,e);default:return uE(n,e)}}function O2(n,e,t=!1,s){let r="";t?r+=fy(n,s):r+=ls(n,s);const o=n.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(t?r+=pE(n,e):r+=hE(n,e)),r}function D2(n,e,t){switch(n.length){case 0:return my();case 1:return G2(n,e,t);case 2:return Z2(n,e,t);case 3:return j2(n,e,t);default:return q2(n,e,t)}}function P2(n,e,t){switch(n.length){case 0:return my();case 1:return H2(n,e,t);case 2:return J2(n,e,t);case 3:return K2(n,e,t);case 4:return X2(n,e,t);case 5:return Y2(n,e);case 6:return Q2(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function F2(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function L2(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function B2(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function V2(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${M2}
    ${W2}
    ${U2}
  `}const M2=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,W2=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,U2=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,z2=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function my(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function G2(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function H2(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function j2(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function K2(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ro(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Ln(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function q2(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let a=o,i="",u="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],i=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+i,u=`b${c}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function X2(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ro(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Ln(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Y2(n,e){const t=Ln(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Q2(n,e){const t=Ln(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Z2(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ce(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function J2(n,e,t){return ce(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Bn(n){return`offset${n}`}function eE(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Oe();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function tE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Bn(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[i,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function nE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=Oe();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function sE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${ds(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],a=r[1];if(a===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Bn(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function rE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=o[0],i=o[1],u=Oe();if(o!=null&&ce(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function oE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&ce(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=o[0],h=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:i}=zt(t),u=a;if(u.length<t.length){const p=ps(n,u),h=["row","col"];return`
      ${ls(p,e)}
      float ${r}(int row, int col) {
        return ${r}(${hs(h,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${ds(n)}
      }
    `;const c=o[0],l=o[1],d=Bn(s);return l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${l}, index);
    return sampleTexture(${s}, uv);
  }
`}function aE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const p=t.slice(1),h=[1,2],f=ps(n,p),g=["b","row","col"];return`
        ${fy(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${hs(g,h)});
        }
      `}const i=Oe();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `;const u=a[0],c=a[1],l=Math.ceil(t[2]/2),d=l*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${d}, ${l}, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `}function iE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=zt(t),c=i;if(c.length<t.length){const g=ps(n,c),m=["row","col","depth"];return`
        ${ls(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${hs(m,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${ds(n)}
      }
    `;const l=n.shapeInfo.texShape,d=l[0],p=l[1],h=n.shapeInfo.flatOffset;if(p===o&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===a&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Bn(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function uE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Oe();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,a=o.length,i=n.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=u[0],l=u[1],d=Math.ceil(o[a-1]/2);let p=d*Math.ceil(o[a-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<a-1;g++)h=`int b${g}, `+h,p*=o[a-g-1],f=`b${g} * ${p} + `+f;return`
    vec4 ${s}(${h}) {
      int index = ${f};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function cE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],a=t[2]*o,i=t[1]*a,{newShape:u,keptDims:c}=zt(t);if(u.length<t.length){const b=ps(n,u),$=["row","col","depth","depth2"];return`
      ${ls(b,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${hs($,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${ds(n)}
      }
    `;const l=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],h=d[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(h===i&&l==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(h===o&&l==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=Bn(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function lE(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,a=e[2]*o,i=e[1]*a,{newShape:u,keptDims:c}=zt(e);if(u.length<e.length){const g=ps(n,u),m=["row","col","depth","depth2","depth3"];return`
      ${ls(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${hs(m,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${r})) +
          depth3;
        ${ds(n)}
      }
    `;const l=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&l==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(h===r&&l==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Bn(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${t}, uv);
    }
  `}function dE(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=zt(e);if(r.length<e.length){const m=ps(n,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${ls(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${hs(y,o)});
      }
    `}const a=e[5],i=e[4]*a,u=e[3]*i,c=e[2]*u,l=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${c}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${ds(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,h=p[0],f=p[1];if(f===l&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Bn(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${c} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function ds(n){const e=n.name,t=P(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function pE(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=hy(n.shapeInfo.logicalShape,e.logicalShape),u=oe(a),c=a-o;let l;const d=["x","y","z","w","u","v"];o===0?l="":a<2&&i.length>=1?l="coords = 0;":l=i.map(b=>`coords.${d[b+c]} = 0;`).join(`
`);let p="";a<2&&o>0?p="coords":p=n.shapeInfo.logicalShape.map((b,$)=>`coords.${d[$+c]}`).join(", ");let h="return outputValue;";const g=P(n.shapeInfo.logicalShape)===1,y=P(e.logicalShape)===1;if(o===1&&!g&&!y)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)a===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){const b=o-2,$=o-1;i.indexOf(b)>-1&&i.indexOf($)>-1?h="return vec4(outputValue.x);":i.indexOf(b)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf($)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${s}(${p});
      ${h}
    }
  `}function hE(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,a=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&i===u&&n.shapeInfo.flatOffset==null&&ce(a,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=oe(u),l=hy(n.shapeInfo.logicalShape,e.logicalShape),d=u-i;let p;const h=["x","y","z","w","u","v"];i===0?p="":u<2&&l.length>=1?p="coords = 0;":p=l.map(g=>`coords.${h[g+d]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((g,m)=>`coords.${h[m+d]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${f});
    }
  `}function oe(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Jl(n,e,t){const{newShape:s,keptDims:r}=zt(e),o=e.length,a=n&&o===3&&e[0]===1,i=a?e.slice(1):s,u=!n&&o>1&&!ce(e,t)&&s.length<o||a;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:r}}function ps(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function hs(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(n,e,t,s){const r=t.map((l,d)=>{const p={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(p.flatOffset=l.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:p}}),o=r.map(l=>l.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},i=A2(r,a,e),u=i2(n.gl,i),c=n.createProgram(u);return I().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:o,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:o,outShapeInfo:a},gy(n,e,c)))}function gy(n,e,t){const s=[],r=[];let o,a,i,u=null,c=null;c=n.getUniformLocation(t,"NAN",!1),I().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const l=!1;for(const d of e.variableNames){const p={name:d,uniform:n.getUniformLocation(t,d,l),offset:n.getUniformLocation(t,`offset${d}`,l)};e.enableShapeUniforms&&(p.shape=n.getUniformLocation(t,`${d}Shape`,l),p.texShape=n.getUniformLocation(t,`${d}TexShape`,l)),s.push(p)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",l),i=n.getUniformLocation(t,"outShapeStrides",l),a=n.getUniformLocation(t,"outTexShape",l)),e.customUniforms)for(const d of e.customUniforms)r.push(n.getUniformLocation(t,d.name,l));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:a}}function Qd(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],a=o.shape;if(!ce(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&o.isUniform)return;const i=t.texShape,u=o.isUniform?null:o.texData.texShape;if(!ce(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function mE(n,e,t,s,r){e.program.enableShapeUniforms||(Qd(e.inShapeInfos,t),Qd([e.outShapeInfo],[s]));const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,a[0],a[1]):n.setOutputMatrixTexture(o.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),I().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const c=t[u],{uniform:l,offset:d,shape:p,texShape:h}=e.variablesLocations[u];if(p){const{uniformShape:f}=Jl(e.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(p,new Int32Array(f));break;case 2:n.gl.uniform2iv(p,new Int32Array(f));break;case 3:n.gl.uniform3iv(p,new Int32Array(f));break;case 4:n.gl.uniform4iv(p,new Int32Array(f));break}}if(h&&n.gl.uniform2i(h,c.texData.texShape[0],c.texData.texShape[1]),l!=null){if(c.isUniform){if(P(c.shape)<2)n.gl.uniform1f(l,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(l,f)}continue}c.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,l,u)}}const i=e.outShapeLocation;if(i)switch(s.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=xe(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const c=e.program.customUniforms[u],l=e.customUniformLocations[u],d=r[u];if(c.type==="float")n.gl.uniform1fv(l,d);else if(c.type==="vec2")n.gl.uniform2fv(l,d);else if(c.type==="vec3")n.gl.uniform3fv(l,d);else if(c.type==="vec4")n.gl.uniform4fv(l,d);else if(c.type==="int")n.gl.uniform1iv(l,d);else if(c.type==="ivec2")n.gl.uniform2iv(l,d);else if(c.type==="ivec3")n.gl.uniform3iv(l,d);else if(c.type==="ivec4")n.gl.uniform4iv(l,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function gE(n,e,t){let s="";e.concat(t).forEach(a=>{const i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:d}=Jl(n.packedInputs,a.shape,u);let p="",h="",f="";if(l.length===1&&n.packedInputs){const N=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];p=`${N[0]>1}_${N[1]>1}`}else if(l.length===2&&!n.packedInputs)h=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!n.packedInputs){const N=xe(l);f=`${N[0]===u[1]}_${N[N.length-1]===u[1]}`}const g=a.shape.length,m=l.length===2&&ce(a.shape,u),y=P(a.shape)===1,b=Ls(a.shape,t.shape),$=!n.packedInputs&&g===t.shape.length&&ce(u,t.texData.texShape),S=n.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${g}_${$}_${c?d:""}_${l.length}_${y}_${b}_${m}_${p}_${h}_${f}_${S}_${i}`}else{const u=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${u}_${i}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${I().getNumber("WEBGL_VERSION")}`,o}function Te(n){return I().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yE{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Gs.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Oe();this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ro(["r","c","d"],e):Ln(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Gs.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Oe();this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ro(["r","c","d"],e):Ln(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bE{constructor(e){this.variableNames=["A"],this.outTexUsage=He.DOWNLOAD;const t=Oe();this.outputShape=e,this.userCode=`
      ${py}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=He.DOWNLOAD;const t=Oe();this.outputShape=e,this.userCode=`
      ${py}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $E={R:0,G:1,B:2,A:3};class Zd{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Oe();this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let a="";for(let i=0;i<s.length;i++){const u=s[i];a+=`
          if(offset == ${i}) {
            result = values[${$E[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Zl():Ql(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vE{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Oe();this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const u=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Zl():Ql(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n){const e=Oe(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return a2(n,t)}function CE(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return d2(n,e)}function TE(n){const e=new Uint16Array([0,1,2,2,1,3]);return p2(n,e)}function ur(n,e,t,s,r,o){f2(e,t);const a=h2(n),i=n.TEXTURE_2D;return B(n,()=>n.bindTexture(i,a)),B(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),B(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),B(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),B(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),I().getNumber("WEBGL_VERSION")===1?B(n,()=>n.texImage2D(i,0,s,e,t,0,r,o,null)):B(n,()=>n.texStorage2D(i,1,s,e,t)),B(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function yy(n){return n.internalFormatFloat}function NE(n,e,t,s){const[r,o]=ar(e,t);return ur(n,r,o,yy(s),s.textureFormatFloat,n.FLOAT)}function xy(n){return n.internalFormatHalfFloat}function EE(n,e,t,s){const[r,o]=ar(e,t);return ur(n,r,o,xy(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function by(n){return n.downloadTextureFormat}function IE(n,e,t,s){const[r,o]=ar(e,t);return ur(n,r,o,by(s),n.RGBA,n.UNSIGNED_BYTE)}function wy(n){return n.internalFormatPackedFloat}function kE(n,e,t,s){const[r,o]=cs(e,t);return ur(n,r,o,wy(s),n.RGBA,n.FLOAT)}function $y(n){return n.internalFormatPackedHalfFloat}function RE(n,e,t,s){const[r,o]=cs(e,t);return ur(n,r,o,$y(s),n.RGBA,s.textureTypeHalfFloat)}function _E(n,e,t){return B(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),qd(n,e,"clipSpacePos",t,3,20,0)&&qd(n,e,"uv",t,2,20,12)}function AE(n,e,t,s,r,o){B(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,i,u;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),i=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(t*s*4),i=n.FLOAT,u=o.internalFormatPackedFloat),a.set(r),I().getNumber("WEBGL_VERSION")===2?B(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,i,a)):B(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,i,a)),B(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function OE(n,e,t){B(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?I().getNumber("WEBGL_VERSION")===2?B(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):B(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):I().getNumber("WEBGL_VERSION")===2?B(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):B(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),B(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function DE(n,e,t,s){const r=n.createBuffer();B(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const i=4*4*e*t;return B(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),B(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),B(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function PE(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function FE(n,e,t,s){const[r,o]=ar(e,t),a=4,i=new Uint8Array(JN(e*t,a));return B(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function LE(n,e,t,s,r,o,a,i){const u=n,c=new Float32Array(e2(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function BE(n,e,t){const s=new Float32Array(e*t*4);return B(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yo{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=I().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,YN(t,e)):this.gl=$t(t),e=this.gl,I().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>B(o,()=>o.createVertexArray()),this.bindVertexArray=a=>B(o,()=>o.bindVertexArray(a)),this.deleteVertexArray=a=>B(o,()=>o.deleteVertexArray(a)),this.getVertexArray=()=>B(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>B(e,()=>o.createVertexArrayOES()),this.bindVertexArray=a=>B(e,()=>o.bindVertexArrayOES(a)),this.deleteVertexArray=a=>B(e,()=>o.deleteVertexArrayOES(a)),this.getVertexArray=()=>B(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),I().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Tr(this.gl,o),ot(this.gl,a))this.textureHalfFloatExtension=Tr(this.gl,a);else if(I().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ot(this.gl,r))this.colorBufferHalfFloatExtension=Tr(this.gl,r);else if(I().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ot(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ot(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=CE(this.gl),this.indexBuffer=TE(this.gl),this.framebuffer=m2(this.gl),this.textureConfig=Yl(this.gl,this.textureHalfFloatExtension)}get debug(){return I().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;B(e,()=>e.finish()),B(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),B(e,()=>e.deleteFramebuffer(this.framebuffer)),B(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),B(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),B(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),NE(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),EE(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),IE(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),OE(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),AE(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),RE(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),kE(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Xd(this.gl,this.framebuffer),this.outputTexture=null),B(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>FE(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,a){return LE(this.gl,e,t,s,r,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return PE(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=DE(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(I().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(o,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=o}else I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>BE(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=SE(t));const s=c2(t);B(t,()=>t.attachShader(s,this.vertexShader)),B(t,()=>t.attachShader(s,e)),l2(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&jo(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;B(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),_E(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(B(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&jo(this.gl,this.program),B(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?y2(this.gl,e,t):x2(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),B(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),b2(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=cs(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&jo(this.gl,this.program),Nr(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}B(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),B(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Tr(this.gl,I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Zo(()=>this.disposed||this.isQueryAvailable(e,I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=VE(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in I().platform&&(s=I().platform.setTimeoutCustom.bind(I().platform)),Zo(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ko(this.gl,e,this.framebuffer),this.debug&&Nr(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ko(this.gl,this.outputTexture,this.framebuffer),this.debug&&Nr(this.gl)):Xd(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;Ko(r,e,this.framebuffer),this.debug&&Nr(r),this.outputTexture=e,B(r,()=>r.viewport(0,0,t,s)),B(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),B(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function VE(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ME(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(n){return(e,t,s,r,o)=>{const a=X(e,t),i=a.length,u=xe(a),c=P(a),l=Mt(o,c),d=e.length,p=t.length,h=xe(e),f=xe(t),g=Ls(e,a),m=Ls(t,a);if(g.length+m.length===0)for(let y=0;y<l.length;++y)l[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<l.length;++y){const b=ro(y,i,u),$=b.slice(-d);g.forEach(k=>$[k]=0);const S=Lr($,d,h),N=b.slice(-p);m.forEach(k=>N[k]=0);const E=Lr(N,p,f);l[y]=n(s[S],r[E])}return[l,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WE(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Xs([0],t),[o,a]=Pe((i,u)=>i!==u?1:0)(e,[],n,r,"bool");return[a,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE=Pe((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(n,e,t,s,r){const o=P(s),a=Wt(r,t);for(let i=0;i<n.length;i++){const u=n[i];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(o>0?a[u]+=e[i]:a[u]+=1)}return a}function GE(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],a=le([r,t],e.dtype);for(let i=0;i<r;i++)for(let u=0;u<o;u++){const c=n.get(i,u);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?a.set(1,i,c):e.size>0?a.set(a.get(i,c)+e.get(i,u),i,c):a.set(a.get(i,c)+1,i,c))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=Pe((n,e)=>n&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(n){return(e,t,s)=>{const r=fe(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=jt(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KE(n,e,t,s){const r=fe(t,P(e));if(s&&t!=="string"){let o=0;n.forEach(a=>{const i=P(a.shape);r.set(a.vals,o),o+=i})}else{let o=0;n.forEach(a=>{const i=t==="string"?ts(a.vals):a.vals;let u=0;for(let c=0;c<a.shape[0];++c){const l=c*e[1]+o;for(let d=0;d<a.shape[1];++d)r[l+d]=i[u++]}o+=a.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qE=Pe((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=jt(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YE=jt(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE=jt(n=>Math.floor(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZE=Pe((n,e)=>Math.floor(n/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JE(n,e,t,s,r,o,a,i,u){const c=le([s,o],t);for(let l=0;l<s;l++){const d=[];let p=0;for(let h=0;h<r;h++){const f=n[l*r+h];p+=f*a[h],d.push(f)}if(p<0||p>=u/o)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let h=0;h<o;h++)c.values[l*o+h]=e.get(...e.indexToLoc(p*o+h))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(n,e,t){const s=le(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),i=a[0],u=a[2],c=e.locToIndex([i,u]);a[2]=e.values[c];const l=n.locToIndex(a);0<=l&&l<n.values.length&&(s.values[r]=n.values[l])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tI=Pe((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nI=Pe((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI=Pe((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rI=Pe((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n,e,t){const s=(e-n)/(t-1),r=Wt(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI=jt(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n,e,t,s){const r=Mt(s,P(t));for(let o=0;o<r.length;++o){const a=o*e;let i=n[a];for(let u=0;u<e;++u){const c=n[a+u];(Number.isNaN(c)||c>i)&&(i=c)}r[o]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uI=Pe((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI=Pe((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vy=Pe((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(n,e,t){const s=Dn(-1,t);return vy([],e,s,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI=Pe((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(n,e,t,s,r){const o=e.length,a=P(e),i=xe(e),u=xe(r),c=Mt(t,P(r));for(let l=0;l<a;++l){const d=ro(l,o,i),p=new Array(d.length);for(let f=0;f<p.length;f++)p[f]=d[s[f]];const h=Lr(p,o,u);c[h]=n[l]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(n,e,t,s){const[r,o]=_t(n,s),a=wt(e,"int32"),i=Wt(P(r),a),u=P(o);for(let c=0;c<i.length;++c){const l=c*u;let d=1;for(let p=0;p<u;++p)d*=t[l+p];i[c]=d}return{outVals:i,outShape:r,outDtype:a}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=ro(r,e.length,xe(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function mI(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function gI(n,e,t,s){const r=[];let o=0;const a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);mI(t,s);let u=1;for(let c=0;c<e.length-1;++c){u*=e[c];const l=e[c+1];for(let d=1;d<u+1;++d)i[c].push(d*l)}for(let c=0;c<n.length;++c){let l=n[c],d=n[c]+1;for(let p=0;p<t.length;++p){const h=t[p],f=p+e.length-1;if(f>=0){const g=i[f],m=g[g.length-1]-h[l];for(let y=l;y<d;++y)i[f].push(h[y+1]+m)}l=h[l],d=h[d]}d!==l&&(r.push([l,d]),o+=d-l)}return{outSplits:i,valueSlices:r,numValues:o}}function yI(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=fe("int32",s);e.push(r),n[t].forEach((o,a)=>r[a]=o)}return e}function Jd(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function xI(n,e,t,s,r,o){const a=Jd(e,2)[1],i=Jd(o,2)[1];let u=0;for(const c of t)for(let l=c[0];l<c[1];++l){for(let d=0;d<s;++d)r[u*i+d]=n[l*a+d];++u}}function bI(n,e,t,s,r){const o=e.slice();o[0]=r;const a=fe(t,P(o)),i=n.length,u=i===0?0:i/e[0];return xI(n,e,s,u,a,o),[a,o]}function wI(n,e,t,s,r,o,a,i){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(fI(o,a,u),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:l,valueSlices:d,numValues:p}=gI(o,a,n,c),h=yI(l),f=bI(t,s,r,d,p);return[h,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ep=2147483647;function $I(n,e,t,s,r,o,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const i=e.length===0,u=r.length===0,c=a.length===0,l=[];i||l.push(e[0]),u||l.push(r[0]),c||l.push(a[0]);for(let m=1;m<l.length;++m)if(l[m]!==l[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=l.length===0?1:l[0],p=fe("int32",d+1);p[0]=0;for(let m=0;m<d;++m){const y=i?n[0]:n[m],b=u?s[0]:s[m],$=c?o[0]:o[m];if($===0)throw new Error("Requires delta != 0");let S;if($>0&&b<y||$<0&&b>y)S=0;else if(S=Math.ceil(Math.abs((b-y)/$)),S>ep)throw new Error(`Requires ((limit - start) / delta) <= ${ep}`);p[m+1]=p[m]+S}const h=p[d],f=fe(t,h);let g=0;for(let m=0;m<d;++m){const y=p[m+1]-p[m];let b=i?n[0]:n[m];const $=c?o[0]:o[m];for(let S=0;S<y;++S)f[g++]=b,b+=$}return[p,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ze=gt;class Jr{constructor(e,t,s,r,o,a,i,u,c,l){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=lg(l),this.raggedRank=dg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ze.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ze.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ze.VALUE_ROWIDS:return Jr.getMaxWidthValueRowID(t);case Ze.ROW_SPLITS:return Jr.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ze[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let a=1;a<t;++a){const i=e[a];i!==r&&(r=i,o=Math.max(a-s,o),s=a)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return np(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;pg(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=cg(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let a=0;for(let i=0;i<r;++i,a+=t)o.push(a);for(let i=r;i<e;++i)o.push(-1);return v(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,a=[];for(let i=0;i<o-1;++i){const u=e[i+1]-e[i];let c=Math.min(r,u),l=t[i];l===-1&&(c=0);for(let d=0;d<c;++d)a.push(l),l+=s;for(let d=0;d<u-c;++d)a.push(-1)}if(o>0&&a.length!==e[o-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,a=[];if(o===0)return[];let i=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let c=t[u];a.push(c);for(let l=1;l<o;++l){const d=e[l];if(d===u)c>=0&&(++i,i<r?c+=s:c=-1);else{if(i=0,u=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);c=t[d]}a.push(c)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Ze.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case Ze.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${Ze[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ze.FIRST_DIM_SIZE:return e[0];case Ze.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ze.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ze[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const o=np(s,!1),a=fe(this.valuesDType,P(o));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,r[c],s[c]);this.setOutput(this.raggedRank,u,a,o)}return[o,a]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,a=s;let i=r.slice();i=i.slice(e+1);const u=P(i),c=t.length;let l=this.defaultValue;if(l.length!==u&&l.length!==1){const f=this.defaultValueShape;U(()=>{const g=_(l,f);l=Kn(g,i).dataSync()})}let d=0,p=0,h=0;for(let f=0;f<=c;++f){let g=f<c?t[f]:-1;if(g===h){++h;continue}if(p<h){const m=o.subarray(d*u),y=a.subarray(p*u),b=(h-p)*u;tp(y,m,b)}if(f>=c){const m=s.length;g=Math.floor(m/u)}if(g>h)if(this.defaultValue.length===1)a.subarray(h*u,g*u).fill(this.defaultValue[0]),h=g;else for(;g>h;){const m=a.slice(h*u);tp(m,l,u),++h}g<0?(d=f+1,p=h):(d=f,p=h,h=p+1)}}}function tp(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function np(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function vI(n,e,t,s,r,o,a,i,u,c){return new Jr(n,e,t,s,r,o,a,i,u,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SI(n,e,t,s){const r=n===e,o=n<e&&t<0,a=e<n&&t>1;if(r||o||a)return Wt(0,s);const i=Math.abs(Math.ceil((e-n)/t)),u=Wt(i,s);e<n&&t===1&&(t=-1),u[0]=n;for(let c=1;c<u.length;c++)u[c]=u[c-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI=jt(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n,e,t,s,r,o,a,i,u,c){const l=[s/r,r],d=n.values,p=e.values;if(s===0)return le(t,e.dtype);const h=u instanceof Cn?u:le(l,e.dtype);typeof u=="string"||typeof u=="number"?h.values.fill(u):typeof u=="boolean"&&h.values.fill(+u);for(let f=0;f<o;f++){const g=[];let m=0;for(let y=0;y<a;y++){const b=d[f*a+y];g.push(b),m+=b*i[y]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let y=0;y<r;y++)c?h.values[m*r+y]+=p[f*r+y]:h.values[m*r+y]=e.rank===0?p[0]:p[f*r+y]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NI=jt(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e,t,s,r){const o=Ml(s,e,t),a=P(t),i=xe(s);if(o){const d=Wl(e,i);return r==="string"?n.slice(d,d+a):n.subarray(d,d+a)}const u=r==="string"?ts(n):n,c=le(s,r,u),l=le(t,r);for(let d=0;d<l.size;++d){const p=l.indexToLoc(d),h=p.map((f,g)=>f+e[g]);l.set(c.get(...h),...p)}return r==="string"?Gg(l.values):l.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n,e,t,s,r,o,a){const i=e[0],u=o[0],c=new Array(u),l=new Array(i),d=e[1];if(u===0){if(i!==0)throw new Error(Rg(i));const m=fe(t,0),y=fe(r,0);return[m,[0,d],y,c,l]}let p=!0,h=0;const f=new Array(u).fill(0);for(let m=0;m<i;++m){const y=n[m*d];if(y<0)throw new Error(_g(m,y));if(y>=u)throw new Error(Ag(m,y,u));++f[y],p=p&&y>=h,h=y}let g=!0;for(let m=0;m<u;++m){const y=f[m]===0;c[m]=y,g=g&&!y,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&p){const m=n,y=s;for(let b=0;b<i;++b)l[b]=b;return[m,[i,d],y,c,l]}else{const m=f[u-1],y=fe(t,m*d),b=fe(r,m),$=new Array(u).fill(0);for(let S=0;S<i;++S){const N=n[S*d],E=$[N],k=(N===0?0:f[N-1])+E;$[N]++;for(let R=0;R<d;++R)y[k*d+R]=n[S*d+R];b[k]=s[S],l[S]=k}for(let S=0;S<u;++S)if($[S]===0){const E=S===0?0:f[S-1];y[E*d+0]=S;for(let k=1;k<d;++k)y[E*d+k]=0;b[E]=a}return[y,[m,d],b,c,l]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t,s,r){const o=P(s),a=e[0],i=r.length,u=[];let c=1,l=-1;for(let m=0;m<i;++m){const y=r[m];if(y===-1){if(l!==-1)throw new Error(Og(l,m));l=m,u.push(1)}else{if(y<0)throw new Error(Dg(m,y));c*=y,u.push(y)}}if(l!==-1){if(c<=0)throw new Error(Pg());const m=Math.trunc(o/c);if(c*m!==o)throw new Error(Fg(s,u));u[l]=m}if(P(u)!==o)throw new Error(Lg(s,u));const p=s.length,h=[];if(p>0){h[p-1]=1;for(let m=p-2;m>=0;--m)h[m]=h[m+1]*s[m+1]}const f=[];if(i>0){f[i-1]=1;for(let m=i-2;m>=0;--m)f[m]=f[m+1]*u[m+1]}const g=fe(t,a*i);for(let m=0;m<a;++m){let y=0;for(let b=0;b<p;++b)y+=n[m*p+b]*h[b];for(let b=0;b<i;++b)g[m*i+b]=Math.trunc(y/f[b]),y%=f[b]}return[g,[a,i],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n,e,t,s,r,o=!1,a=0){const i=s.length,u=[e[0],n.length/e[0]],c=u[1],d=i>0?r[i-1]+1:0;if(d<0)throw new Error(ya());const p=e.slice();p[0]=d;const h=p.reduce(($,S)=>$*S,1),f=fe(t,h);if(i===0)return d>0&&f.fill(a),[f,p];if(d<=0)throw new Error(ya());let g=0,m=1,y=0,b=r[g];for(;;){let $=0;if(m<i){if($=r[m],b===$){++m;continue}if(b>=$)throw new Error(Bg())}if(b<0||b>=d)throw new Error(Vg(b,d));b>y&&f.fill(a,y*c,b*c);for(let S=g;S<m;++S){const N=s[S];if(N<0||N>=u[0])throw new Error(Mg(S,s[S],u[0]));for(let E=0;E<c;E++)f[b*c+E]+=n[N*c+E]}if(o)for(let S=0;S<c;S++)f[b*c+S]/=m-g;if(g=m,++m,y=b+1,b=$,m>i)break}return y<d&&f.fill(a,y*c,d*c),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _I=jt(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AI=Pe((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OI=jt((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e,t,s){const r=le(n,e.dtype);for(let o=0;o<r.size;o++){const a=r.indexToLoc(o),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*t[u]+s[u];r.set(e.get(...i),...a)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PI{constructor(e,t,s,r,o,a){this.separator=Lt(e),this.nGramWidths=t,this.leftPad=Lt(s),this.rightPad=Lt(r),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,a){for(let i=0;i<o;++i){const u=this.getPadWidth(a),c=Math.max(0,u-i),l=Math.max(0,u-(o-(i+1))),d=a-(c+l),p=t+(c>0?0:i-u);let h=0;h+=c*this.leftPad.length;for(let b=0;b<d;++b)h+=e[p+b].length;h+=l*this.rightPad.length;const f=c+l+d-1;h+=f*this.separator.length,s[r+i]=new Uint8Array(h);const g=s[r+i];let m=0;const y=b=>b.forEach($=>g[m++]=$);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(e[p+b]),y(this.separator);if(d>0){y(e[p+d-1]);for(let b=0;b<l;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<l-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<r;++c){let l=t[c]>=u;if(l=l&&t[c]<=s,!l)throw new Error(`Invalid split value ${t[c]}, must be in [${u}, ${s}]`);u=t[c]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const o=r-1,a=fe("int32",r);if(s===0||r===0){const u=new Array(s);for(let c=0;c<=o;++c)a[c]=0;return[u,a]}a[0]=0;for(let u=1;u<=o;++u){const c=t[u]-t[u-1];let l=0;this.nGramWidths.forEach(d=>{l+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&l===0&&(l=1),a[u]=a[u-1]+l}const i=new Array(a[o]);for(let u=0;u<o;++u){const c=t[u];let l=a[u];if(this.nGramWidths.forEach(d=>{const p=t[u+1]-t[u],h=this.getNumNGrams(p,d);this.createNGrams(e,c,i,l,h,d),l+=h}),this.preserveShort&&l===a[u]){const d=t[u+1]-t[u];if(d===0)continue;const p=d+2*this.padWidth,h=1;this.createNGrams(e,c,i,l,h,p)}}return[i,a]}}function FI(n,e,t,s,r,o,a,i){return new PI(t,s,r,o,a,i).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=n.indexOf(o);for(;a!==-1;){const i=n.subarray(0,a);(!t||i.length!==0)&&s.push(i),n=n.subarray(a+1),a=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const a=n.subarray(r,o);(!t||a.length!==0)&&s.push(a),r=o+1}}function BI(n,e,t){const s=n.length,r=[];let o=0,a=0;const i=new Array(s);for(let p=0;p<s;++p){const h=r.length;LI(n[p],e,t,r);const f=r.length-h;i[p]=f,o+=f,a=Math.max(a,f)}const u=fe("int32",o*2),c=new Array(o),l=[s,a];let d=0;for(let p=0;p<s;++p)for(let h=0;h<i[p];++h)u[d*2]=p,u[d*2+1]=h,c[d]=r[d],++d;return[u,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n,e){const t=fe("int32",n.length);for(let s=0;s<n.length;++s)t[s]=Zp(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MI=Pe((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=le(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=o[u]%n.shape[u];const i=n.locToIndex(a);s.values[r]=n.values[i]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ts=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Sy(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const i=s-t+1,u=e-t+1,c=Math.log(i),l=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*l*(i-l)/i)*Math.sign(u-i/2),p=Math.max(t,Math.floor(e-u*l/i+d)),h=Math.min(s,Math.floor(e+(i-u)*l/i+d));Sy(n,e,p,h)}const r=n[e];let o=t,a=s;for(Dt(n,t,e),Ts(n[s],r)>0&&Dt(n,t,s);o<a;){for(Dt(n,o,a),o++,a--;Ts(n[o],r)<0;)o=o+1;for(;Ts(n[a],r)>0;)a=a-1}Ts(n[t],r)===0?Dt(n,t,a):(a=a+1,Dt(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function UI(n,e,t,s,r){const o=e[e.length-1],[a,i]=[n.length/o,o],u=Mt(t,a*s),c=Mt("int32",a*s);for(let d=0;d<a;d++){const p=d*i,h=n.subarray(p,p+i);let f=new Array(h.length);h.forEach((b,$)=>f[$]={value:b,index:$}),s<f.length&&(Sy(f,s),f=f.slice(0,s)),r&&f.sort(Ts);const g=d*s,m=u.subarray(g,g+s),y=c.subarray(g,g+s);for(let b=0;b<s;b++)m[b]=f[b].value,y[b]=f[b].index}const l=e.slice();return l[l.length-1]=s,[le(l,t,u),le(l,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(n,e,t,s){const r=me(e,t)[0],o=[1,t[0],1];for(let f=0;f<r;f++)o[0]*=t[f];o[1]=t[r];for(let f=r+1;f<t.length;f++)o[2]*=t[f];const a=new Map,i=new Int32Array(t[r]),u=new Cn(o,s,n),c=[],l=o[0]===1&&o[2]===1;for(let f=0;f<t[r];f++){let g;if(l)g=n[f].toString();else{const y=[];for(let b=0;b<o[0];b++)for(let $=0;$<o[2];$++)y.push(u.get(b,f,$));g=y.join(",")}const m=a.get(g);if(m!=null)i[f]=m;else{const y=a.size;a.set(g,y),i[f]=y,c.push(f)}}const d=o.slice();d[1]=a.size;const p=new Cn(d,s);c.forEach((f,g)=>{for(let m=0;m<o[0];m++)for(let y=0;y<o[2];y++)p.set(u.get(m,f,y),m,g,y)});const h=t.slice();return h[r]=d[1],{outputValues:p.values,outputShape:h,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GI=Object.freeze(Object.defineProperty({__proto__:null,addImpl:UE,bincountImpl:zE,bincountReduceImpl:GE,bitwiseAndImpl:HE,castImpl:WE,ceilImpl:jE,concatImpl:KE,equalImpl:qE,expImpl:XE,expm1Impl:YE,floorDivImpl:ZE,floorImpl:QE,gatherNdImpl:JE,gatherV2Impl:eI,greaterEqualImpl:nI,greaterImpl:tI,lessEqualImpl:rI,lessImpl:sI,linSpaceImpl:oI,logImpl:aI,maxImpl:iI,maximumImpl:uI,minimumImpl:cI,multiplyImpl:vy,negImpl:lI,notEqualImpl:dI,prodImpl:hI,raggedGatherImpl:wI,raggedRangeImpl:$I,raggedTensorToTensorImpl:vI,rangeImpl:SI,rsqrtImpl:CI,scatterImpl:TI,sigmoidImpl:NI,simpleAbsImpl:ME,sliceImpl:EI,sparseFillEmptyRowsImpl:II,sparseReshapeImpl:kI,sparseSegmentReductionImpl:RI,sqrtImpl:_I,squaredDifferenceImpl:AI,staticRegexReplaceImpl:OI,stridedSliceImpl:DI,stringNGramsImpl:FI,stringSplitImpl:BI,stringToHashBucketFastImpl:VI,subImpl:MI,tileImpl:WI,topKImpl:UI,transposeImpl:pI,uniqueImpl:zI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:HI,bincountImpl:Cy,bincountReduceImpl:jI,bitwiseAndImpl:KI,castImpl:qI,ceilImpl:XI,concatImpl:YI,equalImpl:QI,expImpl:ZI,expm1Impl:JI,floorImpl:ek,gatherNdImpl:tk,gatherV2Impl:nk,greaterImpl:sk,greaterEqualImpl:rk,lessImpl:ok,lessEqualImpl:ak,linSpaceImpl:ik,logImpl:uk,maxImpl:ck,maximumImpl:lk,minimumImpl:dk,multiplyImpl:pk,negImpl:hk,notEqualImpl:fk,prodImpl:mk,raggedGatherImpl:gk,raggedRangeImpl:yk,raggedTensorToTensorImpl:xk,rangeImpl:bk,rsqrtImpl:wk,scatterImpl:$k,sigmoidImpl:vk,simpleAbsImpl:Ty,sliceImpl:Sk,sparseFillEmptyRowsImpl:Ck,sparseReshapeImpl:Tk,sparseSegmentReductionImpl:Ny,sqrtImpl:Nk,staticRegexReplaceImpl:Ek,stridedSliceImpl:Ik,stringNGramsImpl:kk,stringSplitImpl:Rk,stringToHashBucketFastImpl:_k,subImpl:Ak,tileImpl:Ok,topKImpl:Dk,transposeImpl:ed,uniqueImpl:Pk}=GI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ey(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Re(n,e){return e===1?[n]:Ey(n,e)}function Fk(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lk{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Te(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Re("rc",this.rank),s=oe(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)o=`${e[e.length-1-a]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iy{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Bk(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Zl():Ql(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Bk(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?_2(["r","c","d"],"inputShape"):Ln(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vk{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=rp(t,s),o=op(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=sp(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[o].pop();return this.usedTextures[o].push(u),u}let i;return r===we.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===we.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===we.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===we.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===we.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=rp(s,r),a=op(t,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=sp(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=I().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[a],l=c&&c.indexOf(e);if(l==null||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Mk(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function sp(n,e,t,s,r){const o=Wk(e,s);let a;if(r){const[u,c]=cs(n[0],n[1]);a=u*c}else{const[u,c]=ar(n[0],n[1]);a=u*c}const i=Mk(t,o);return a*i}function Wk(n,e){switch(n){case we.PACKED_2X2_FLOAT32:return wy(e);case we.PACKED_2X2_FLOAT16:return $y(e);case we.UNPACKED_FLOAT32:return yy(e);case we.UNPACKED_FLOAT16:return xy(e);case we.PACKED_4X1_UNSIGNED_BYTE:return by(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Uk(n){return I().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?we.PACKED_2X2_FLOAT32:we.UNPACKED_FLOAT32:n?we.PACKED_2X2_FLOAT16:we.UNPACKED_FLOAT16}function rp(n,e){if(n===He.UPLOAD)return we.PACKED_2X2_FLOAT32;if(n===He.RENDER||n==null)return Uk(e);if(n===He.DOWNLOAD||n===He.PIXELS)return we.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function op(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ct{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const dt="if (isnan(x)) return x;",zk="return x;",ap="return abs(x);",Gk="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hk=dt+`
  return (x < 0.0) ? 0.0 : x;
`,jk=dt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Kt="return x;",Kk="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qk="return x;",Xk=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Yk=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qk=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Zk="return 1.0 / (1.0 + exp(-1.0 * x));";class Qt{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jk{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length);const t=e.length,s=Re("rc",t),r=oe(t),o=Fk(t,s),a=s.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eR=Sl,tR=1e-7,nR=1e-4,kr={};function sR(n){return n in kr||(kr[n]={}),kr[n]}const rR=I().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),oR=600;function aR(){return I().global.screen==null?1024:I().global.screen.height*I().global.screen.width*window.devicePixelRatio*oR/1024/1024}class _o extends Fa{nextDataId(){return _o.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!I().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Yo)t=e;else{const s=$t(I().getNumber("WEBGL_VERSION"),e);t=new Yo(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=$t(I().getNumber("WEBGL_VERSION"));t=new Yo(s),this.binaryCache=sR(I().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Vk(this.gpgpu),this.numMBBeforeWarning=aR(),this.texData=new Tp(this,ft())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,a){const i=this.makeTensorInfo(t,s),u=this.texData.get(i.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,o]},u.texShape=[r,o];const c=Er(t),l=new Zd(c,!1,a),d=this.runWebGLProgram(l,[i],s,[[r,o]]);return d.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(i),d.dataId}write(e,t,s){if((I().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||I().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:He.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(I().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:He.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:a,shape:i,isPacked:u}=t;if(a!=null){let p;u?p=new Qt(i,Kt):p=new Ct(i,Kt);const h=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:r}],r),f=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let l;c&&(l=tt());let d;if(r==="complex64"){const p=this.readSync(o.real.dataId),h=this.readSync(o.imag.dataId);d=ga(p,h)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=tt()-l),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:a,complexTensorInfos:i,isPacked:u}=t;if(o!=null){let f;u?f=new Qt(r,Kt):f=new Ct(r,Kt);const g=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:a}],a),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(I().getBool("DEBUG")&&!I().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&I().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,l;if(a!=="complex64"&&I().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const f=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...Cr(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){const f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),g=f[0],m=f[1];d=ga(g,m)}else if(c==null)d=this.getValuesFromTexture(e);else{const f=P(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(l!=null&&this.disposeIntermediateTensorInfo(l),c!=null){const f=this.gpgpu.gl;B(f,()=>f.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,d),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(f=>f(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ft().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:a,dtype:i,isPacked:u,texture:c}=s;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;u?h=new Qt(o,Kt):h=new Ct(o,Kt);const f=this.runWebGLProgram(h,[{dataId:e,shape:o,dtype:i}],i),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),d=ft().makeTensorFromTensorInfo(l),p=this.texData.get(l.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Sn(r));return le(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!r2(s))throw I().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=P(t);if(I().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),h=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Cr(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),f}const a=I().getBool("WEBGL_PACK")&&r===!0,i=a?Er(t):t,u=a?new wE(i):new bE(i),c=this.runWebGLProgram(u,[{shape:i,dtype:s,dataId:e}],"float32"),l=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Nt(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=Nt(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);i.kernelMs=Ep(u),i.getExtraProfileInfo=()=>u.map((c,l)=>({name:a[l],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:tt(),endMs:null}}endTimer(e){return I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=tt(),e)}async getQueryTime(e){if(I().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:a,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=rR){return I().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&P(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){nt("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return eR(e.shape,t)}packedUnaryOp(e,t,s){const r=new Qt(e.shape,t),o=this.compileAndRun(r,[e],s);return ft().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=Ty(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(I().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ap,e.dtype);const t=new Ct(e.shape,ap),s=this.compileAndRun(t,[e]);return ft().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ft(s[0])){const o=s.map(a=>Lt(a));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return ft().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new Jk(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Lk(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[ns(e.shape),...ss(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[ns(t),...ss(t)],a=new Iy(o,s),i=!0,u=[s],c=this.runWebGLProgram(a,[r],e.dtype,u,i);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:a}=s;if(t!=null){const p=P(o),h=t[0]*t[1]*4;v(p<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=Er(o);let u;r?u=new xE(i):u=new yE(i);const c=!0,l=[t??Cr(i)],d=this.runWebGLProgram(u,[{shape:i,dtype:a,dataId:e}],a,l,c,t);return{dtype:a,shape:o,dataId:d.dataId}}runWebGLProgram(e,t,s,r,o=!1,a){const i=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Gs.DENSE){const y=a??Cr(e.outputShape);u.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),P(i.shape)===0)return u.values=Mt(i.dtype,0),i;const c=[],l=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&P(y.shape)<=I().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Zr(b.shape,y.shape)){const $=y,S=y.shape;y.shape=b.shape,y=this.packedReshape(y,S),c.push(y),b=this.texData.get(y.dataId),$.shape=S}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(i.dataId);const d={shape:i.shape,texData:u,isUniform:!1},p=gE(e,l,d),h=this.getAndSaveBinary(p,()=>fE(this.gpgpu,e,l,d)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),I().get("ENGINE_COMPILE_ONLY")||mE(this.gpgpu,h,l,d,r),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const m=I().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const y=tt();y-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!I().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const y=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),y}return i}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(I().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=U(()=>{if(!I().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=I().getBool("DEBUG");I().set("DEBUG",!1);const t=this.abs(K(1e-8)).dataSync()[0];if(I().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?tR:nR}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:a,usage:i,isPacked:u}=t;if(a!=null)return;const c=this.activeTimers!=null;let l;c&&(l=tt());let d=t.texShape;if(d==null&&(d=v2(s,u),t.texShape=d),o!=null){const p=Er(s);let h,f=d[1],g=d[0];const m=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!m)&&([f,g]=cs(d[0],d[1])),u?h=new vE(p,m):h=new Zd(p,m);const y=m?[g,f]:d,b=this.makeTensorInfo(y,r),$=this.texData.get(b.dataId);m?$.usage=He.PIXELS:$.usage=He.UPLOAD,$.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,g,o);const S=[[g,f]],N=!0,E=this.runWebGLProgram(h,[b],r,S,N),k=this.texData.get(E.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,I().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=tt()-l)}else{const p=this.acquireTexture(d,i,r,u);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=iR(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ks(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ig(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(dy(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:u}=gy(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:a,channels:i}=e,u=ft().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(r,t,s,o,a,i);return ft().makeTensorFromDataId(c,t,s,u)}}_o.nextDataId=0;function iR(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc()&&xh("webgl",()=>new _o,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const td=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class An{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=X(t,s),this.enableShapeUniforms=Te(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class fs{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=X(t,s);const o=this.outputShape.length;this.enableShapeUniforms=Te(o);let a="";if(r)if(o===0||P(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${oe(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Re("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ue(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const uR={kernelName:io,backendName:"webgl",kernelFunc:Ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(o.dataId),i=Ue({inputs:{x:s},backend:t}),u=Ue({inputs:{x:r},backend:t});return a.complexTensorInfos={real:i,imag:u},o}const cR={kernelName:ui,backendName:"webgl",kernelFunc:cn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ky="return (a < 0.) ? b * a : a;",Ry=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function lR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,a=t.makeTensorInfo([],"float32",Dn(o,"float32")),i=I().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fs(Ry,r.shape,a.shape):new An(ky,r.shape,a.shape),u=t.runWebGLProgram(i,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),u}const dR={kernelName:Zi,backendName:"webgl",kernelFunc:lR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _y="return (a < 0.) ? b * a : a;",Ay=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function pR(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=I().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fs(Ay,s.shape,r.shape):new An(_y,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const hR={kernelName:Ru,backendName:"webgl",kernelFunc:pR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ms="if (isnan(x)) return x;";function Y({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:a}=r,i=o,u=s||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){const d=i.texData.get(a.dataId),p=t(d.values,u);return i.makeTensorInfo(a.shape,u,p)}const c=I().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let l;return c?l=new Qt(a.shape,e):l=new Ct(a.shape,n),i.runWebGLProgram(l,[a],u)}}function ve({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:a,backend:i})=>{const{a:u,b:c}=a,l=i;if(s&&u.dtype==="complex64"){const f=l.texData.get(u.dataId),g=l.texData.get(c.dataId),[m,y]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map($=>{const[S,N]=$,E={dataId:S.dataId,dtype:S.dtype,shape:u.shape},k={dataId:N.dataId,dtype:N.dtype,shape:c.shape},R=new An(n,u.shape,c.shape);return l.runWebGLProgram(R,[E,k],wt(S.dtype,N.dtype))}),b=cn({inputs:{real:m,imag:y},backend:l});return l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(y),b}const d=o||wt(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||l.shouldExecuteOnCPU([u,c]))&&r!=null){const f=l.texData.get(u.dataId).values,g=l.texData.get(c.dataId).values,m=u.dtype==="string"?ts(f):f,y=u.dtype==="string"?ts(g):g,[b,$]=r(u.shape,c.shape,m,y,d),S=l.makeTensorInfo($,d),N=l.texData.get(S.dataId);return N.values=b,S}const p=I().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return p?h=new fs(e,u.shape,c.shape,t):h=new An(n,u.shape,c.shape),l.runWebGLProgram(h,[u,c],d)}}function Hs(n,e=!1){if(n==="linear")return e?qk:zk;if(n==="relu")return e?Yk:Hk;if(n==="elu")return e?Xk:Gk;if(n==="relu6")return e?Qk:jk;if(n==="prelu")return e?Ay:_y;if(n==="leakyrelu")return e?Ry:ky;if(n==="sigmoid")return e?Zk:Kk;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oy{constructor(e,t,s,r=!1,o=!1,a=!1,i=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Te(this.outputShape.length);const l=r?e[1]:e[2],d=Math.ceil(l/2),p=r?"i * 2, rc.y":"rc.y, i * 2",h=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";i&&(u?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let $="rc.x",S="rc.x";e[0]<t[0]?$=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(S=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${S};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ip={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class up{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=X(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cp="return a * b;";function nd(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=wt(s.dtype,r.dtype);if(s.dtype==="complex64"){const i=t.texData.get(s.dataId),u=t.texData.get(r.dataId),c=new up(ip.REAL,s.shape,r.shape),l=new up(ip.IMAG,s.shape,r.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],p=t.runWebGLProgram(c,d,"float32"),h=t.runWebGLProgram(l,d,"float32"),f=cn({inputs:{real:p,imag:h},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),f}if(t.shouldExecuteOnCPU([s,r])){const i=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[c,l]=pk(s.shape,r.shape,i.values,u.values,o),d=t.makeTensorInfo(l,o),p=t.texData.get(d.dataId);return p.values=c,d}let a;return I().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new fs(cp,s.shape,r.shape):a=new An(cp,s.shape,r.shape),t.runWebGLProgram(a,[s,r],o)}const fR={kernelName:bu,backendName:"webgl",kernelFunc:nd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(n,e,t){const s=[ns(n.shape),...ss(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[ns(e),...ss(e)],a=new Iy(o,s),i=!0,u=[s],c=t.runWebGLProgram(a,[r],n.dtype,u,i);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,a=t,i=P(r.shape),u=kp(o,i),c=P(u);v(i===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const l=a.texData.get(r.dataId);return l.isPacked&&!Zr(r.shape,u)&&!(l.texture!==null&&Zr(l.shape,u))?mR(r,u,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const gR={kernelName:Vu,backendName:"webgl",kernelFunc:F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lp{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];const i=Math.floor(s/4)*4,u=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const d=1/t;c=`sumValue += dot(values * ${vn(d)?d.toPrecision(2):d}, ones);`}let l="";o%s>0&&(l=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yR{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const l=Math.floor(s/4)*4,d=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xR(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=Eo(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Mn(n,e,t,s){const r=xR(n.shape);let o=n;for(let a=0;a<r.length;a++){const{inSize:i,windowSize:u,outSize:c}=r[a];let l,d;t==="mean"?l=a===0?new lp({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c},i):new lp({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c}):l=new yR({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:c},t),d=o,o=s.runWebGLProgram(l,[o],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bR{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=oe(this.rank),o=wR(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function wR(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $R{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let l=0;l<s.length;l++)s[l]=e[t[l]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=oe(this.rank),o=Ey("rc",this.rank),a=new Array(this.rank);for(let l=0;l<t.length;l++)a[t[l]]=o[l];const i=`vec2(${a.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(n,e,t){const s=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $R(n.shape,e):new bR(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(n,e,t,s){const r=e,o=n.shape.length,a=me(r,n.shape);let i=a;const u=ct(i,o),c=u!=null;let l=n;c&&(l=Ao(n,u,s),i=lt(i.length,o)),St("sum",i,o);const[d,p]=_t(l.shape,i);let h=d;t&&(h=Ke(d,a));const f=P(p),m=P(n.shape)/f,y=F({inputs:{x:l},attrs:{shape:[m,f]},backend:s}),b=co(n.dtype),$=Mn(y,b,"sum",s),S=F({inputs:{x:$},attrs:{shape:h},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo($),c&&s.disposeIntermediateTensorInfo(l),S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;return vR(r,o,a,t)}const SR={kernelName:rc,backendName:"webgl",kernelFunc:Oo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,a=t,i=r.shape.length,u=new Array(i);for(let l=0;l<u.length;l++)u[l]=r.shape[o[l]];let c;if(a.shouldExecuteOnCPU([r])){const d=a.texData.get(r.dataId).values,p=ed(d,r.shape,r.dtype,o,u);c=a.makeTensorInfo(u,r.dtype);const h=a.texData.get(c.dataId);h.values=p}else c=Ao(r,o,a);return c}const CR={kernelName:Es,backendName:"webgl",kernelFunc:Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dy=1e3;function eo({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){const c=n.shape.length,l=e.shape.length,d=t?n.shape[c-2]:n.shape[c-1],p=s?e.shape[l-1]:e.shape[l-2],h=t?n.shape[c-1]:n.shape[c-2],f=s?e.shape[l-2]:e.shape[l-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),y=P(g),b=P(m),S=X(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([h,f]);v(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const N=t?[y,d,h]:[y,h,d],E=s?[b,f,p]:[b,p,f],k=F({inputs:{x:n},backend:r,attrs:{shape:N}}),R=F({inputs:{x:e},backend:r,attrs:{shape:E}}),A=[k,R],O=Math.max(y,b),D=t?k.shape[1]:k.shape[2],V=o!=null,z=a!=null,G=u==="leakyrelu",j=u!=null?Hs(u,!0):null,q=V||z||G||j!=null;let Q;if((h===1||f===1)&&D>Dy&&q===!1){let he=k,Fe=R;t&&(he=Ae({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),A.push(he)),s&&(Fe=Ae({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),A.push(Fe));const qe=f!==1,pt=f===1;let Xe=he;qe&&(Xe=F({inputs:{x:he},backend:r,attrs:{shape:[O,D,1]}}),A.push(Xe));const ht=f===1?2:1;let Ye=Fe;pt&&(Ye=F({inputs:{x:Fe},backend:r,attrs:{shape:[O,1,D]}}),A.push(Ye));const Qe=nd({inputs:{a:Xe,b:Ye},backend:r});Q=Oo({inputs:{x:Qe},backend:r,attrs:{axis:ht,keepDims:!0}}),A.push(Qe)}else{const he=wt(n.dtype,e.dtype),Fe=new Oy(N,E,[O,h,f],t,s,V,j,z,G),qe=[k,R];if(o!=null&&qe.push(o),z&&qe.push(a),G){const pt=r.makeTensorInfo([],"float32",Dn(i,"float32"));qe.push(pt),A.push(pt)}Q=r.runWebGLProgram(Fe,qe,he)}const J=F({inputs:{x:Q},backend:r,attrs:{shape:S}});A.push(Q);for(const he of A)r.disposeIntermediateTensorInfo(he);return J}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=s;return eo({a:r,b:o,transposeA:u,transposeB:c,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:d,activation:l})}const NR={kernelName:Vr,backendName:"webgl",kernelFunc:TR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dp="return abs(x);";function ER(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),a=Ty(o.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return I().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qt(s.shape,dp):r=new Ct(s.shape,dp),t.runWebGLProgram(r,[s],s.dtype)}const IR={kernelName:Ma,backendName:"webgl",kernelFunc:ER};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=dt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,RR=Y({opSnippet:kR}),_R={kernelName:Wa,backendName:"webgl",kernelFunc:RR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AR=dt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,OR=Y({opSnippet:AR}),DR={kernelName:Ua,backendName:"webgl",kernelFunc:OR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pp="return a + b;",PR=ve({opSnippet:pp,packedOpSnippet:pp,supportsComplex:!0,cpuKernelImpl:HI}),FR={kernelName:oo,backendName:"webgl",kernelFunc:PR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LR{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BR{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Ue({inputs:{x:s[0]},backend:t});if(s.length>I().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),c=Dr({inputs:s.slice(0,u),backend:t}),l=Dr({inputs:s.slice(u),backend:t});return Dr({inputs:[c,l],backend:t})}const r=s.map(u=>u.dtype).reduce((u,c)=>wt(u,c)),o=s.map(u=>u.shape),i=I().getBool("WEBGL_PACK")?new BR(s[0].shape,o):new LR(s[0].shape,o);return t.runWebGLProgram(i,s,r)}const VR={kernelName:za,backendName:"webgl",kernelFunc:Dr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,u=me(o,r.shape);let c=u;const l=ct(c,i);let d=r;l!=null&&(d=Ae({inputs:{x:r},backend:t,attrs:{perm:l}}),c=lt(c.length,i)),St("all",c,i);const[p,h]=_t(d.shape,c),f=P(h),g=F({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),m=Mn(g,g.dtype,"all",t);let y;if(a){const b=Ke(p,u);y=F({inputs:{x:m},backend:t,attrs:{shape:b}})}else y=F({inputs:{x:m},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),l!=null&&t.disposeIntermediateTensorInfo(d),y}const WR={kernelName:Ga,backendName:"webgl",kernelFunc:MR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,u=me(o,r.shape);let c=u;const l=ct(c,i);let d=r;l!=null&&(d=Ae({inputs:{x:r},backend:t,attrs:{perm:l}}),c=lt(c.length,i)),St("any",c,i);const[p,h]=_t(d.shape,c),f=P(h),g=F({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),m=Mn(g,g.dtype,"any",t);let y;if(a){const b=Ke(p,u);y=F({inputs:{x:m},backend:t,attrs:{shape:b}})}else y=F({inputs:{x:m},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),l!=null&&t.disposeIntermediateTensorInfo(d),y}const zR={kernelName:Ha,backendName:"webgl",kernelFunc:UR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GR{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const i=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HR{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,v(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,c=oe(u),l=Re("coords",u);let d,p;if(a===1){p=u+1;const R=oe(p);d=`
        ${R} sourceLocR = ${R}(${l.join()}, 0);
        ++${l[u-1]};
        ${R} sourceLocG = ${R}(${l.join()}, 0);
        ++${l[u-2]};
        ${R} sourceLocA = ${R}(${l.join()}, 0);
        --${l[u-1]};
        ${R} sourceLocB = ${R}(${l.join()}, 0);
        --${l[u-2]};`}else p=u,d=`
        ${c} sourceLocR = coords;
        ++${l[u-1]};
        ${c} sourceLocG = coords;
        ++${l[u-2]};
        ${c} sourceLocA = coords;
        --${l[u-1]};
        ${c} sourceLocB = coords;
        --${l[u-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],g=h.map(R=>"int "+R),m=Re("sourceLocR",p-1).concat("inIdx.r"),y=Re("sourceLocG",p-1).concat("inIdx.g"),b=Re("sourceLocB",p-1).concat("inIdx.b"),$=Re("sourceLocA",p-1).concat("inIdx.a"),S=s==="max"?"greaterThan":"lessThan",N=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${$.join()})));`,E=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${l[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${l[u-2]} < ${i[u-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const a=Eo(o),i={windowSize:a,inSize:o,batchSize:r,outSize:Math.ceil(o/a)},u=new GR(i,t,s==null),c=[e];s!=null&&c.push(s);const l=n.runWebGLProgram(u,c,"int32");if(l.shape[1]===1)return l;const d=Py(n,e,t,l);return n.disposeIntermediateTensorInfo(l),d}function Fy(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],a=Eo(o),i=new HR(r,a,t,s==null),u=s==null?[e]:[e,s],c=n.runWebGLProgram(i,u,"int32");if(c.shape.length===e.shape.length){const l=Fy(n,e,t,c);return n.disposeIntermediateTensorInfo(c),l}return c}function Ly(n,e,t,s){const r=[t];if(St("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!I().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=n.texData.get(e.dataId),i=a!==null&&a.isPacked;let u=e;i&&(u=n.unpackTensor(e),o.push(u));const[c,l]=_t(u.shape,r),d=P(l),p=F({inputs:{x:u},backend:n,attrs:{shape:[-1,d]}});o.push(p);const h=Py(n,p,s);o.push(h);const f=F({inputs:{x:h},backend:n,attrs:{shape:c}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return Fy(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=me(o,r.shape);const i=ct(a,r.shape.length);let u=r;const c=[];i!=null&&(u=Ae({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),a=lt(a.length,u.shape.length)),St("argMax",[a[0]],u.shape.length);const l=Ly(t,u,a[0],"max");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),l}const KR={kernelName:ja,backendName:"webgl",kernelFunc:jR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=me(o,r.shape);const i=ct(a,r.shape.length);let u=r;const c=[];i!=null&&(u=Ae({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),a=lt(a.length,u.shape.length)),St("argMin",[a[0]],u.shape.length);const l=Ly(t,u,a[0],"min");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),l}const XR={kernelName:Ka,backendName:"webgl",kernelFunc:qR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YR=dt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,QR=Y({opSnippet:YR}),ZR={kernelName:qa,backendName:"webgl",kernelFunc:QR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JR=dt+"return log(x + sqrt(x * x + 1.0));",e_=Y({opSnippet:JR}),t_={kernelName:Xa,backendName:"webgl",kernelFunc:e_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_=dt+`
  return atan(x);
`,s_=Y({opSnippet:n_}),r_={kernelName:Ya,backendName:"webgl",kernelFunc:s_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o_=td+`
  return atan(a, b);
`,a_=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vn+`
  return result;
`,i_=ve({opSnippet:o_,packedOpSnippet:a_}),u_={kernelName:Za,backendName:"webgl",kernelFunc:i_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c_=dt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,l_=Y({opSnippet:c_}),d_={kernelName:Qa,backendName:"webgl",kernelFunc:l_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class js{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(g||(b="-1.0 / 1e-20"),s){const R=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${h}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?m:y:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");const N=Math.floor(a/4)*4,E=a%4,k=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${h}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${N};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${S});
      }
    `}}class sd{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,u=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const $=t==="avg";let S="0.0";if($||(S="-1.0 / 1e-20"),s){const O=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${c});
        const ivec3 pads = ivec3(${m}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${O} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const k=Math.floor(a/4)*4,R=a%4,A=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${c});
      const ivec3 pads = ivec3(${m}, ${y}, ${b});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${k};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${E});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;ir(r,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:u}=s,c=1;v(Ge(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const l=Pn(r.shape,o,a,c,i,u);if(l.filterWidth===1&&l.filterHeight===1&&ce(l.inShape,l.outShape))return Ue({inputs:{x:r},backend:t});const d=new js(l,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const h_={kernelName:Ja,backendName:"webgl",kernelFunc:p_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:u,dataFormat:c}=s,l=[1,1,1],d=Qs(r.shape,o,a,l,i,u,c),p=new sd(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const m_={kernelName:ei,backendName:"webgl",kernelFunc:f_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=u-1-e.padInfo.top,d=c-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class y_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=d-1-e.padInfo.front,g=p-1-e.padInfo.top,m=h-1-e.padInfo.left,y=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:i,strides:u,pad:c,dimRoundingMode:l}=s,d=[1,1,1],p=Qs(a.shape,i,u,d,c,l),h=new y_(p);return t.runWebGLProgram(h,[r],a.dtype)}const b_={kernelName:Mp,backendName:"webgl",kernelFunc:x_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o;ir([r,o],"avgPoolGrad");const{filterSize:i,strides:u,pad:c}=s,l=Pn(a.shape,i,u,1,c),d=new g_(l);return t.runWebGLProgram(d,[r],a.dtype)}const $_={kernelName:Vp,backendName:"webgl",kernelFunc:w_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:a,transposeB:i}=s;return eo({a:r,b:o,transposeA:a,transposeB:i,backend:t})}const S_={kernelName:ti,backendName:"webgl",kernelFunc:v_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C_{constructor(e,t,s,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],X(e,t),X(e,s);let i="0.0";r!=null&&(X(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";o!=null&&(X(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T_{constructor(e,t,s,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],X(e,t),X(e,s);let i="vec4(0.0)";r!=null&&(X(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(X(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:a,scale:i}=n;v(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),v(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),v(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const c=[s,r,o];let l=null;a!=null&&(l=a.shape,c.push(a));let d=null;i!=null&&(d=i.shape,c.push(i));const p=I().getBool("WEBGL_PACK_NORMALIZATION")?new T_(s.shape,r.shape,o.shape,l,d,u):new C_(s.shape,r.shape,o.shape,l,d,u);return e.runWebGLProgram(p,c,c[0].dtype)},E_={kernelName:Ui,backendName:"webgl",kernelFunc:N_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I_{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=oe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=k_(this.rank);let r;const o=e.map((a,i)=>`sourceLoc.${Aa[i]} = start[${i}] + coords.${Aa[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Aa=["x","y","z","w","u","v"];function k_(n){if(n===1)return"sourceLoc";if(n<=6)return Aa.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=oe(this.rank),s=Re("coords",this.rank),r=Re("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((l,d)=>`start[${d}]`).join()});`:e.map((l,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),a=s.texData.get(o.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let i=Wl(e,xe(n.shape));r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,u+1),o}function gs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:a}=s,[i,u]=sg(r,o,a);if(Km(r,i,u),P(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=t.texData.get(r.dataId),p=Sk(d.values,i,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,p)}const{isPacked:c}=t.texData.get(r.dataId),l=Ml(r.shape,i,u);if(c||!l){const d=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new R_(u):new I_(u),p=[i];return t.runWebGLProgram(d,[r],r.dtype,p)}return t.uploadToGPU(r.dataId),__(r,i,u,t)}const A_={kernelName:Qu,backendName:"webgl",kernelFunc:gs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:a}=s;v(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((b,$)=>b*$),u=zl(r.shape,o,i),c=Gl(u.length,o.length),l=Hl(r.shape,o,i),d=fg(a,o.length),p=mg(l,a,o.length),h=[],f=F({inputs:{x:r},backend:t,attrs:{shape:u}}),g=Ae({inputs:{x:f},backend:t,attrs:{perm:c}}),m=F({inputs:{x:g},backend:t,attrs:{shape:l}}),y=gs({inputs:{x:m},backend:t,attrs:{begin:d,size:p}});return h.push(f),h.push(g),h.push(m),h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},D_={kernelName:ni,backendName:"webgl",kernelFunc:O_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a}=s,i=t.readSync(r.dataId),u=t.readSync(o.dataId),c=Cy(i,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,c)}const F_={kernelName:si,backendName:"webgl",kernelFunc:P_};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L_=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,B_=`
  return float(int(a.r) & int(b.r));
`;function V_(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=I().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=I().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const u=t.texData.get(s.dataId).values,c=t.texData.get(r.dataId).values,[l,d]=KI(s.shape,r.shape,u,c,s.dtype),p=t.makeTensorInfo(d,s.dtype),h=t.texData.get(p.dataId);return h.values=l,p}let i;return o?i=new fs(L_,s.shape,r.shape,!1):i=new An(B_,s.shape,r.shape),t.runWebGLProgram(i,[s,r],s.dtype)}const M_={kernelName:ri,backendName:"webgl",kernelFunc:V_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),i=X(Array.from(o),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const U_={kernelName:oi,backendName:"webgl",kernelFunc:W_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_="return float(a != b);",By=ve({opSnippet:z_,cpuKernelImpl:fk,dtype:"bool"}),G_={kernelName:$u,backendName:"webgl",kernelFunc:By};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cr(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ue({inputs:{x:r.complexTensorInfos.real},backend:t})}const H_={kernelName:Fu,backendName:"webgl",kernelFunc:cr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j_="return float(int(x));";function K_(n,e){const t=new Ct(n.shape,j_),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Ue({inputs:{x:r},backend:t});const a=nn(r.shape),i=Oa({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=cn({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),u}if(r.dtype==="complex64"){const a=cr({inputs:{input:r},backend:t}),i=Oa({inputs:{x:a},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(a),i}if(!Ap(r.dtype,o)){const a=Ue({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[i,u,c]=qI(a,r.shape,r.dtype,o);return t.makeTensorInfo(i,u,c)}if(o==="int32")return K_(r,t);if(o==="bool"){const a=t.makeTensorInfo([],"bool",Mt("bool",1)),u=By({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const q_={kernelName:ao,backendName:"webgl",kernelFunc:Oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hp="return ceil(x);",X_=Y({opSnippet:hp,packedOpSnippet:hp,cpuKernelImpl:XI}),Y_={kernelName:ai,backendName:"webgl",kernelFunc:X_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:a}=s;let i;I().getBool("WEBGL_PACK_CLIP")?i=new Z_(r.shape):i=new Q_(r.shape);const u=[[o],[a]];return t.runWebGLProgram(i,[r],r.dtype,u)}const eA={kernelName:ii,backendName:"webgl",kernelFunc:J_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tA{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fp(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function nA(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new tA(s.shape),a=[fp(s,r.complexTensorInfos.real),fp(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,a,a[0].dtype)}const sA={kernelName:ci,backendName:"webgl",kernelFunc:nA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rA{constructor(e){this.outputShape=[],this.outputShape=Rn(e,1),this.variableNames=e.map((a,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const i=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oA{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Rn(e,t);const s=this.outputShape,r=s.length,o=oe(r),a=Re("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,m)=>`T${m}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let g=1;g<u.length;g++)u[g]=u[g-1]+e[g][t];const c=i[t],l=i.slice(-2),d=i.join();let p=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${d}), vec2(${l.join()}));
        }`;for(let g=1;g<u.length;g++){const m=u[g-1];p+=`
        if (${c} < ${u[g]}  && ${c} >= ${u[g-1]}) {
          return getChannel(
            getT${g}(${Rr(i,c,m)}),
            vec2(${Rr(l,c,m)}));
        }`}const h=u.length,f=u[u.length-1];p+=`
        return getChannel(
          getT${h}(${Rr(i,c,f)}),
          vec2(${Rr(l,c,f)}));`,this.userCode=`
      float getValue(${i.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Rr(n,e,t){const s=n.indexOf(e);return n.map((o,a)=>a===s?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Do(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ue({inputs:{x:r.complexTensorInfos.imag},backend:t})}const aA={kernelName:qi,backendName:"webgl",kernelFunc:Do};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ns(n,e,t){const s=n[0].dtype;if(s==="complex64"){const h=n.map(b=>cr({inputs:{input:b},backend:t})),f=n.map(b=>Do({inputs:{input:b},backend:t})),g=Ns(h,e,t),m=Ns(f,e,t),y=cn({inputs:{real:g,imag:m},backend:t});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),y}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const h=n.map(S=>{const E=[-1,P(S.shape.slice(e))];return F({inputs:{x:S},backend:t,attrs:{shape:E}})}),f=h.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=Rn(h.map(S=>S.shape),1),m=h[0].shape[0]===1,y=YI(f,g,s,m),b=Rn(n.map(S=>S.shape),e),$=t.makeTensorInfo(b,s,y);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),$}const o=n.filter(h=>P(h.shape)>0),a=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const h=a?new Ct(n[0].shape,Kt):new Qt(n[0].shape,Kt);return t.runWebGLProgram(h,n,s)}const i=I().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const h=[];for(let g=0;g<o.length;g+=i){const m=o.slice(g,g+i);h.push(Ns(m,e,t))}const f=Ns(h,e,t);for(const g of h)t.disposeIntermediateTensorInfo(g);return f}if(a){const h=new oA(o.map(f=>f.shape),e);return t.runWebGLProgram(h,o,s)}const{tensors2D:u,outShape:c}=iA(o,e,t),l=new rA(u.map(h=>h.shape)),d=t.runWebGLProgram(l,u,s);u.forEach(h=>t.disposeIntermediateTensorInfo(h));const p=F({inputs:{x:d},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(d),p}function iA(n,e,t){const s=Rn(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>F({inputs:{x:o},attrs:{shape:[-1,P(o.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=me(r,e[0].shape)[0],a=e.map(c=>c.shape);ug(a,o);const i=Rn(e.map(c=>c.shape),o);if(P(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const u=e.filter(c=>P(c.shape)>0);return u.length===1?Ue({inputs:{x:u[0]},backend:t}):Ns(u,o,t)}const uA={kernelName:li,backendName:"webgl",kernelFunc:Vy};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class My{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",y=m?1:2,b=m?2:3,$=m?3:1;let S="",N="";s&&(r?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:S=`
          float activation(float x) {
            ${s}
          }
        `,N="result = activation(result);");const E=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${N}
        setOutput(result);
      }
    `}}class cA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,d=e.filterDepth,p=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wy{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Te(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,d=l;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<l;m++)p+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<l;m++)p+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(d+1)/2;m++){const y=m*2;if(p+=`
           xC = xCCorner + ${y*u};
           `,i===1){if(y<l&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?p+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<l)){const b=a%2===0?so(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:p+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?p+=`
                     xC${y+1} = xTexelC${y};
                     `:p+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<l&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<l&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<l&&(p+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<l&&(p+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<l&&(p+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let h="",f="";s&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:h=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Te(this.outputShape.length);const{dataFormat:s}=t,r=Oe(),o=s==="channelsLast",a=o?1:2,i=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let l=0;l<=1;l++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${l};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Uy({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const u=n.shape,c=s.texData.get(n.dataId),l=t.inChannels,d=u[0]*u[1]*u[2],p=t.outChannels,h=t.dataFormat==="channelsLast",f=!1,g=!1;let m;const y=[];if(o!=null){const S=to(o.shape,h);S!=null&&(o=F({inputs:{x:o},backend:s,attrs:{shape:S}}),y.push(o))}if(r!=null){const S=to(r.shape,h);S!=null&&(r=F({inputs:{x:r},backend:s,attrs:{shape:S}}),y.push(r))}if(!((d===1||p===1)&&l>Dy)&&c.isPacked&&h&&c.texture!=null&&u[2]%2!==0&&ce(c.shape.slice(-3),u.slice(-3))){const S=u[0]*u[1]*(u[2]+1),N={dataId:n.dataId,shape:[1,S,t.inChannels],dtype:n.dtype},E=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,v(Zr(c.shape,N.shape),()=>`packed reshape ${c.shape} to ${N.shape} isn't free`);const k=F({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const R=eo({a:N,b:k,backend:s,transposeA:f,transposeB:g,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),A=s.texData.get(R.dataId);v(A.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=E,A.shape=t.outShape,m=Ue({inputs:{x:R},backend:s}),m.shape=t.outShape,y.push(R)}else{const S=t.outHeight*t.outWidth,N=F({inputs:{x:n},backend:s,attrs:{shape:h?[t.batchSize,S,t.inChannels]:[t.batchSize,t.inChannels,S]}}),E=F({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=eo({a:h?N:E,b:h?E:N,transposeA:!h,transposeB:g,backend:s,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a});m=F({inputs:{x:k},backend:s,attrs:{shape:t.outShape}}),y.push(N),y.push(E),y.push(k)}for(const S of y)s.disposeIntermediateTensorInfo(S);return m}function zy({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const{filterWidth:u,filterHeight:c,inChannels:l,outWidth:d,outHeight:p,dataFormat:h}=t,f=h==="channelsLast",g=u*c*l,m=p*d,y=[t.batchSize,g,m],b=!0,$=!1,S=[];if(o!=null){const J=to(o.shape,f);J!=null&&(o=F({inputs:{x:o},backend:s,attrs:{shape:J}}),S.push(o))}if(r!=null){const J=to(r.shape,f);J!=null&&(r=F({inputs:{x:r},backend:s,attrs:{shape:J}}),S.push(r))}const N=F({inputs:{x:e},backend:s,attrs:{shape:[1,g,P(e.shape)/g]}});S.push(N);const E=new lA(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],R=s.runWebGLProgram(E,[n],"float32",k),A=F({inputs:{x:R},backend:s,attrs:{shape:y}});S.push(R),S.push(A);const O=r!=null,D=o!=null,V=i==="leakyrelu",z=i?Hs(i,!0):null,G=new Oy(f?A.shape:N.shape,f?N.shape:A.shape,f?[t.batchSize,m,t.outChannels]:[t.batchSize,t.outChannels,m],b,$,O,z,D,V),j=f?[A,N]:[N,A];if(r&&j.push(r),D&&j.push(o),V){const J=s.makeTensorInfo([],"float32",Dn(a,"float32"));j.push(J),S.push(J)}const q=s.runWebGLProgram(G,j,"float32"),Q=F({inputs:{x:q},backend:s,attrs:{shape:t.outShape}});S.push(q);for(const J of S)s.disposeIntermediateTensorInfo(J);return Q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dataFormat:u,dilations:c,dimRoundingMode:l}=s,d=os(u),p=je(r.shape,o.shape,a,c,i,l,!1,d);let h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=Uy({x:r,filter:o,convInfo:p,backend:t});else if(p.strideWidth<=2&&d==="channelsLast"&&I().getBool("WEBGL_EXP_CONV")){const g=new Wy(p),m=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=t.runWebGLProgram(g,[r,o],"float32",m)}else if(I().getBool("WEBGL_CONV_IM2COL"))h=zy({x:r,filter:o,convInfo:p,backend:t});else{const g=new My(p);h=t.runWebGLProgram(g,[r,o],"float32")}const f=F({inputs:{x:h},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(h),f}const pA={kernelName:di,backendName:"webgl",kernelFunc:dA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class fA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=s-1-e.padInfo.left,c=a?1:2,l=a?2:3,d=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class mA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,c=s-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:l}=s,d=os(u),p=je(r.shape,l,a,1,i,c,!1,d),h=new hA(p);return t.runWebGLProgram(h,[r,o],"float32")}const xA={kernelName:pi,backendName:"webgl",kernelFunc:yA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bA{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Te(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:a,strides:i,pad:u,dataFormat:c,dimRoundingMode:l}=s,d=os(c),p=je(a,o.shape,i,1,u,l,!1,d);if(I().getBool("WEBGL_PACK")&&d==="channelsLast"){const h=[[p.strideHeight,p.strideWidth]],f=new bA(p);return t.runWebGLProgram(f,[r,o],"float32",h)}else{const h=new fA(p);return t.runWebGLProgram(h,[r,o],"float32")}}const $A={kernelName:hi,backendName:"webgl",kernelFunc:wA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:u}=s,c=Zs(r.shape,o.shape,a,u,i),l=new cA(c);return t.runWebGLProgram(l,[r,o],"float32")}const SA={kernelName:fi,backendName:"webgl",kernelFunc:vA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,filterShape:u}=s,c=Zs(r.shape,u,a,1,i),l=new mA(c);return t.runWebGLProgram(l,[r,o],"float32")}const TA={kernelName:Wp,backendName:"webgl",kernelFunc:CA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NA(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:a,strides:i,inputShape:u}=s,c=Zs(u,o.shape,i,1,a),l=new gA(c);return t.runWebGLProgram(l,[r,o],"float32")}const EA={kernelName:mi,backendName:"webgl",kernelFunc:NA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IA=ms+`
  return cos(x);
`,kA=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Vn}
  return result;
`,RA=Y({opSnippet:IA,packedOpSnippet:kA}),_A={kernelName:gi,backendName:"webgl",kernelFunc:RA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AA=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,OA=Y({opSnippet:AA}),DA={kernelName:yi,backendName:"webgl",kernelFunc:OA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PA{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,u,c]=e,[l]=t,[d,p]=s;this.outputShape=[l,d,p,c];const h=r==="bilinear"?1:0,[f,g]=[`${i-1}.0`,`${u-1}.0`],[m,y,b]=d>1?[`${(i-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[$,S,N]=p>1?[`${(u-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${S};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FA=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:c}=s,l=new PA(r.shape,o.shape,i,u,c);return t.runWebGLProgram(l,[r,o,a],"float32")},LA={kernelName:wi,backendName:"webgl",kernelFunc:FA};var Ks;(function(n){n.Prod="*",n.Sum="+"})(Ks||(Ks={}));class mp{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=this.op===Ks.Prod?"1.0":"0.0",i=s?a:`getX(${gp(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",l="";s?(c=r?`end != ${u-1}`:"end != 0",l=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${u}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${oe(o)} coords = getOutputCoords();
        int end = ${yp(o,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${l};
          ${yp(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${gp(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function gp(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function yp(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gy(n,e,t,s,r,o){const a=e.shape.length,i=ct([s],a);let u=e;i!=null&&(u=Ae({inputs:{x:e},backend:t,attrs:{perm:i}}));const c=lt(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const l=u.shape[c];let d=Ue({inputs:{x:u},backend:t});for(let p=0;p<=Math.ceil(Math.log2(l))-1;p++){const h=new mp(n,u.shape,!1,o),f=[[p]],g=d;d=t.runWebGLProgram(h,[d],d.dtype,f),t.disposeIntermediateTensorInfo(g)}if(r){const p=new mp(n,u.shape,r,o),h=d;d=t.runWebGLProgram(p,[d],d.dtype),t.disposeIntermediateTensorInfo(h)}if(i!=null){const p=qc(i),h=Ae({inputs:{x:d},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(u),h}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return Gy(Ks.Prod,r,t,o,a,i)}const VA={kernelName:xi,backendName:"webgl",kernelFunc:BA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return Gy(Ks.Sum,r,t,o,a,i)}const WA={kernelName:bi,backendName:"webgl",kernelFunc:MA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a,binaryOutput:i}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),c=t.readSync(o.dataId),l=Cy(u,c,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,l)}else if(r.shape.length===2){const u=t.bufferSync(r),c=t.bufferSync(o),l=jI(u,c,a,i);return t.makeTensorInfo(l.shape,o.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const zA={kernelName:$i,backendName:"webgl",kernelFunc:UA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GA{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:a}=s,i=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],c=a==="NHWC"?r.shape[2]:r.shape[3],l=a==="NHWC"?r.shape[3]:r.shape[1],d=u*o,p=c*o,h=l/(o*o),f=a==="NHWC"?[i,d,p,h]:[i,h,d,p],g=new GA(f,o,a);return t.runWebGLProgram(g,[r],r.dtype)}const jA={kernelName:vi,backendName:"webgl",kernelFunc:HA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hy{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Te(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels;let c="",l="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,l="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jy{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Te(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,d=e.filterWidth,p=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let y=0;y<d;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(p+1)/2;y++){const b=y*2;if(h+=`
          xC = xCCorner + ${b*c};
          `,u===1){if(b<d&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?h+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const $=i%2===0?so(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:h+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):$===1?h+=`
                    xC${b+1} = xTexelC${b};
                    `:h+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(h+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(h+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(h+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let f="",g="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:c}=s;let l=u;l==null&&(l=[1,1]),v(Ge(a,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const d=je(r.shape,o.shape,a,l,i,c,!0);let p;I().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new jy(d):p=new Hy(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(p,[r,o],"float32",h)}const qA={kernelName:Si,backendName:"webgl",kernelFunc:KA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class YA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:c,filterShape:l}=s,d=je(r.shape,l,a,i,u,c,!0),p=new XA(d);return t.runWebGLProgram(p,[r,o],"float32")}const ZA={kernelName:Ci,backendName:"webgl",kernelFunc:QA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:c,inputShape:l}=s,d=je(l,o.shape,a,i,u,c,!0),p=new YA(d);return t.runWebGLProgram(p,[r,o],"float32")}const eO={kernelName:Ti,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tO{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=P(s.shape),a=F({inputs:{x:s},backend:t,attrs:{shape:[o]}}),i=new tO(o),u=t.runWebGLProgram(i,[a],a.dtype),c=F({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),c}const sO={kernelName:Ni,backendName:"webgl",kernelFunc:nO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:c,dilationWidth:l}=e,{top:d,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:u}=s,c=_h(r.shape,o.shape,a,i,"NHWC",u);let l;const d=new rO(c);l=t.runWebGLProgram(d,[r,o],"float32");const p=F({inputs:{x:l},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(l),p}const aO={kernelName:Ei,backendName:"webgl",kernelFunc:oO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:a,summedDims:i,idDims:u}=Cg(r,o.length);Ng(a.length,u,o);const{path:c,steps:l}=Eg(i,u),d=l.length;let p=null,h=a.length;const f=[];for(let g=0;g<d;++g){for(const m of l[g]){const{permutationIndices:y,expandDims:b}=Tg(h,u[m]);let $;Ig(y)?$=o[m]:($=Ae({inputs:{x:o[m]},backend:t,attrs:{perm:y}}),f.push($));const S=$.shape.slice();for(let N=0;N<b.length;++N)S.splice(b[N],0,1);ce($.shape,S)||($=F({inputs:{x:$},backend:t,attrs:{shape:S}}),f.push($)),p===null?p=$:(p=nd({inputs:{a:$,b:p},backend:t}),f.push(p))}g<d-1&&(c[g]>=0&&(p=Oo({inputs:{x:p},backend:t,attrs:{axis:c[g]-(a.length-h),keepDims:!1}}),f.push(p)),h--)}for(const g of f)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const uO={kernelName:Ri,backendName:"webgl",kernelFunc:iO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cO="return (x >= 0.0) ? x : (exp(x) - 1.0);",lO=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,dO=Y({opSnippet:cO,packedOpSnippet:lO}),pO={kernelName:_i,backendName:"webgl",kernelFunc:dO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hO="return (b >= 0.0) ? a : a * (b + 1.0);",fO=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,mO=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=I().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fs(fO,s.shape,r.shape):new An(hO,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},gO={kernelName:Up,backendName:"webgl",kernelFunc:mO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yO=`
  return vec4(equal(a, b));
`,xO="return float(a == b);",bO=ve({opSnippet:xO,packedOpSnippet:yO,dtype:"bool",cpuKernelImpl:QI}),wO={kernelName:Oi,backendName:"webgl",kernelFunc:bO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $O=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${xg};
  float a1 = ${bg};
  float a2 = ${wg};
  float a3 = ${$g};
  float a4 = ${vg};
  float a5 = ${Sg};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,vO=Y({opSnippet:$O}),SO={kernelName:Ai,backendName:"webgl",kernelFunc:vO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CO=ms+`
  return exp(x);
`,TO=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ky=Y({opSnippet:CO,packedOpSnippet:TO,cpuKernelImpl:ZI,dtype:"float32"}),NO={kernelName:Di,backendName:"webgl",kernelFunc:Ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Da(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,a=o.shape.length,i=o.shape.slice();let u=r;return r<0&&(v(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),i.splice(u,0,1),F({inputs:{x:o},backend:s,attrs:{shape:i}})}const EO={kernelName:Pi,backendName:"webgl",kernelFunc:Da};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xp="return exp(x) - 1.0;",IO=Y({opSnippet:xp,packedOpSnippet:xp,cpuKernelImpl:JI}),kO={kernelName:Fi,backendName:"webgl",kernelFunc:IO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bp{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qy(n,e,t){const s=t.texData.get(n.dataId),r=P(n.shape),o=n.shape[n.shape.length-1],a=r/o,i=F({inputs:{x:n},backend:t,attrs:{shape:[a,o]}}),u=i.shape,c=new bp("real",u,e),l=new bp("imag",u,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],p=t.runWebGLProgram(c,d,"float32"),h=t.runWebGLProgram(l,d,"float32"),f=cn({inputs:{real:p,imag:h},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h);const g=F({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(n){const{inputs:e,backend:t}=n,{input:s}=e;return qy(s,!1,t)}const _O={kernelName:Li,backendName:"webgl",kernelFunc:RO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AO{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||rs(r),o==="string"){const a=fe(o,P(s));return a.fill(r),e.makeTensorInfo(s,o,a)}else{const a=new AO(s,r),i=[[r]];return e.runWebGLProgram(a,[],o,i)}}const OO={kernelName:Bi,backendName:"webgl",kernelFunc:lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DO{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PO={kernelName:Vi,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new DO(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wp="return floor(x);",FO=Y({opSnippet:wp,packedOpSnippet:wp,cpuKernelImpl:ek}),LO={kernelName:Mi,backendName:"webgl",kernelFunc:FO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,VO=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,MO=ve({opSnippet:BO,packedOpSnippet:VO,dtype:"int32"}),WO={kernelName:Wi,backendName:"webgl",kernelFunc:MO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UO{constructor(e){this.variableNames=["A"];const t=Oe(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zO{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Oe(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO={kernelName:Br,backendName:"webgl",kernelFunc:HO};let Un,Qo=I().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function HO(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,c]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],l=[c,u],d=[c,u,o];if(i||a){const g=I().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Un==null||g!==Qo)&&(Qo=g,Un=document.createElement("canvas").getContext("2d",{willReadFrequently:Qo})),Un.canvas.width=u,Un.canvas.height=c,Un.drawImage(r,0,0,u,c),r=Un.canvas}const p=t.makeTensorInfo(l,"int32");t.texData.get(p.dataId).usage=He.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),r);const h=I().getBool("WEBGL_PACK")?new zO(d):new UO(d),f=t.runWebGLProgram(h,[p],"int32");return t.disposeData(p.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s,g=os(l),m=je(r.shape,o.shape,u,d,c,p,!1,g);let y;const b=[],$=a!=null,S=i!=null,N=h==="leakyrelu",E=()=>{const R=[r,o],A=(O,D)=>{if(D==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const V=F({inputs:{x:O},backend:t,attrs:{shape:[O.shape[0],1,1]}});return b.push(V),V}return O};if($&&R.push(A(a,l)),S&&R.push(A(i,l)),N){const O=t.makeTensorInfo([],"float32",Dn(f,"float32"));R.push(O),b.push(O)}return R};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=Uy({x:r,filter:o,convInfo:m,backend:t,bias:a,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else if(m.strideWidth<=2&&g==="channelsLast"&&I().getBool("WEBGL_EXP_CONV")){const R=h?Hs(h,!0):null,A=new Wy(m,$,R,S,N),O=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],D=E();y=t.runWebGLProgram(A,D,"float32",O)}else if(I().getBool("WEBGL_CONV_IM2COL"))y=zy({x:r,filter:o,convInfo:m,backend:t,bias:a,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const R=h?Hs(h,!1):null,A=new My(m,$,R,S,N),O=E();y=t.runWebGLProgram(A,O,"float32")}const k=F({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return b.push(y),b.forEach(R=>t.disposeIntermediateTensorInfo(R)),k}const KO={kernelName:Mr,backendName:"webgl",kernelFunc:jO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:u,pad:c,dilations:l,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=s,f=[];let g=l;g==null&&(g=[1,1]),v(Ge(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);const m=je(r.shape,o.shape,u,g,c,d,!0),y=I().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,b=p?Hs(p,y):null,$=[r,o],S=a!=null,N=i!=null,E=p==="leakyrelu";if(S&&$.push(a),N&&$.push(i),E){const O=t.makeTensorInfo([],"float32",Dn(h,"float32"));$.push(O),f.push(O)}let k;y?k=new jy(m,S,b,N,E):k=new Hy(m,S,b,N,E);const R=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],A=t.runWebGLProgram(k,$,"float32",R);return f.forEach(O=>t.disposeIntermediateTensorInfo(O)),A}const XO={kernelName:Wr,backendName:"webgl",kernelFunc:qO};class YO{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=oe(s.length);let a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QO(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,a=o[o.length-1],i=P(s.shape),[u,c,l,d]=Vl(s,r),p=F({inputs:{x:r},backend:t,attrs:{shape:[c,a]}}),h=F({inputs:{x:s},backend:t,attrs:{shape:[P(s.shape)/l,l]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=t.readSync(r.dataId),b=t.bufferSync(s),$=tk(y,b,s.dtype,c,a,l,d,s.shape,i);return t.makeTensorInfo(u,s.dtype,$.values)}const f=new YO(a,d,[c,l],s.shape),g=t.runWebGLProgram(f,[h,p],h.dtype),m=F({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),m}const ZO={kernelName:Gi,backendName:"webgl",kernelFunc:QO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JO{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=oe(this.rank),r=eD(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function eD(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xy(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:a,batchDims:i}=s,u=me(a,r.shape)[0];if(I().get("DEBUG")){const b=t.readSync(o.dataId),$=r.shape[u];for(let S=0;S<b.length;++S){const N=b[S];v(N<=$-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${$-1}]`)}}const c=zg(r,o,u,i),l=P(o.shape),d=[],p=F({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=F({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,l/c.batchSize]}});d.push(p),d.push(h);const f=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const b=t.bufferSync(h),$=t.bufferSync(p),S=nk($,b,f);return d.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(c.outputShape,S.dtype,S.values)}const g=new JO(p.shape,f),m=t.runWebGLProgram(g,[p,h],p.dtype);d.push(m);const y=F({inputs:{x:m},backend:t,attrs:{shape:c.outputShape}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const tD={kernelName:zi,backendName:"webgl",kernelFunc:Xy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD="return float(a > b);",sD=`
  return vec4(greaterThan(a, b));
`,rD=ve({opSnippet:nD,packedOpSnippet:sD,cpuKernelImpl:sk,dtype:"bool"}),oD={kernelName:Hi,backendName:"webgl",kernelFunc:rD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD="return float(a >= b);",iD=`
  return vec4(greaterThanEqual(a, b));
`,uD=ve({opSnippet:aD,packedOpSnippet:iD,dtype:"bool",cpuKernelImpl:rk}),cD={kernelName:ji,backendName:"webgl",kernelFunc:uD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lD(n){const{inputs:e,backend:t}=n,{input:s}=e;return qy(s,!0,t)}const dD={kernelName:Ki,backendName:"webgl",kernelFunc:lD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD="return float(!isnan(x) && !isinf(x));",hD=Y({opSnippet:pD,dtype:"bool"}),fD={kernelName:Xi,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD="return float(isinf(x));",gD=Y({opSnippet:mD,dtype:"bool"}),yD={kernelName:Yi,backendName:"webgl",kernelFunc:gD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xD="return float(isnan(x));",bD=Y({opSnippet:xD,dtype:"bool"}),wD={kernelName:Qi,backendName:"webgl",kernelFunc:bD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D="return float(a < b);",vD=`
  return vec4(lessThan(a, b));
`,SD=ve({opSnippet:$D,packedOpSnippet:vD,cpuKernelImpl:ok,dtype:"bool"}),CD={kernelName:Ji,backendName:"webgl",kernelFunc:SD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TD="return float(a <= b);",ND=`
  return vec4(lessThanEqual(a, b));
`,ED=ve({opSnippet:TD,packedOpSnippet:ND,cpuKernelImpl:ak,dtype:"bool"}),ID={kernelName:eu,backendName:"webgl",kernelFunc:ED};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,a=ik(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const RD={kernelName:tu,backendName:"webgl",kernelFunc:kD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _D=ms+`
  return x < 0.0 ? 0./0. : log(x);
`,AD=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,OD=Y({opSnippet:_D,packedOpSnippet:AD,cpuKernelImpl:uk}),DD={kernelName:nu,backendName:"webgl",kernelFunc:OD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PD=ms+`
  return log(1.0 + x);
`,FD=Y({opSnippet:PD}),LD={kernelName:su,backendName:"webgl",kernelFunc:FD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BD="return float(a >= 1.0 && b >= 1.0);",VD=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,MD=ve({opSnippet:BD,packedOpSnippet:VD,dtype:"bool"}),WD={kernelName:ru,backendName:"webgl",kernelFunc:MD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD="return float(!(x >= 1.0));",zD=Y({opSnippet:UD}),GD={kernelName:ou,backendName:"webgl",kernelFunc:zD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HD="return float(a >= 1.0 || b >= 1.0);",jD=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,KD=ve({opSnippet:HD,packedOpSnippet:jD,dtype:"bool"}),qD={kernelName:au,backendName:"webgl",kernelFunc:KD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XD{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YD{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${c})`:o===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QD=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:a,alpha:i,beta:u}=s,c=I().getBool("WEBGL_PACK_NORMALIZATION")?new YD(r.shape,o,a,i,u):new XD(r.shape,o,a,i,u);return t.runWebGLProgram(c,[r],r.dtype)},ZD={kernelName:iu,backendName:"webgl",kernelFunc:QD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JD{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eP=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:a}=e,{depthRadius:i,bias:u,alpha:c,beta:l}=s,d=new JD(r.shape,i,u,c,l);return t.runWebGLProgram(d,[r,o,a],r.dtype)},tP={kernelName:zp,backendName:"webgl",kernelFunc:eP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n,e,t,s){const r=P(e),a=P(n.shape)/r,i=F({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Mn(i,n.dtype,"max",s),c=F({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yy(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:a}=s,i=r.shape.length,u=me(o,r.shape);let c=u;const l=ct(c,i),d=l!=null,p=t.shouldExecuteOnCPU([r]);let h=r;if(d){if(p){const $=t.texData.get(h.dataId).values,S=new Array(i);for(let k=0;k<S.length;k++)S[k]=r.shape[l[k]];const N=ed($,r.shape,r.dtype,l,S);h=t.makeTensorInfo(S,r.dtype);const E=t.texData.get(h.dataId);E.values=N}else h=Ao(r,l,t);c=lt(c.length,i)}St("max",c,i);const[f,g]=_t(h.shape,c);let m=f;a&&(m=Ke(f,u));let y;if(p){const $=t.texData.get(h.dataId).values,S=ck($,P(g),m,r.dtype);y=t.makeTensorInfo(m,r.dtype);const N=t.texData.get(y.dataId);N.values=S}else y=nP(h,g,m,t);return d&&t.disposeIntermediateTensorInfo(h),y}const sP={kernelName:uu,backendName:"webgl",kernelFunc:Yy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rP=td+`
  return max(a, b);
`,oP=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vn+`
  return result;
`,aP=ve({opSnippet:rP,packedOpSnippet:oP,cpuKernelImpl:lk}),iP={kernelName:cu,backendName:"webgl",kernelFunc:aP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;ir(r,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:u}=s,c=1;v(Ge(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const l=Pn(r.shape,o,a,c,i,u);if(l.filterWidth===1&&l.filterHeight===1&&ce(l.inShape,l.outShape))return Ue({inputs:{x:r},backend:t});const d=new js(l,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const cP={kernelName:lu,backendName:"webgl",kernelFunc:uP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dataFormat:u,dimRoundingMode:c}=s,l=[1,1,1],d=Qs(r.shape,o,a,l,i,c,u),p=new sd(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const dP={kernelName:du,backendName:"webgl",kernelFunc:lP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,u=a-1-e.padInfo.left,c=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class hP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,d=u-1-e.padInfo.front,p=c-1-e.padInfo.top,h=l-1-e.padInfo.left,f=u*c*l-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:i,strides:u,pad:c,dimRoundingMode:l}=s,d=[1,1,1],p=Qs(a.shape,i,u,d,c,l),h=new sd(p,"max",!0),f=t.runWebGLProgram(h,[a],a.dtype),g=new hP(p),m=t.runWebGLProgram(g,[r,f],a.dtype);return t.disposeIntermediateTensorInfo(f),m}const mP={kernelName:Hp,backendName:"webgl",kernelFunc:fP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:a}=e,i=o;ir([o,a],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:d}=s,p=Pn(i.shape,u,c,1,l,d),h=!0,f=new js(p,"max",h),g=t.runWebGLProgram(f,[i],i.dtype),m=new pP(p),y=t.runWebGLProgram(m,[r,g],i.dtype);return t.disposeIntermediateTensorInfo(g),y}const yP={kernelName:Gp,backendName:"webgl",kernelFunc:gP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xP(n,e,t,s){let r=new js(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new js(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[o,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP={kernelName:pu,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=e,u=t;v(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];v(Ge(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const l=Pn(s.shape,r,o,c,a),[d,p]=xP(s,i,l,u);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wP(n,e,t,s){const r=P(e),a=P(n.shape)/r,i=F({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Mn(i,"float32","mean",s),c=F({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P={kernelName:hu,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,a=t,i=s.shape.length,u=me(o,s.shape);let c=u;const l=ct(c,i),d=l!=null,p=a.shouldExecuteOnCPU([s]),h=[];let f=s;if(d){if(p){const S=a.texData.get(f.dataId).values,N=new Array(i);for(let R=0;R<N.length;R++)N[R]=s.shape[l[R]];const E=ed(S,s.shape,s.dtype,l,N);f=a.makeTensorInfo(N,s.dtype);const k=a.texData.get(f.dataId);k.values=E}else f=Ao(s,l,a);h.push(f),c=lt(c.length,i)}St("sum",c,i);const[g,m]=_t(f.shape,c);let y=g;r&&(y=Ke(g,u));const b=wP(f,m,y,a);for(const $ of h)a.disposeIntermediateTensorInfo($);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,u=me(o,r.shape);let c=u;const l=ct(c,i);let d=r;l!=null&&(d=Ae({inputs:{x:r},backend:t,attrs:{perm:l}}),c=lt(c.length,r.shape.length)),St("min",c,i);const[p,h]=_t(d.shape,c),f=P(h),g=F({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),m=Mn(g,g.dtype,"min",t);let y;if(a){const b=Ke(p,u);y=F({inputs:{x:m},backend:t,attrs:{shape:b}})}else y=F({inputs:{x:m},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),l!=null&&t.disposeIntermediateTensorInfo(d),y}const SP={kernelName:fu,backendName:"webgl",kernelFunc:vP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CP=td+`
  return min(a, b);
`,TP=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vn+`
  return result;
`,NP=ve({opSnippet:CP,packedOpSnippet:TP,cpuKernelImpl:dk}),EP={kernelName:mu,backendName:"webgl",kernelFunc:NP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IP{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((l,d)=>l[0]+e[d]+l[1]);const r=e.length,o=oe(r),a=t.map(l=>l[0]).join(","),i=t.map((l,d)=>l[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kP{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const r=e.length,o=oe(r),a=t.map(f=>f[0]).join(","),i=t.map((f,g)=>f[0]+e[g]).join(","),u=Re("rc",r),c=Re("source",r),l=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let h="";if(r===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${u[r-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${u[r-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${u[r-1]} += 1;
          if(${l}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RP=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,a=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kP(s.shape,r,o):new IP(s.shape,r,o);return e.runWebGLProgram(a,[s],s.dtype)},_P={kernelName:gu,backendName:"webgl",kernelFunc:RP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AP=`if (b == 0.0) return NAN;
  return mod(a, b);`,OP=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vn+`
  return result;
`,DP=ve({opSnippet:AP,packedOpSnippet:OP}),PP={kernelName:yu,backendName:"webgl",kernelFunc:DP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FP{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LP=`
if (a == b) {
  return 1.0;
};
return a / b;`,BP=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Qy=ve({opSnippet:LP,packedOpSnippet:BP,checkOutOfBounds:!0}),VP={kernelName:ki,backendName:"webgl",kernelFunc:Qy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $p="return a - b;",Zy=ve({opSnippet:$p,packedOpSnippet:$p,supportsComplex:!0,cpuKernelImpl:Ak}),MP={kernelName:bc,backendName:"webgl",kernelFunc:Zy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,a=me([o],r.shape),i=Yy({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=Ke(i.shape,a),c=F({inputs:{x:i},backend:t,attrs:{shape:u}}),l=Zy({inputs:{a:r,b:c},backend:t}),d=Ky({inputs:{x:l},backend:t}),p=Oo({inputs:{x:d},backend:t,attrs:{axis:a,keepDims:!1}}),h=F({inputs:{x:p},backend:t,attrs:{shape:u}}),f=Qy({inputs:{a:d,b:h},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),f}const WP={kernelName:ic,backendName:"webgl",kernelFunc:Jy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UP(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:a,normalized:i}=s,u=i?r:Jy({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=u.shape[0],l=u.shape[1],d=new FP(c,l,o),p=[[a]],h=t.runWebGLProgram(d,[u],"int32",p);return i||t.disposeIntermediateTensorInfo(u),h}const zP={kernelName:xu,backendName:"webgl",kernelFunc:UP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GP=dt+`
  return -x;
`,HP=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function jP(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[a,i]=hk(o.values,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,a)}let r;return I().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qt(s.shape,HP):r=new Ct(s.shape,GP),t.runWebGLProgram(r,[s],s.dtype)}const KP={kernelName:wu,backendName:"webgl",kernelFunc:jP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP=Nl;function XP(n){nt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=s,c=t.readSync(r.dataId),l=t.readSync(o.dataId),{selectedIndices:d}=qP(c,l,a,i,u);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const YP={kernelName:vu,backendName:"webgl",kernelFunc:XP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QP=El;function ZP(n){nt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=s,l=t.readSync(r.dataId),d=t.readSync(o.dataId),{selectedIndices:p,validOutputs:h}=QP(l,d,a,i,u,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const JP={kernelName:Su,backendName:"webgl",kernelFunc:ZP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eF=Il;function tF(n){nt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=s,l=t.readSync(r.dataId),d=t.readSync(o.dataId),p=a,h=i,f=u,g=c,{selectedIndices:m,selectedScores:y}=eF(l,d,p,h,f,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const nF={kernelName:Cu,backendName:"webgl",kernelFunc:tF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sF{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rF=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:a,onValue:i,offValue:u}=s,c=P(r.shape),l=new sF(c,a,i,u),d=F({inputs:{x:r},backend:t,attrs:{shape:[c]}}),p=t.runWebGLProgram(l,[d],o);t.disposeIntermediateTensorInfo(d);const h=[...r.shape,a],f=F({inputs:{x:p},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(p),f},oF={kernelName:Nu,backendName:"webgl",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=cr({inputs:{input:s},backend:t}),o=no({inputs:{x:r},backend:t}),a=Do({inputs:{input:s},backend:t}),i=no({inputs:{x:a},backend:t}),u=cn({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lr({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const aF={kernelName:Ec,backendName:"webgl",kernelFunc:no};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ex(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=cr({inputs:{input:s},backend:t}),o=ex({inputs:{x:r},backend:t}),a=Do({inputs:{input:s},backend:t}),i=no({inputs:{x:a},backend:t}),u=cn({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lr({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const iF={kernelName:Tu,backendName:"webgl",kernelFunc:ex};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Da({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(l=>{Ce(o,l.shape,"All tensors passed to stack must have matching shapes"),v(a===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(l=>{const d=Da({inputs:{input:l},backend:t,attrs:{dim:r}});return i.push(d),d}),c=Vy({inputs:u,backend:t,attrs:{axis:r}});return i.forEach(l=>t.disposeIntermediateTensorInfo(l)),c}const cF={kernelName:Eu,backendName:"webgl",kernelFunc:uF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lF{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,l)=>c[0]+e[l]+c[1]);const r=e.length,o=oe(r),a=t.map(c=>c[0]).join(","),i=t.map((c,l)=>c[0]+e[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dF{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,m)=>g[0]+e[m]+g[1]);const r=e.length,o=oe(r),a=t.map(g=>g[0]).join(","),i=t.map((g,m)=>g[0]+e[m]).join(","),u=Re("rc",r),c=Re("source",r),l=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${l}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${l}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=r===1?2:4;g<m;g++)f+=`
        ${p[g]}
        if (${h}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${d});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tx=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:a}=s;if(P(r.shape)===0){const c=o.map((l,d)=>l[0]+r.shape[d]+l[1]);return lr({backend:t,attrs:{shape:c,value:a,dtype:r.dtype}})}const i=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dF(r.shape,o,a):new lF(r.shape,o,a),u=[[a]];return t.runWebGLProgram(i,[r],r.dtype,u)},pF={kernelName:Iu,backendName:"webgl",kernelFunc:tx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,fF=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vn+`
  return result;
`,mF=ve({opSnippet:hF,packedOpSnippet:fF}),gF={kernelName:ku,backendName:"webgl",kernelFunc:mF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,u=[],c=me(o,r.shape);let l=c;const d=ct(l,i);let p=r;d!=null&&(p=Ae({inputs:{x:r},backend:t,attrs:{perm:d}}),l=lt(l.length,i),u.push(p)),St("prod",l,i);let h;if(t.shouldExecuteOnCPU([p])){const f=t.texData.get(p.dataId).values,{outVals:g,outShape:m,outDtype:y}=mk(p.shape,p.dtype,f,l);h=t.makeTensorInfo(m,y,g)}else{const[f,g]=_t(p.shape,l),m=P(g),y=F({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),b=co(r.dtype),$=Mn(y,b,"prod",t);h=F({inputs:{x:$},backend:t,attrs:{shape:f}}),u.push(y),u.push($)}if(a){u.push(h);const f=Ke(h.shape,c);h=F({inputs:{x:h},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const xF={kernelName:_u,backendName:"webgl",kernelFunc:yF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,{outputRaggedRank:i}=s,u=r.map(y=>t.readSync(y.dataId)),c=r.map(y=>y.shape),l=t.readSync(o.dataId),d=t.readSync(a.dataId),[p,h,f]=gk(u,c,l,o.shape,o.dtype,d,a.shape,i),g=p.map(y=>t.makeTensorInfo([y.length],"int32",y)),m=t.makeTensorInfo(f,o.dtype,h);return g.concat([m])}const wF={kernelName:Au,backendName:"webgl",kernelFunc:bF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,a=t.readSync(s.dataId),i=t.readSync(r.dataId),u=t.readSync(o.dataId),[c,l]=yk(a,s.shape,s.dtype,i,r.shape,u,o.shape),d=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([l.length],s.dtype,l);return[d,p]}const vF={kernelName:Ou,backendName:"webgl",kernelFunc:$F};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=s,c=t.readSync(r.dataId),l=t.readSync(o.dataId),d=t.readSync(a.dataId),p=i.map(m=>t.readSync(m.dataId)),h=i.map(m=>m.shape),[f,g]=xk(c,r.shape,l,o.shape,o.dtype,d,a.shape,p,h,u);return t.makeTensorInfo(f,o.dtype,g)}const CF={kernelName:Du,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:a}=t,i=bk(s,r,o,a);return e.makeTensorInfo([i.length],a,i)},TF={kernelName:Pu,backendName:"webgl",kernelFunc:nx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF="return 1.0 / x;",EF=Y({opSnippet:NF}),IF={kernelName:Lu,backendName:"webgl",kernelFunc:EF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kF=dt+`
  return (x < 0.0) ? 0.0 : x;
`,RF=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_F=Y({opSnippet:kF,packedOpSnippet:RF}),AF={kernelName:Bu,backendName:"webgl",kernelFunc:_F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=dt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,DF=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,PF=Y({opSnippet:OF,packedOpSnippet:DF}),FF={kernelName:Uu,backendName:"webgl",kernelFunc:PF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LF{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,s,c];const l=[r&&t>1?i-1:i,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BF{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,s,c];const l=[r&&t>1?i-1:i,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[u,c]=i,l=I().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new BF(r.shape,u,c,o,a):new LF(r.shape,u,c,o,a);return t.runWebGLProgram(l,[r],"float32")}const MF={kernelName:Wu,backendName:"webgl",kernelFunc:VF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WF{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,i]=e,u=[s&&a>1?r-1:r,s&&i>1?o-1:o],c=[s&&a>1?a-1:a,s&&i>1?i-1:i],l=u[0]/c[0],d=u[1]/c[1],p=1/l,h=1/d,f=Math.ceil(p)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,i=new WF(o.shape,r.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const zF={kernelName:Kp,backendName:"webgl",kernelFunc:UF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GF{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,s,c];const l=[r&&t>1?i-1:i,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let h;o?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HF{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,u,c]=e;this.outputShape=[a,t,s,c];const l=[r&&t>1?i-1:i,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let h;o?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[u,c]=i,l=I().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HF(r.shape,u,c,o,a):new GF(r.shape,u,c,o,a);return t.runWebGLProgram(l,[r],r.dtype)}const KF={kernelName:Mu,backendName:"webgl",kernelFunc:jF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qF{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,i]=e,u=[s&&a>1?r-1:r,s&&i>1?o-1:o],c=[s&&a>1?a-1:a,s&&i>1?i-1:i],l=u[0]/c[0],d=u[1]/c[1],p=1/l,h=1/d,f=Math.ceil(p)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,i=new qF(o.shape,r.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const YF={kernelName:jp,backendName:"webgl",kernelFunc:XF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QF{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,o=e.map((i,u)=>r(u)).join(","),a=oe(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZF{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Re("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=oe(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${o}){
            result.g = ${c(r.slice())};
          }
          if(${a}) {
            result.b = ${l(r.slice())};
            if(${o}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return p(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",p(f)}function l(f){return f[s-2]="("+f[s-2]+" + 1)",p(f)}function d(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",p(f)}function p(f){const g=e.map((b,$)=>h($,f)),m=g.join(","),y=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function h(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,a=r.shape.length,i=me(o,r.shape);if(a===0)return Ue({inputs:{x:r},backend:t});const u=I().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZF(r.shape,i):new QF(r.shape,i);return t.runWebGLProgram(u,[r],r.dtype)}const eL={kernelName:zu,backendName:"webgl",kernelFunc:JF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tL{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL={kernelName:kc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:a}=e,i=t,u=new tL(s.shape,o),[c,l]=hg(a,s.shape[1],s.shape[2]),d=[[c,l,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(u,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sL=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,rL=Y({opSnippet:sL}),oL={kernelName:Gu,backendName:"webgl",kernelFunc:rL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL="return inversesqrt(x);",iL=Y({opSnippet:aL,cpuKernelImpl:wk}),uL={kernelName:Hu,backendName:"webgl",kernelFunc:iL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rd{constructor(e,t,s,r,o,a,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const c=oe(o.length),l=oe(a.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let h="";r===1?h="i":r===2&&(h="i, coords[1]");const f=`getUpdates(${h})`;let g="";u&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cL{constructor(e,t,s,r,o,a,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const c=oe(o.length),l=oe(a.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let h="";r===1?h="i":r===2&&(h="i, coords[1]");const f=`getUpdates(${h})`;let g="";u&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lL(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=or(o,r,a),p=[d/c,c];if(d===0)return t.makeTensorInfo(a,r.dtype);const h=F({inputs:{x:r},backend:t,attrs:{shape:[u,i]}}),f=F({inputs:{x:o},backend:t,attrs:{shape:[u,c]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let m;I().getBool("WEBGL_PACK")?m=new cL(u,i,h.shape.length,f.shape.length,l,p):m=new rd(u,i,h.shape.length,f.shape.length,l,p);const y=t.runWebGLProgram(m,[f,h,g],f.dtype),b=F({inputs:{x:y},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(g),b}const dL={kernelName:ju,backendName:"webgl",kernelFunc:lL};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pL{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=I().getNumber("WEBGL_VERSION")===2?o:a,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hL(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:a}=s,i=new pL(r.shape[0],r.shape[1],o.shape[1],a),u=[[r.shape[1]]];return t.runWebGLProgram(i,[r,o],"int32",u)}const fL={kernelName:qu,backendName:"webgl",kernelFunc:hL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mL{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let l=0;l<t.length;l++)c.push(`${i[l]}`),l<e&&u.push(`${i[l]}`);r=u.join(),o=c.join()}const a=oe(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,a=new mL(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,o],wt(r.dtype,o.dtype))}const yL={kernelName:Xu,backendName:"webgl",kernelFunc:gL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xL=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${gg};
  float scale = ${yg};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,bL=Y({opSnippet:xL}),wL={kernelName:Yu,backendName:"webgl",kernelFunc:bL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L=ms+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,vL=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,SL=Y({opSnippet:$L,packedOpSnippet:vL,cpuKernelImpl:vk}),CL={kernelName:tc,backendName:"webgl",kernelFunc:SL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TL=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,NL=Y({opSnippet:TL}),EL={kernelName:ec,backendName:"webgl",kernelFunc:NL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL=ms+`
  return sin(x);
`,kL=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Vn}
  return result;
`,RL=Y({opSnippet:IL,packedOpSnippet:kL}),_L={kernelName:Zu,backendName:"webgl",kernelFunc:RL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AL=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,OL=Y({opSnippet:AL}),DL={kernelName:Ju,backendName:"webgl",kernelFunc:OL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PL=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,FL=Y({opSnippet:PL}),LL={kernelName:nc,backendName:"webgl",kernelFunc:FL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BL=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:a}=s;v(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((y,b)=>y*b),u=[[0,0]];u.push(...a);for(let y=1+o.length;y<r.shape.length;++y)u.push([0,0]);const c=[],l=tx({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),d=zl(l.shape,o,i,!1),p=Gl(d.length,o.length,!1),h=Hl(l.shape,o,i,!1),f=F({inputs:{x:l},backend:t,attrs:{shape:d}}),g=Ae({inputs:{x:f},backend:t,attrs:{perm:p}}),m=F({inputs:{x:g},backend:t,attrs:{shape:h}});return c.push(l),c.push(f),c.push(g),c.forEach(y=>t.disposeIntermediateTensorInfo(y)),m},VL={kernelName:oc,backendName:"webgl",kernelFunc:BL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=t.readSync(s.dataId),u=t.readSync(r.dataId),c=t.readSync(o.dataId),l=t.readSync(a.dataId)[0],[d,p,h,f,g]=Ck(i,s.shape,s.dtype,u,r.dtype,c,l);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],r.dtype,h),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const WL={kernelName:uc,backendName:"webgl",kernelFunc:ML};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UL(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.readSync(r.dataId)),i=t.readSync(s.dataId),u=Array.from(t.readSync(o.dataId)),[c,l,d]=Tk(i,s.shape,s.dtype,a,u);return[t.makeTensorInfo(l,s.dtype,c),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const zL={kernelName:cc,backendName:"webgl",kernelFunc:UL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=t.readSync(s.dataId),i=t.readSync(r.dataId),u=t.readSync(o.dataId),[c,l]=Ny(a,s.shape,s.dtype,i,u,!0);return t.makeTensorInfo(l,s.dtype,c)}const HL={kernelName:lc,backendName:"webgl",kernelFunc:GL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jL(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=t.readSync(s.dataId),i=t.readSync(r.dataId),u=t.readSync(o.dataId),[c,l]=Ny(a,s.shape,s.dtype,i,u);return t.makeTensorInfo(l,s.dtype,c)}const KL={kernelName:dc,backendName:"webgl",kernelFunc:jL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:i}=s,{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:p}=or(o,r,i),h=!1;if(o.dtype==="string"){const y=t.bufferSync(r),b=t.bufferSync(o),$=Sn(t.readSync(a.dataId)[0]),S=$k(y,b,i,p,l,c,u,d,$,h);return t.makeTensorInfo(i,S.dtype,S.values)}const f=new rd(c,u,r.shape.length,o.shape.length,d,[p,1],h),g=t.runWebGLProgram(f,[o,r,a],o.dtype),m=F({inputs:{x:g},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(g),m}const XL={kernelName:pc,backendName:"webgl",kernelFunc:qL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,i=me(a,r.shape)[0],u=kg(r,o,i),c=r.shape.length,l=new Array(c).fill(0),d=r.shape.slice();return u.map(p=>{const h=[...d];h[i]=p;const f=gs({inputs:{x:r},backend:t,attrs:{begin:l,size:h}});return l[i]+=p,f})}const QL={kernelName:ac,backendName:"webgl",kernelFunc:YL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vp="return sqrt(x);",ZL=Y({opSnippet:vp,packedOpSnippet:vp,cpuKernelImpl:Nk}),JL={kernelName:sc,backendName:"webgl",kernelFunc:ZL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eB="return x * x;",tB=Y({opSnippet:eB}),nB={kernelName:qp,backendName:"webgl",kernelFunc:tB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sp="return (a - b) * (a - b);",sB=ve({opSnippet:Sp,packedOpSnippet:Sp}),rB={kernelName:hc,backendName:"webgl",kernelFunc:sB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),a=ts(o),i=Ek(a,"string",s);return t.makeTensorInfo(r.shape,"string",i)}const aB={kernelName:fc,backendName:"webgl",kernelFunc:oB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=dt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Ct(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const uB={kernelName:Ic,backendName:"webgl",kernelFunc:iB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cB{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=oe(s.length),a=oe(s.length);let i="";if(r===1)i="coords * strides + begin";else{let u=0;i=s.map((c,l)=>(u++,s.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${u-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:a,strides:i,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:h,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:b,end:$,strides:S}=rg(r.shape,o,a,i,u,c,l,d,p);let N;if(g)N=F({inputs:{x:r},backend:t,attrs:{shape:f}});else if(m||y){v(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=qm(b,$,S),R=gs({inputs:{x:r},backend:t,attrs:{begin:b,size:k}});N=F({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([r])){const R=t.readSync(r.dataId),A=le(r.shape,r.dtype,R),O=Ik(h,A,S,b);N=t.makeTensorInfo(f,r.dtype,O.values)}else{const R=new cB(b,S,h);N=t.runWebGLProgram(R,[r],r.dtype)}const E=F({inputs:{x:N},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(N),E}const dB={kernelName:mc,backendName:"webgl",kernelFunc:lB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:c}=s,{data:l,dataSplits:d}=e,p=t.readSync(l.dataId),h=t.readSync(d.dataId),[f,g]=kk(p,h,r,o,a,i,u,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",g)]}const hB={kernelName:gc,backendName:"webgl",kernelFunc:pB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=t.readSync(o.dataId),u=t.readSync(a.dataId)[0],[c,l,d]=Rk(i,u,r),p=l.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",l),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const mB={kernelName:yc,backendName:"webgl",kernelFunc:fB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(o.dataId),i=_k(a,r);return t.makeTensorInfo(o.shape,"int32",i)}const yB={kernelName:xc,backendName:"webgl",kernelFunc:gB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xB="return tan(x);",bB=Y({opSnippet:xB}),wB={kernelName:wc,backendName:"webgl",kernelFunc:bB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $B=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,vB=Y({opSnippet:$B}),SB={kernelName:$c,backendName:"webgl",kernelFunc:vB};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CB(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:a}=e,{sliceRank:i,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=or(a,o,r.shape),p=[d/c,c];if(d===0)return t.makeTensorInfo(r.shape,o.dtype);const h=F({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=F({inputs:{x:a},backend:t,attrs:{shape:[u,c]}}),g=F({inputs:{x:r},backend:t,attrs:{shape:p}}),m=new rd(u,i,h.shape.length,f.shape.length,l,p,!1,!0),y=t.runWebGLProgram(m,[f,h,g],g.dtype),b=F({inputs:{x:y},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),b}const TB={kernelName:Ku,backendName:"webgl",kernelFunc:CB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NB{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=oe(this.rank),o=EB(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function EB(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),c=r.dtype==="string"?u.map(p=>Sn(p)):u,l=le(r.shape,r.dtype,c),d=Ok(l,o);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const a=new NB(r.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const IB={kernelName:uo,backendName:"webgl",kernelFunc:sx};class kB{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class RB{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pn(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Cp(n){let e=1;for(;e<n;)e*=2;return e}function _B(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:a}=s,i=I().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=I().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,l=c[c.length-1];if(t.shouldExecuteOnCPU([r])||l<i||o>u){const O=t.readSync(r.dataId),[D,V]=Dk(O,c,r.dtype,o,a);return[t.makeTensorInfo(D.shape,D.dtype,D.values),t.makeTensorInfo(V.shape,V.dtype,V.values)]}if(o===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(l===1)return[r,lr({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const d=t.texData.get(r.dataId),p=d!==null&&d.isPacked,h=p?t.unpackTensor(r):r,g=P(c)/l,m=F({inputs:{x:h},attrs:{shape:[g,l]},backend:t});p&&pn(t,h);const y=Cp(o),b=Cp(l);let $=null;const S=()=>$===null?[m,m]:[m,$],N=(O,D,V)=>{const z=S(),G=new kB(V),q=[[l],[$===null?1:0],[Number.NEGATIVE_INFINITY],[O],[D]],Q=$;$=t.runWebGLProgram(G,z,"int32",q),pn(t,Q)};for(let O=1;O<y;O*=2){const D=O*2;for(let V=O;V>=1;V/=2)N(D,V,[g,b])}for(let O=b;O>y;O/=2){const D=S(),V=new RB([g,O/2]),G=[[l],[$===null?1:0],[y]],j=$;$=t.runWebGLProgram(V,D,"int32",G),pn(t,j);const q=y/2,Q=q*2;for(let J=q;J>=1;J/=2)N(Q,J,$.shape)}let E=$;$=gs({inputs:{x:$},backend:t,attrs:{begin:0,size:[g,o]}}),pn(t,E);let k=Xy({inputs:{x:m,indices:$},backend:t,attrs:{axis:1,batchDims:1}});pn(t,m);const R=c.slice(0,-1);R.push(o),E=$,$=F({inputs:{x:$},attrs:{shape:R},backend:t}),pn(t,E);const A=k;return k=F({inputs:{x:k},attrs:{shape:R},backend:t}),pn(t,A),[k,$]}const AB={kernelName:vc,backendName:"webgl",kernelFunc:_B};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OB{constructor(e,t,s,r,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:c}=s,[l,d,p,h]=r.shape,[f,g]=c??[d,p],m=[l,f,g,h],y=new OB(d,p,a,i,u,m);return t.runWebGLProgram(y,[r,o],"float32")}const PB={kernelName:Sc,backendName:"webgl",kernelFunc:DB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;ir(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(o.dataId),{outputValues:i,outputShape:u,indices:c}=Pk(a,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,i),s.makeTensorInfo([c.length],"int32",c)]}const LB={kernelName:Cc,backendName:"webgl",kernelFunc:FB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r,i=a.shape.length,u=r.shape[o],c=new Array(i-1);let l=0;for(let g=0;g<i;g++)g!==o&&(c[l++]=a.shape[g]);const d=[],p=new Array(i).fill(0),h=a.shape.slice();h[o]=1;const f=new Array(u);for(let g=0;g<f.length;g++){p[o]=g;const m=gs({inputs:{x:a},backend:t,attrs:{begin:p,size:h}}),y=F({inputs:{x:m},backend:t,attrs:{shape:c}});f[g]=y,d.push(m)}return d.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const VB={kernelName:Tc,backendName:"webgl",kernelFunc:BB};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MB{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/s);this.outputShape=[r,i];const u="0.0",c="sumValue",l=Math.floor(s/4)*4,d=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let h="";o%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:a}=s,i=r.shape.length,u=[];let c=0;const l=ct([c],i);let d=r;l!=null&&(d=Ae({inputs:{x:r},backend:t,attrs:{perm:l}}),u.push(d),c=lt(1,i)[0]);const p=Ug(d.shape,c,a),h=P([d.shape[c]]),f=F({inputs:{x:d},backend:t,attrs:{shape:[-1,h]}});u.push(f);const g=co(r.dtype),m=(S,N,E,k,R)=>{const A=S.shape[0],O=S.shape[1],D=Wg(O,R),V={windowSize:D,inSize:O,batchSize:A,numSegments:R},z=new MB(V,N),G=t.compileAndRun(z,[S,E],k);if(u.push(G),G.shape[1]===R)return G;const j=nx({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),q=sx({inputs:{x:j},backend:t,attrs:{reps:[O/D]}});return u.push(j),u.push(q),m(G,N,q,k,R)},y=m(f,"unsortedSegmentSum",o,g,a),b=F({inputs:{x:y},backend:t,attrs:{shape:p}});let $=b;if(l!=null){u.push(b);const S=qc(l);$=Ae({inputs:{x:$},backend:t,attrs:{perm:S}})}return u.forEach(S=>t.disposeIntermediateTensorInfo(S)),$}const UB={kernelName:Nc,backendName:"webgl",kernelFunc:WB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zB=[NR,IR,_R,DR,FR,VR,WR,zR,KR,XR,ZR,t_,r_,u_,d_,h_,m_,b_,$_,S_,E_,D_,F_,M_,U_,q_,Y_,eA,cR,sA,uA,pA,xA,$A,SA,TA,EA,_A,DA,LA,VA,WA,zA,jA,qA,ZA,eO,sO,aO,uO,pO,gO,wO,SO,NO,EO,kO,_O,OO,PO,LO,WO,GO,KO,XO,ZO,tD,oD,cD,uR,dD,aA,fD,yD,wD,dR,CD,ID,RD,DD,LD,WD,GD,qD,ZD,tP,sP,iP,cP,dP,mP,yP,bP,$P,SP,EP,_P,PP,zP,fR,KP,YP,JP,nF,G_,oF,iF,cF,pF,gF,hR,xF,wF,vF,CF,TF,H_,VP,IF,AF,FF,gR,MF,zF,KF,YF,eL,nL,oL,uL,dL,fL,yL,wL,CL,EL,_L,DL,A_,WP,LL,VL,WL,zL,HL,KL,XL,QL,JL,nB,rB,aB,uB,dB,hB,mB,yB,MP,SR,wB,SB,TB,IB,AB,PB,CR,LB,VB,UB,aF];for(const n of zB)Rc(n);export{Qr as S,jB as U,HB as k};
